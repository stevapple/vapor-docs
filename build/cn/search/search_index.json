{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u8fd9\u662f Vapor \u7684\u4e2d\u6587\u6587\u6863\u3002 Vapor\u662f Swift \u8bed\u8a00\u6700\u5e38\u7528\u7684 Web \u7f51\u7edc\u6846\u67b6\uff0c\u6ca1\u6709\u4e4b\u4e00\u3002\u5b83\u53ef\u4ee5\u4e3a\u60a8\u7684\u7f51\u7ad9\u6216 API \u63d0\u4f9b\u7cbe\u7f8e\u7684\u9875\u9762\u5c55\u793a\u548c\u7b80\u6613\u7684\u4f7f\u7528\u65b9\u5f0f\u3002 \u5f00\u59cb \u00b6 \u5982\u679c\u60a8\u662f\u7b2c\u4e00\u6b21\u4f7f\u7528 Vapor\uff0c\u8bf7\u524d\u5f80 \u5b89\u88c5 \u2192 macOS \u5b89\u88c5 Swift \u548c Vapor \u5f00\u53d1\u73af\u5883\u3002 Vapor \u5b89\u88c5\u5b8c\u6210\u540e\uff0c\u8bf7\u67e5\u770b \u5f00\u59cb \u2192 \u4f60\u597d\uff0c\u4e16\u754c \u793a\u4f8b\uff0c\u4ee5\u521b\u5efa\u60a8\u7684\u7b2c\u4e00\u4e2a Vapor \u5e94\u7528\u7a0b\u5e8f\uff01 \u5176\u4ed6\u8d44\u6e90 \u00b6 \u8fd9\u91cc\u662f\u5176\u4ed6\u4e00\u4e9b\u6709\u5173 Vapor \u6846\u67b6\u7684\u5185\u5bb9\uff0c\u4ee5\u4f9b\u5b66\u4e60\u4e0e\u4ea4\u6d41\u3002 \u540d\u79f0 \u63cf\u8ff0 \u94fe\u63a5 Vapor Discord \u4e0e\u6570\u5343\u540d Vapor \u5f00\u53d1\u4eba\u5458\u4ea4\u6d41\u3002 \u8bbf\u95ee \u2192 API docs \u901a\u8fc7\u4ee3\u7801\u6ce8\u91ca\u81ea\u52a8\u751f\u6210\u7684\u6587\u6863\u3002 \u8bbf\u95ee \u2192 Stack Overflow \u4f7f\u7528 Vapor \u6807\u7b7e\u63d0\u95ee\u548c\u56de\u7b54\u76f8\u5173\u95ee\u9898\u3002 \u8bbf\u95ee \u2192 Swift Forums \u5728 Swift.org \u8bba\u575b\u7684 Vapor \u4e13\u9898\u53d1\u5e03\u3002 \u8bbf\u95ee \u2192 Source Code \u4e86\u89e3 Vapor \u7684\u5de5\u4f5c\u539f\u7406\u3002 \u8bbf\u95ee \u2192 GitHub Issues \u5728 GitHub \u4e0a\u62a5\u544a\u9519\u8bef\u6216\u63d0\u4ea4\u529f\u80fd\u3002 \u8bbf\u95ee \u2192 \u4f5c\u8005 \u00b6 OHeroJ , \u664b\u5148\u68ee , cit117 \u4ee5\u53ca Vapor \u793e\u533a\u7684\u6570\u767e\u540d\u6210\u5458\u3002","title":"\u5e8f"},{"location":"#_1","text":"\u5982\u679c\u60a8\u662f\u7b2c\u4e00\u6b21\u4f7f\u7528 Vapor\uff0c\u8bf7\u524d\u5f80 \u5b89\u88c5 \u2192 macOS \u5b89\u88c5 Swift \u548c Vapor \u5f00\u53d1\u73af\u5883\u3002 Vapor \u5b89\u88c5\u5b8c\u6210\u540e\uff0c\u8bf7\u67e5\u770b \u5f00\u59cb \u2192 \u4f60\u597d\uff0c\u4e16\u754c \u793a\u4f8b\uff0c\u4ee5\u521b\u5efa\u60a8\u7684\u7b2c\u4e00\u4e2a Vapor \u5e94\u7528\u7a0b\u5e8f\uff01","title":"\u5f00\u59cb"},{"location":"#_2","text":"\u8fd9\u91cc\u662f\u5176\u4ed6\u4e00\u4e9b\u6709\u5173 Vapor \u6846\u67b6\u7684\u5185\u5bb9\uff0c\u4ee5\u4f9b\u5b66\u4e60\u4e0e\u4ea4\u6d41\u3002 \u540d\u79f0 \u63cf\u8ff0 \u94fe\u63a5 Vapor Discord \u4e0e\u6570\u5343\u540d Vapor \u5f00\u53d1\u4eba\u5458\u4ea4\u6d41\u3002 \u8bbf\u95ee \u2192 API docs \u901a\u8fc7\u4ee3\u7801\u6ce8\u91ca\u81ea\u52a8\u751f\u6210\u7684\u6587\u6863\u3002 \u8bbf\u95ee \u2192 Stack Overflow \u4f7f\u7528 Vapor \u6807\u7b7e\u63d0\u95ee\u548c\u56de\u7b54\u76f8\u5173\u95ee\u9898\u3002 \u8bbf\u95ee \u2192 Swift Forums \u5728 Swift.org \u8bba\u575b\u7684 Vapor \u4e13\u9898\u53d1\u5e03\u3002 \u8bbf\u95ee \u2192 Source Code \u4e86\u89e3 Vapor \u7684\u5de5\u4f5c\u539f\u7406\u3002 \u8bbf\u95ee \u2192 GitHub Issues \u5728 GitHub \u4e0a\u62a5\u544a\u9519\u8bef\u6216\u63d0\u4ea4\u529f\u80fd\u3002 \u8bbf\u95ee \u2192","title":"\u5176\u4ed6\u8d44\u6e90"},{"location":"#_3","text":"OHeroJ , \u664b\u5148\u68ee , cit117 \u4ee5\u53ca Vapor \u793e\u533a\u7684\u6570\u767e\u540d\u6210\u5458\u3002","title":"\u4f5c\u8005"},{"location":"async/","text":"Async \u00b6 You may have noticed some APIs in Vapor expect or return a generic EventLoopFuture type. If this is your first time hearing about futures, they might seem a little confusing at first. But don't worry, this guide will show you how to take advantage of their powerful APIs. Promises and futures are related, but distinct, types. Promises are used to create futures. Most of the time, you will be working with futures returned by Vapor's APIs and you will not need to worry about creating promises. type description mutability EventLoopFuture Reference to a value that may not be available yet. read-only EventLoopPromise A promise to provide some value asynchronously. read/write Futures are an alternative to callback-based asynchronous APIs. Futures can be chained and transformed in ways that simple closures cannot. Transforming \u00b6 Just like optionals and arrays in Swift, futures can be mapped and flat-mapped. These are the most common operations you will perform on futures. method argument description map (T) -> U Maps a future value to a different value. flatMapThrowing (T) throws -> U Maps a future value to a different value or an error. flatMap (T) -> EventLoopFuture<U> Maps a future value to different future value. transform U Maps a future to an already available value. If you look at the method signatures for map and flatMap on Optional<T> and Array<T> , you will see that they are very similar to the methods available on EventLoopFuture<T> . map \u00b6 The map method allows you to transform the future's value to another value. Because the future's value may not be available yet (it may be the result of an asynchronous task) we must provide a closure to accept the value. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... /// Map the future string to an integer let futureInt = futureString . map { string in print ( string ) // The actual String return Int ( string ) ?? 0 } /// We now have a future integer print ( futureInt ) // EventLoopFuture<Int> flatMapThrowing \u00b6 The flatMapThrowing method allows you to transform the future's value to another value or throw an error. Info Because throwing an error must create a new future internally, this method is prefixed flatMap even though the closure does not accept a future return. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... /// Map the future string to an integer let futureInt = futureString . flatMapThrowing { string in print ( string ) // The actual String // Convert the string to an integer or throw an error guard let int = Int ( string ) else { throw Abort (...) } return int } /// We now have a future integer print ( futureInt ) // EventLoopFuture<Int> flatMap \u00b6 The flatMap method allows you to transform the future's value to another future value. It gets the name \"flat\" map because it is what allows you to avoid creating nested futures (e.g., EventLoopFuture<EventLoopFuture<T>> ). In other words, it helps you keep your generics flat. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... /// Assume we have created an HTTP client let client : Client = ... /// flatMap the future string to a future response let futureResponse = futureString . flatMap { string in client . get ( string ) // EventLoopFuture<ClientResponse> } /// We now have a future response print ( futureResponse ) // EventLoopFuture<ClientResponse> Info If we instead used map in the above example, we would have ended up with: EventLoopFuture<EventLoopFuture<ClientResponse>> . To call a throwing method inside of a flatMap , use Swift's do / catch keywords and create a completed future . /// Assume future string and client from previous example. let futureResponse = futureString . flatMap { string in let url : URL do { // Some synchronous throwing method. url = try convertToURL ( string ) } catch { // Use event loop to make pre-completed future. return eventLoop . makeFailedFuture ( error ) } return client . get ( url ) // EventLoopFuture<ClientResponse> } transform \u00b6 The transform method allows you to modify a future's value, ignoring the existing value. This is especially useful for transforming the results of EventLoopFuture<Void> where the actual value of the future is not important. Tip EventLoopFuture<Void> , sometimes called a signal, is a future whose sole purpose is to notify you of completion or failure of some async operation. /// Assume we get a void future back from some API let userDidSave : EventLoopFuture < Void > = ... /// Transform the void future to an HTTP status let futureStatus = userDidSave . transform ( to : HTTPStatus . ok ) print ( futureStatus ) // EventLoopFuture<HTTPStatus> Even though we have supplied an already-available value to transform , this is still a transformation . The future will not complete until all previous futures have completed (or failed). Chaining \u00b6 The great part about transformations on futures is that they can be chained. This allows you to express many conversions and subtasks easily. Let's modify the examples from above to see how we can take advantage of chaining. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... /// Assume we have created an HTTP client let client : Client = ... /// Transform the string to a url, then to a response let futureResponse = futureString . flatMapThrowing { string in guard let url = URL ( string : string ) else { throw Abort (. badRequest , reason : \"Invalid URL string: \\( string ) \" ) } return url }. flatMap { url in client . get ( url ) } print ( futureResponse ) // EventLoopFuture<ClientResponse> After the initial call to map, there is a temporary EventLoopFuture<URL> created. This future is then immediately flat-mapped to a EventLoopFuture<Response> Future \u00b6 Let's take a look at some other methods for using EventLoopFuture<T> . makeFuture \u00b6 You can use an event loop to create pre-completed future with either the value or an error. // Create a pre-succeeded future. let futureString : EventLoopFuture < String > = eventLoop . makeSucceededFuture ( \"hello\" ) // Create a pre-failed future. let futureString : EventLoopFuture < String > = eventLoop . makeFailedFuture ( error ) whenComplete \u00b6 You can use whenComplete to add a callback that will be executed when the future succeeds or fails. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... futureString . whenComplete { result in switch result { case . success ( let string ): print ( string ) // The actual String case . failure ( let error ): print ( error ) // A Swift Error } } Note You can add as many callbacks to a future as you want. Wait \u00b6 You can use .wait() to synchronously wait for the future to be completed. Since a future may fail, this call is throwing. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... /// Block until the string is ready let string = try futureString . wait () print ( string ) /// String wait() can only be used on a background thread or the main thread, i.e., in configure.swift . It can not be used on an event loop thread, i.e., in route closures. Warning Attempting to call wait() on an event loop thread will cause an assertion failure. Promise \u00b6 Most of the time, you will be transforming futures returned by calls to Vapor's APIs. However, at some point you may need to create a promise of your own. To create a promise, you will need access to an EventLoop . You can get access to an event loop from Application or Request depending on context. let eventLoop : EventLoop // Create a new promise for some string. let promiseString = eventLoop . makePromise ( of : String . self ) print ( promiseString ) // EventLoopPromise<String> print ( promiseString . futureResult ) // EventLoopFuture<String> // Completes the associated future. promiseString . succeed ( \"Hello\" ) // Fails the associated future. promiseString . fail (...) Info A promise can only be completed once. Any subsequent completions will be ignored. Promises can be completed ( succeed / fail ) from any thread. This is why promises require an event loop to be initialized. Promises ensure that the completion action gets returned to its event loop for execution. Event Loop \u00b6 When your application boots, it will usually create one event loop for each core in the CPU it is running on. Each event loop has exactly one thread. If you are familiar with event loops from Node.js, the ones in Vapor are similar. The main difference is that Vapor can run multiple event loops in one process since Swift supports multi-threading. Each time a client connects to your server, it will be assigned to one of the event loops. From that point on, all communication between the server and that client will happen on that same event loop (and by association, that event loop's thread). The event loop is responsible for keeping track of each connected client's state. If there is a request from the client waiting to be read, the event loop triggers a read notification, causing the data to be read. Once the entire request is read, any futures waiting for that request's data will be completed. In route closures, you can access the current event loop via Request . req . eventLoop . makePromise ( of : ...) Warning Vapor expects that route closures will stay on req.eventLoop . If you hop threads, you must ensure access to Request and the final response future all happen on the request's event loop. Outside of route closures, you can get one of the available event loops via Application . app . eventLoopGroup . next (). makePromise ( of : ...) hop \u00b6 You can change a future's event loop using hop . futureString . hop ( to : otherEventLoop ) Blocking \u00b6 Calling blocking code on an event loop thread can prevent your application from responding to incoming requests in a timely manner. An example of a blocking call would be something like libc.sleep(_:) . router . get ( \"hello\" ) { req in /// Puts the event loop's thread to sleep. sleep ( 5 ) /// Returns a simple string once the thread re-awakens. return \"Hello, world!\" } sleep(_:) is a command that blocks the current thread for the number of seconds supplied. If you do blocking work like this directly on an event loop, the event loop will be unable to respond to any other clients assigned to it for the duration of the blocking work. In other words, if you do sleep(5) on an event loop, all of the other clients connected to that event loop (possibly hundreds or thousands) will be delayed for at least 5 seconds. Make sure to run any blocking work in the background. Use promises to notify the event loop when this work is done in a non-blocking way. router . get ( \"hello\" ) { req -> EventLoopFuture < String > in /// Create a new void promise let promise = req . eventLoop . makePromise ( of : Void . self ) /// Dispatch some work to happen on a background thread req . application . threadPool . submit { _ in /// Puts the background thread to sleep /// This will not affect any of the event loops sleep ( 5 ) /// When the \"blocking work\" has completed, /// complete the promise and its associated future. promise . succeed () } /// Wait for the future to be completed, /// then transform the result to a simple String return promise . futureResult . transform ( to : \"Hello, world!\" ) } Not all blocking calls will be as obvious as sleep(_:) . If you are suspicious that a call you are using may be blocking, research the method itself or ask someone. The sections below go over how methods can block in more detail. I/O Bound \u00b6 I/O bound blocking means waiting on a slow resource like a network or hard disk which can be orders of magnitude slower than the CPU. Blocking the CPU while you wait for these resources results in wasted time. Danger Never make blocking I/O bound calls directly on an event loop. All of Vapor's packages are built on SwiftNIO and use non-blocking I/O. However, there are many Swift packages and C libraries in the wild that use blocking I/O. Chances are if a function is doing disk or network IO and uses a synchronous API (no callbacks or futures) it is blocking. CPU Bound \u00b6 Most of the time during a request is spent waiting for external resources like database queries and network requests to load. Because Vapor and SwiftNIO are non-blocking, this downtime can be used for fulfilling other incoming requests. However, some routes in your application may need to do heavy CPU bound work as the result of a request. While an event loop is processing CPU bound work, it will be unable to respond to other incoming requests. This is normally fine since CPUs are fast and most CPU work web applications do is lightweight. But this can become a problem if routes with long running CPU work are preventing requests to faster routes from being responded to quickly. Identifying long running CPU work in your app and moving it to background threads can help improve the reliability and responsiveness of your service. CPU bound work is more of a gray area than I/O bound work, and it is ultimately up to you to determine where you want to draw the line. A common example of heavy CPU bound work is Bcrypt hashing during user signup and login. Bcrypt is deliberately very slow and CPU intensive for security reasons. This may be the most CPU intensive work a simple web application actually does. Moving hashing to a background thread can allow the CPU to interleave event loop work while calculating hashes which results in higher concurrency.","title":"Async"},{"location":"async/#async","text":"You may have noticed some APIs in Vapor expect or return a generic EventLoopFuture type. If this is your first time hearing about futures, they might seem a little confusing at first. But don't worry, this guide will show you how to take advantage of their powerful APIs. Promises and futures are related, but distinct, types. Promises are used to create futures. Most of the time, you will be working with futures returned by Vapor's APIs and you will not need to worry about creating promises. type description mutability EventLoopFuture Reference to a value that may not be available yet. read-only EventLoopPromise A promise to provide some value asynchronously. read/write Futures are an alternative to callback-based asynchronous APIs. Futures can be chained and transformed in ways that simple closures cannot.","title":"Async"},{"location":"async/#transforming","text":"Just like optionals and arrays in Swift, futures can be mapped and flat-mapped. These are the most common operations you will perform on futures. method argument description map (T) -> U Maps a future value to a different value. flatMapThrowing (T) throws -> U Maps a future value to a different value or an error. flatMap (T) -> EventLoopFuture<U> Maps a future value to different future value. transform U Maps a future to an already available value. If you look at the method signatures for map and flatMap on Optional<T> and Array<T> , you will see that they are very similar to the methods available on EventLoopFuture<T> .","title":"Transforming"},{"location":"async/#map","text":"The map method allows you to transform the future's value to another value. Because the future's value may not be available yet (it may be the result of an asynchronous task) we must provide a closure to accept the value. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... /// Map the future string to an integer let futureInt = futureString . map { string in print ( string ) // The actual String return Int ( string ) ?? 0 } /// We now have a future integer print ( futureInt ) // EventLoopFuture<Int>","title":"map"},{"location":"async/#flatmapthrowing","text":"The flatMapThrowing method allows you to transform the future's value to another value or throw an error. Info Because throwing an error must create a new future internally, this method is prefixed flatMap even though the closure does not accept a future return. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... /// Map the future string to an integer let futureInt = futureString . flatMapThrowing { string in print ( string ) // The actual String // Convert the string to an integer or throw an error guard let int = Int ( string ) else { throw Abort (...) } return int } /// We now have a future integer print ( futureInt ) // EventLoopFuture<Int>","title":"flatMapThrowing"},{"location":"async/#flatmap","text":"The flatMap method allows you to transform the future's value to another future value. It gets the name \"flat\" map because it is what allows you to avoid creating nested futures (e.g., EventLoopFuture<EventLoopFuture<T>> ). In other words, it helps you keep your generics flat. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... /// Assume we have created an HTTP client let client : Client = ... /// flatMap the future string to a future response let futureResponse = futureString . flatMap { string in client . get ( string ) // EventLoopFuture<ClientResponse> } /// We now have a future response print ( futureResponse ) // EventLoopFuture<ClientResponse> Info If we instead used map in the above example, we would have ended up with: EventLoopFuture<EventLoopFuture<ClientResponse>> . To call a throwing method inside of a flatMap , use Swift's do / catch keywords and create a completed future . /// Assume future string and client from previous example. let futureResponse = futureString . flatMap { string in let url : URL do { // Some synchronous throwing method. url = try convertToURL ( string ) } catch { // Use event loop to make pre-completed future. return eventLoop . makeFailedFuture ( error ) } return client . get ( url ) // EventLoopFuture<ClientResponse> }","title":"flatMap"},{"location":"async/#transform","text":"The transform method allows you to modify a future's value, ignoring the existing value. This is especially useful for transforming the results of EventLoopFuture<Void> where the actual value of the future is not important. Tip EventLoopFuture<Void> , sometimes called a signal, is a future whose sole purpose is to notify you of completion or failure of some async operation. /// Assume we get a void future back from some API let userDidSave : EventLoopFuture < Void > = ... /// Transform the void future to an HTTP status let futureStatus = userDidSave . transform ( to : HTTPStatus . ok ) print ( futureStatus ) // EventLoopFuture<HTTPStatus> Even though we have supplied an already-available value to transform , this is still a transformation . The future will not complete until all previous futures have completed (or failed).","title":"transform"},{"location":"async/#chaining","text":"The great part about transformations on futures is that they can be chained. This allows you to express many conversions and subtasks easily. Let's modify the examples from above to see how we can take advantage of chaining. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... /// Assume we have created an HTTP client let client : Client = ... /// Transform the string to a url, then to a response let futureResponse = futureString . flatMapThrowing { string in guard let url = URL ( string : string ) else { throw Abort (. badRequest , reason : \"Invalid URL string: \\( string ) \" ) } return url }. flatMap { url in client . get ( url ) } print ( futureResponse ) // EventLoopFuture<ClientResponse> After the initial call to map, there is a temporary EventLoopFuture<URL> created. This future is then immediately flat-mapped to a EventLoopFuture<Response>","title":"Chaining"},{"location":"async/#future","text":"Let's take a look at some other methods for using EventLoopFuture<T> .","title":"Future"},{"location":"async/#makefuture","text":"You can use an event loop to create pre-completed future with either the value or an error. // Create a pre-succeeded future. let futureString : EventLoopFuture < String > = eventLoop . makeSucceededFuture ( \"hello\" ) // Create a pre-failed future. let futureString : EventLoopFuture < String > = eventLoop . makeFailedFuture ( error )","title":"makeFuture"},{"location":"async/#whencomplete","text":"You can use whenComplete to add a callback that will be executed when the future succeeds or fails. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... futureString . whenComplete { result in switch result { case . success ( let string ): print ( string ) // The actual String case . failure ( let error ): print ( error ) // A Swift Error } } Note You can add as many callbacks to a future as you want.","title":"whenComplete"},{"location":"async/#wait","text":"You can use .wait() to synchronously wait for the future to be completed. Since a future may fail, this call is throwing. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... /// Block until the string is ready let string = try futureString . wait () print ( string ) /// String wait() can only be used on a background thread or the main thread, i.e., in configure.swift . It can not be used on an event loop thread, i.e., in route closures. Warning Attempting to call wait() on an event loop thread will cause an assertion failure.","title":"Wait"},{"location":"async/#promise","text":"Most of the time, you will be transforming futures returned by calls to Vapor's APIs. However, at some point you may need to create a promise of your own. To create a promise, you will need access to an EventLoop . You can get access to an event loop from Application or Request depending on context. let eventLoop : EventLoop // Create a new promise for some string. let promiseString = eventLoop . makePromise ( of : String . self ) print ( promiseString ) // EventLoopPromise<String> print ( promiseString . futureResult ) // EventLoopFuture<String> // Completes the associated future. promiseString . succeed ( \"Hello\" ) // Fails the associated future. promiseString . fail (...) Info A promise can only be completed once. Any subsequent completions will be ignored. Promises can be completed ( succeed / fail ) from any thread. This is why promises require an event loop to be initialized. Promises ensure that the completion action gets returned to its event loop for execution.","title":"Promise"},{"location":"async/#event-loop","text":"When your application boots, it will usually create one event loop for each core in the CPU it is running on. Each event loop has exactly one thread. If you are familiar with event loops from Node.js, the ones in Vapor are similar. The main difference is that Vapor can run multiple event loops in one process since Swift supports multi-threading. Each time a client connects to your server, it will be assigned to one of the event loops. From that point on, all communication between the server and that client will happen on that same event loop (and by association, that event loop's thread). The event loop is responsible for keeping track of each connected client's state. If there is a request from the client waiting to be read, the event loop triggers a read notification, causing the data to be read. Once the entire request is read, any futures waiting for that request's data will be completed. In route closures, you can access the current event loop via Request . req . eventLoop . makePromise ( of : ...) Warning Vapor expects that route closures will stay on req.eventLoop . If you hop threads, you must ensure access to Request and the final response future all happen on the request's event loop. Outside of route closures, you can get one of the available event loops via Application . app . eventLoopGroup . next (). makePromise ( of : ...)","title":"Event Loop"},{"location":"async/#hop","text":"You can change a future's event loop using hop . futureString . hop ( to : otherEventLoop )","title":"hop"},{"location":"async/#blocking","text":"Calling blocking code on an event loop thread can prevent your application from responding to incoming requests in a timely manner. An example of a blocking call would be something like libc.sleep(_:) . router . get ( \"hello\" ) { req in /// Puts the event loop's thread to sleep. sleep ( 5 ) /// Returns a simple string once the thread re-awakens. return \"Hello, world!\" } sleep(_:) is a command that blocks the current thread for the number of seconds supplied. If you do blocking work like this directly on an event loop, the event loop will be unable to respond to any other clients assigned to it for the duration of the blocking work. In other words, if you do sleep(5) on an event loop, all of the other clients connected to that event loop (possibly hundreds or thousands) will be delayed for at least 5 seconds. Make sure to run any blocking work in the background. Use promises to notify the event loop when this work is done in a non-blocking way. router . get ( \"hello\" ) { req -> EventLoopFuture < String > in /// Create a new void promise let promise = req . eventLoop . makePromise ( of : Void . self ) /// Dispatch some work to happen on a background thread req . application . threadPool . submit { _ in /// Puts the background thread to sleep /// This will not affect any of the event loops sleep ( 5 ) /// When the \"blocking work\" has completed, /// complete the promise and its associated future. promise . succeed () } /// Wait for the future to be completed, /// then transform the result to a simple String return promise . futureResult . transform ( to : \"Hello, world!\" ) } Not all blocking calls will be as obvious as sleep(_:) . If you are suspicious that a call you are using may be blocking, research the method itself or ask someone. The sections below go over how methods can block in more detail.","title":"Blocking"},{"location":"async/#io-bound","text":"I/O bound blocking means waiting on a slow resource like a network or hard disk which can be orders of magnitude slower than the CPU. Blocking the CPU while you wait for these resources results in wasted time. Danger Never make blocking I/O bound calls directly on an event loop. All of Vapor's packages are built on SwiftNIO and use non-blocking I/O. However, there are many Swift packages and C libraries in the wild that use blocking I/O. Chances are if a function is doing disk or network IO and uses a synchronous API (no callbacks or futures) it is blocking.","title":"I/O Bound"},{"location":"async/#cpu-bound","text":"Most of the time during a request is spent waiting for external resources like database queries and network requests to load. Because Vapor and SwiftNIO are non-blocking, this downtime can be used for fulfilling other incoming requests. However, some routes in your application may need to do heavy CPU bound work as the result of a request. While an event loop is processing CPU bound work, it will be unable to respond to other incoming requests. This is normally fine since CPUs are fast and most CPU work web applications do is lightweight. But this can become a problem if routes with long running CPU work are preventing requests to faster routes from being responded to quickly. Identifying long running CPU work in your app and moving it to background threads can help improve the reliability and responsiveness of your service. CPU bound work is more of a gray area than I/O bound work, and it is ultimately up to you to determine where you want to draw the line. A common example of heavy CPU bound work is Bcrypt hashing during user signup and login. Bcrypt is deliberately very slow and CPU intensive for security reasons. This may be the most CPU intensive work a simple web application actually does. Moving hashing to a background thread can allow the CPU to interleave event loop work while calculating hashes which results in higher concurrency.","title":"CPU Bound"},{"location":"authentication/","text":"Authentication \u00b6 Authentication is the act of verifying a user's identity. This is done through the verification of credentials like a username and password or unique token. Authentication (sometimes called auth/c) is distinct from authorization (auth/z) which is the act of verifying a previously authenticated user's permissions to perform certain tasks. Introduction \u00b6 Vapor's Authentication API provides support for authenticating a user via the Authorization header, using Basic and Bearer . It also supports authenticating a user via the data decoded from the Content API. Authentication is implemented by creating an Authenticator which contains the verification logic. An authenticator can be used to protect individual route groups or an entire app. The following authenticator helpers ship with Vapor: Protocol Description RequestAuthenticator Base authenticator capable of creating middleware. BasicAuthenticator Authenticates Basic authorization header. BearerAuthenticator Authenticates Bearer authorization header. UserTokenAuthenticator Authenticates a token type with associated user. CredentialsAuthenticator Authenticates a credentials payload from the request body. If authentication is successful, the authenticator adds the verified user to req.auth . This user can then be accessed using req.auth.get(_:) in routes protected by the authenticator. If authentication fails, the user is not added to req.auth and any attempts to access it will fail. Authenticatable \u00b6 To use the Authentication API, you first need a user type that conforms to Authenticatable . This can be a struct , class , or even a Fluent Model . The following examples assume this simple User struct that has one property: name . import Vapor struct User : Authenticatable { var name : String } Each example below will create an authenticator named UserAuthenticator . Route \u00b6 Authenticators are middleware and be be used for protecting routes. let protected = app . grouped ( UserAuthenticator ()) protected . get ( \"me\" ) { req -> String in try req . auth . require ( User . self ). name } req.auth.require is used to fetch the authenticated User . If authentication failed, this method will throw an error, protecting the route. Guard Middleware \u00b6 You can also use GuardMiddleware in your route group to ensure that a user has been authenticated before reaching your route handler. let protected = app . grouped ( UserAuthenticator ()) . grouped ( User . guardMiddleware ()) Requiring authentication is not done by the authenticator middleware to allow for composition of authenticators. Read more about composition below. Basic \u00b6 Basic authentication sends a username and password in the Authorization header. The username and password are concatenated with a colon (e.g. test:secret ), base-64 encoded, and prefixed with \"Basic \" . The following example request encodes the username test with password secret . GET /me HTTP / 1.1 Authorization : Basic dGVzdDpzZWNyZXQ= Basic authentication is typically used once to log a user in and generate a token. This minimizes how frequently the user's sensitive password must be sent. You should never send Basic authorization over a plaintext or unverified TLS connection. To implement Basic authentication in your app, create a new authenticator conforming to BasicAuthenticator . Below is an example authenticator hard-coded to verify the request from above. import Vapor struct UserAuthenticator : BasicAuthenticator { typealias User = App . User func authenticate ( basic : BasicAuthorization , for request : Request ) -> EventLoopFuture < User ? > { guard basic . username == \"test\" && basic . password == \"secret\" else { return request . eventLoop . makeSucceededFuture ( nil ) } let test = User ( name : \"Vapor\" ) return request . eventLoop . makeSucceededFuture ( test ) } } This protocol requires you to implement authenticate(basic:for:) which will be called when an incoming request contains the Authorization: Basic ... header. A BasicAuthorization struct containing the username and password is passed to the method. In this test authenticator, the username and password are tested against hard-coded values. In a real authenticator, you might check against a database or external API. This is why the authenticate method allows you to return a future. Tip Passwords should never be stored in a database as plaintext. Always use password hashes for comparison. If the authentication parameters are correct, in this case matching the hard-coded values, a User named Vapor is returned. If the authentication parameters do not match, nil is returned, which signifies authentication failed. If you add this authenticator to your app, and test the route defined above, you should see the name \"Vapor\" returned for a successful login. If the credentials are not correct, you should see a 401 Unauthorized error. Bearer \u00b6 Bearer authentication sends a token in the Authorization header. The token is prefixed with \"Bearer \" . The following example request sends the token foo . GET /me HTTP / 1.1 Authorization : Bearer foo Bearer authentication is commonly used for authentication of API endpoints. The user typically requests a Bearer token by sending credentials like a username and password to a login endpoint. This token may last minutes or days depending on the application's needs. As long as the token is valid, the user can use it in place of his or her credentials to authenticate against the API. If the token becomes invalid, a new one can be generated using the login endpoint. To implement Bearer authentication in your app, create a new authenticator conforming to BearerAuthenticator . Below is an example authenticator hard-coded to verify the request from above. import Vapor struct UserAuthenticator : BearerAuthenticator { typealias User = App . User func authenticate ( bearer : BearerAuthorization , for request : Request ) -> EventLoopFuture < User ? > { guard bearer . token == \"foo\" else { return request . eventLoop . makeSucceededFuture ( nil ) } let test = User ( name : \"Vapor\" ) return request . eventLoop . makeSucceededFuture ( test ) } } This protocol requires you to implement authenticate(bearer:for:) which will be called when an incoming request contains the Authorization: Bearer ... header. A BearerAuthorization struct containing the token is passed to the method. In this test authenticator, the token is tested against a hard-coded value. In a real authenticator, you might verify the token by checking against a database or using cryptographic measures, like is done with JWT. This is why the authenticate method allows you to return a future. Tip When implementing token verification, it's important to consider horizontal scalability. If your application needs to handle many users concurrently, authentication can be a potential bottlneck. Consider how your design will scale across multiple instances of your application running at once. If the authentication parameters are correct, in this case matching the hard-coded value, a User named Vapor is returned. If the authentication parameters do not match, nil is returned, which signifies authentication failed. If you add this authenticator to your app, and test the route defined above, you should see the name \"Vapor\" returned for a successful login. If the credentials are not correct, you should see a 401 Unauthorized error. Composition \u00b6 Multiple authenticators can be composed (combined together) to create more complex endpoint authentication. Since an authenticator middleware will not reject the request if authentication fails, more than one of these middleware can be chained together. Authenticators can composed in two key ways. Composing Methods \u00b6 The first method of authentication composition is chaining more than one authenticator for the same user type. Take the following example: app . grouped ( UserPasswordAuthenticator ()) . grouped ( UserTokenAuthenticator ()) . grouped ( User . guardMiddleware ()) . post ( \"login\" ) { req in let user = try req . auth . require ( User . self ) // Do something with user. } This example assumes two authenticators UserPasswordAuthenticator and UserTokenAuthenticator that both authenticate User . Both of these authenticators are added to the route group. Finally, GuardMiddleware is added after the authenticators to require that User was successfully authenticated. This composition of authenticators results in a route that can be accessed by either password or token. Such a route could allow a user to login and generate a token, then continue to use that token to generate new tokens. Composing Users \u00b6 The second method of authentication composition is chaining authenticators for different user types. Take the following example: app . grouped ( AdminAuthenticator ()) . grouped ( UserAuthenticator ()) . get ( \"secure\" ) { req in guard req . auth . has ( Admin . self ) || req . auth . has ( User . self ) else { throw Abort (. unauthorized ) } // Do something. } This example assumes two authenticators AdminAuthenticator and UserAuthenticator that authenticate Admin and User , respectively. Both of these authenticators are added to the route group. Instead of using GuardMiddleware , a check in the route handler is added to see if either Admin or User were authenticated. If not, an error is thrown. This composition of authenticators results in a route that can be accessed by two different types of users with potentially different methods of authentication. Such a route could allow for normal user authentication while still giving access to a super-user. Manual \u00b6 You can also handle authentication manually using req.auth . This is especially useful for testing. To manually log a user in, use req.auth.login(_:) . Any Authenticatable user can be passed to this method. req . auth . login ( User ( name : \"Vapor\" )) To get the authenticated user, use req.auth.require(_:) let user : User = try req . auth . require ( User . self ) print ( user . name ) // String You can also use req.auth.get(_:) if you don't want to automatically throw an error when authentication fails. let user = req . auth . get ( User . self ) print ( user ?. name ) // String? To unauthenticate a user, pass the user type to req.auth.logout(_:) . req . auth . logout ( User . self ) Fluent \u00b6 Fluent defines two protocols ModelAuthenticatable and ModelTokenAuthenticatable which can be added to your existing models. Conforming your models to these protocols allows for the creation of authenticators for protecting endpoints. ModelTokenAuthenticatable authenticates with a Bearer token. This is what you use to protect most of your endpoints. ModelAuthenticatable authenticates with username and password and is used by a single endpoint for generating tokens. This guide assumes you are familiar with Fluent and have successfully configured your app to use a database. If you are new to Fluent, start with the overview . User \u00b6 To start, you will need a model representing the user that will be authenticated. For this guide, we'll be using the following model, but you are free to use an existing model. import Fluent import Vapor final class User : Model , Content { static let schema = \"users\" @ ID ( key : . id ) var id : UUID ? @ Field ( key : \"name\" ) var name : String @ Field ( key : \"email\" ) var email : String @ Field ( key : \"password_hash\" ) var passwordHash : String init () { } init ( id : UUID ? = nil , name : String , email : String , passwordHash : String ) { self . id = id self . name = name self . email = email self . passwordHash = passwordHash } } The model must be able to store a username, in this case an email, and a password hash. The corresponding migration for this example model is here: import Fluent import Vapor extension User { struct Migration : Fluent . Migration { var name : String { \"CreateUser\" } func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"users\" ) . id () . field ( \"name\" , . string , . required ) . field ( \"email\" , . string , . required ) . field ( \"password_hash\" , . string , . required ) . create () } func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"users\" ). delete () } } } Don't forget to add the migration to app.migrations . app . migrations . add ( User . Migration ()) The first thing you will need is an endpoint to create new users. Let's use POST /users . Create a Content struct representing the data this endpoint expects. import Vapor extension User { struct Create : Content { var name : String var email : String var password : String var confirmPassword : String } } If you like, you can conform this struct to Validatable to add validation requirements. import Vapor extension User . Create : Validatable { static func validations ( _ validations : inout Validations ) { validations . add ( \"name\" , as : String . self , is : ! . empty ) validations . add ( \"email\" , as : String . self , is : . email ) validations . add ( \"password\" , as : String . self , is : . count ( 8. ..)) } } Now you can create the POST /users endpoint. app . post ( \"users\" ) { req -> EventLoopFuture < User > in try User . Create . validate ( req ) let create = try req . content . decode ( User . Create . self ) guard create . password == create . confirmPassword else { throw Abort (. badRequest , reason : \"Passwords did not match\" ) } let user = try User ( name : create . name , email : create . email , passwordHash : Bcrypt . hash ( create . password ) ) return user . save ( on : req . db ) . map { user } } This endpoint validates the incoming request, decodes the User.Create struct, and checks that the passwords match. It then uses the decoded data to create a new User and saves it to the database. The plaintext password is hashed using Bcrypt before saving to the database. Build and run the project, making sure to migrate the database first, then use the following request to create a new user. POST /users HTTP / 1.1 Content-Length : 97 Content-Type : application/json { \"name\" : \"Vapor\" , \"email\" : \"test@vapor.codes\" , \"password\" : \"secret\" , \"confirmPassword\" : \"secret\" } Model Authenticatable \u00b6 Now that you have a user model and an endpoint to create new users, let's conform the model to ModelAuthenticatable . This will allow for the model to be authenticated using username and password. import Fluent import Vapor extension User : ModelAuthenticatable { static let usernameKey = \\ User . $ email static let passwordHashKey = \\ User . $ passwordHash func verify ( password : String ) throws -> Bool { try Bcrypt . verify ( password , created : self . passwordHash ) } } This extension adds ModelAuthenticatable conformance to User . The first two properties specify which fields should be used for storing the username and password hash respectively. The \\ notation creates a key path to the fields that Fluent can use to access them. The last requirement is a method for verifying plaintext passwords sent in the Basic authentication header. Since we're using Bcrypt to hash the password during signup, we'll use Bcrypt to verify that the supplied password matches the stored password hash. Now that the User conforms to ModelAuthenticatable , we can create an authenticator for protecting the login route. let passwordProtected = app . grouped ( User . authenticator ()) passwordProtected . post ( \"login\" ) { req -> User in try req . auth . require ( User . self ) } ModelAuthenticatable adds a static method authenticator for creating an authenticator. Test that this route works by sending the following request. POST /login HTTP / 1.1 Authorization : Basic dGVzdEB2YXBvci5jb2RlczpzZWNyZXQ= This request passes the username test@vapor.codes and password secret via the Basic authentication header. You should see the previously created user returned. While you could theoretically use Basic authentication to protect all of your endpoints, it's recommended to use a separate token instead. This minimizes how often you must send the user's sensitive password over the Internet. It also makes authentication much faster since you only need to perform password hashing during login. User Token \u00b6 Create a new model for representing user tokens. import Fluent import Vapor final class UserToken : Model , Content { static let schema = \"user_tokens\" @ ID ( key : . id ) var id : UUID ? @ Field ( key : \"value\" ) var value : String @ Parent ( key : \"user_id\" ) var user : User init () { } init ( id : UUID ? = nil , value : String , userID : User . IDValue ) { self . id = id self . value = value self . $ user . id = userID } } This model must have a value field for storing the token's unique string. It must also have a parent-relation to the user model. You may add additional properties to this token as you see fit, such as an expiration date. Next, create a migration for this model. import Fluent extension UserToken { struct Migration : Fluent . Migration { var name : String { \"CreateUserToken\" } func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"user_tokens\" ) . id () . field ( \"value\" , . string , . required ) . field ( \"user_id\" , . uuid , . required , . references ( \"users\" , \"id\" )) . unique ( on : \"value\" ) . create () } func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"user_tokens\" ). delete () } } } Notice that this migration makes the value field unique. It also creates a foreign key reference between the user_id field and the users table. Don't forget to add the migration to app.migrations . app . migrations . add ( UserToken . Migration ()) Finally, add a method on User for generating a new token. This method will be used during login. extension User { func generateToken () throws -> UserToken { try . init ( value : [ UInt8 ]. random ( count : 16 ). base64 , userID : self . requireID () ) } } Here we're using [UInt8].random(count:) to generate a random token value. For this example, 16 bytes, or 128 bits, of random data are being used. You can adjust this number as you see fit. The random data is then base-64 encoded to make it easy to transmit in HTTP headers. Now that you can generate user tokens, update the POST /login route to create and return a token. let passwordProtected = app . grouped ( User . authenticator ()) passwordProtected . post ( \"login\" ) { req -> EventLoopFuture < UserToken > in let user = try req . auth . require ( User . self ) let token = try user . generateToken () return token . save ( on : req . db ) . map { token } } Test that this route works by using the same login request from above. You should now get a token upon logging in that looks something like: 8gtg300Jwdhc/Ffw784EXA== Hold onto the token you get as we'll use it shortly. Model Token Authenticatable \u00b6 Conform UserToken to ModelTokenAuthenticatable . This will allow for tokens to authenticate your User model. import Vapor import Fluent extension UserToken : ModelTokenAuthenticatable { static let valueKey = \\ UserToken . $ value static let userKey = \\ UserToken . $ user var isValid : Bool { true } } The first protocol requirement specifies which field stores the token's unique value. This is the value that will be sent in the Bearer authentication header. The second requirement specifies the parent-relation to the User model. This is how Fluent will look up the authenticated user. The final requirement is an isValid boolean. If this is false , the token will be deleted from the database and the user will not be authenticated. For simplicity, we'll make the tokens eternal by hard-coding this to true . Now that the token conforms to ModelTokenAuthenticatable , you can create an authenticator for protecting routes. Create a new endpoint GET /me for getting the currently authenticated user. let tokenProtected = app . grouped ( UserToken . authenticator ()) tokenProtected . get ( \"me\" ) { req -> User in try req . auth . require ( User . self ) } Similar to User , UserToken now has a static authenticator() method that can generate an authenticator. The authenticator will attempt to find a matching UserToken using the value provided in the Bearer authentication header. If it finds a match, it will fetch the related User and authenticate it. Test that this route works by sending the following HTTP request where the token is the value you saved from the POST /login request. GET /me HTTP / 1.1 Authorization : Bearer <token> You should see the authenticated User returned. Session \u00b6 Vapor's Session API can be used to automatically persist user authentication between requests. This works by storing a unique identifier for the user in the request's session data after successful login. On subsequent requests, the user's identifier is fetched from the session and used to authenticate the user before calling your route handler. Sessions are great for front-end web applications built in Vapor that serve HTML directly to web browsers. For APIs, we recommend using stateless, token-based authentication to persist user data between requests. Session Authenticatable \u00b6 To use session-based authentication, you will need a type that conforms to SessionAuthenticatable . For this example, we'll use a simple struct. import Vapor struct User { var email : String } To conform to SessionAuthenticatable , you will need to specify a sessionID . This is the value that will be stored in the session data and must uniquely identify the user. extension User : SessionAuthenticatable { var sessionID : String { self . email } } For our simple User type, we'll use the email address as the unique session identifier. Session Authenticator \u00b6 Next, we'll need a SessionAuthenticator to handle resolving instances of our User from the persisted session identifier. struct UserSessionAuthenticator : SessionAuthenticator { typealias User = App . User func authenticate ( sessionID : String , for request : Request ) -> EventLoopFuture < Void > { let user = User ( email : sessionID ) request . auth . login ( user ) return request . eventLoop . makeSucceededFuture (()) } } Since all the information we need to initialize our example User is contained in the session identifier, we can create and login the user synchronously. In a real-world application, you would likely use the session identifier to perform a database lookup or API request to fetch the rest of the user data before authenticating. Next, let's create a simple bearer authenticator to perform the initial authentication. struct UserBearerAuthenticator : BearerAuthenticator { func authenticate ( bearer : BearerAuthorization , for request : Request ) -> EventLoopFuture < Void > { if bearer . token == \"test\" { let user = User ( name : \"hello@vapor.codes\" ) request . auth . login ( user ) } return request . eventLoop . makeSucceededFuture (()) } } This authenticator will authenticate a user with the email hello@vapor.codes when the bearer token test is sent. Finally, let's combine all these pieces together in your application. // Create protected route group which requires user auth. let protected = app . routes . grouped ([ app . sessions . middleware , UserSessionAuthenticator (), UserBearerAuthenticator (), User . guardMiddleware (), ]) // Add GET /me route for reading user's email. protected . get ( \"me\" ) { req -> String in try req . auth . require ( User . self ). email } SessionsMiddleware is added first to enable session support on the application. More information about configuring sessions can be found in the Session API section. Next, the SessionAuthenticator is added. This handles authenticating the user if a session is active. If the authentication has not been persisted in the session yet, the request will be forwarded to the next authenticator. UserBearerAuthenticator will check the bearer token and authenticate the user if it equals \"test\" . Finally, User.guardMiddleware() will ensure that User has been authenticated by one of the previous middleware. If the user has not been authenticated, an error will be thrown. To test this route, first send the following request: GET /me HTTP / 1.1 authorization : Bearer test This will cause UserBearerAuthenticator to authenticate the user. Once authenticated, UserSessionAuthenticator will persist the user's identifier in session storage and generate a cookie. Use the cookie from the response in a second request to the route. GET /me HTTP / 1.1 cookie : vapor_session=123 This time, UserSessionAuthenticator will authenticate the user and you should again see the user's email returned. Model Session Authenticatable \u00b6 Fluent models can generate SessionAuthenticator s by conforming to ModelSessionAuthenticatable . This will use the model's unique identifier as the session identifier and automatically perform a database lookup to restore the model from the session. import Fluent final class User : Model { ... } // Allow this model to be persisted in sessions. extension User : ModelSessionAuthenticatable { } You can add ModelSessionAuthenticatable to any existing model as an empty conformance. Once added, a new static method will be available for creating a SessionAuthenticator for that model. User . sessionAuthenticator () This will use the application's default database for resolving the user. To specify a database, pass the identifier. User . sessionAuthenticator (. sqlite )","title":"Authentication"},{"location":"authentication/#authentication","text":"Authentication is the act of verifying a user's identity. This is done through the verification of credentials like a username and password or unique token. Authentication (sometimes called auth/c) is distinct from authorization (auth/z) which is the act of verifying a previously authenticated user's permissions to perform certain tasks.","title":"Authentication"},{"location":"authentication/#introduction","text":"Vapor's Authentication API provides support for authenticating a user via the Authorization header, using Basic and Bearer . It also supports authenticating a user via the data decoded from the Content API. Authentication is implemented by creating an Authenticator which contains the verification logic. An authenticator can be used to protect individual route groups or an entire app. The following authenticator helpers ship with Vapor: Protocol Description RequestAuthenticator Base authenticator capable of creating middleware. BasicAuthenticator Authenticates Basic authorization header. BearerAuthenticator Authenticates Bearer authorization header. UserTokenAuthenticator Authenticates a token type with associated user. CredentialsAuthenticator Authenticates a credentials payload from the request body. If authentication is successful, the authenticator adds the verified user to req.auth . This user can then be accessed using req.auth.get(_:) in routes protected by the authenticator. If authentication fails, the user is not added to req.auth and any attempts to access it will fail.","title":"Introduction"},{"location":"authentication/#authenticatable","text":"To use the Authentication API, you first need a user type that conforms to Authenticatable . This can be a struct , class , or even a Fluent Model . The following examples assume this simple User struct that has one property: name . import Vapor struct User : Authenticatable { var name : String } Each example below will create an authenticator named UserAuthenticator .","title":"Authenticatable"},{"location":"authentication/#route","text":"Authenticators are middleware and be be used for protecting routes. let protected = app . grouped ( UserAuthenticator ()) protected . get ( \"me\" ) { req -> String in try req . auth . require ( User . self ). name } req.auth.require is used to fetch the authenticated User . If authentication failed, this method will throw an error, protecting the route.","title":"Route"},{"location":"authentication/#guard-middleware","text":"You can also use GuardMiddleware in your route group to ensure that a user has been authenticated before reaching your route handler. let protected = app . grouped ( UserAuthenticator ()) . grouped ( User . guardMiddleware ()) Requiring authentication is not done by the authenticator middleware to allow for composition of authenticators. Read more about composition below.","title":"Guard Middleware"},{"location":"authentication/#basic","text":"Basic authentication sends a username and password in the Authorization header. The username and password are concatenated with a colon (e.g. test:secret ), base-64 encoded, and prefixed with \"Basic \" . The following example request encodes the username test with password secret . GET /me HTTP / 1.1 Authorization : Basic dGVzdDpzZWNyZXQ= Basic authentication is typically used once to log a user in and generate a token. This minimizes how frequently the user's sensitive password must be sent. You should never send Basic authorization over a plaintext or unverified TLS connection. To implement Basic authentication in your app, create a new authenticator conforming to BasicAuthenticator . Below is an example authenticator hard-coded to verify the request from above. import Vapor struct UserAuthenticator : BasicAuthenticator { typealias User = App . User func authenticate ( basic : BasicAuthorization , for request : Request ) -> EventLoopFuture < User ? > { guard basic . username == \"test\" && basic . password == \"secret\" else { return request . eventLoop . makeSucceededFuture ( nil ) } let test = User ( name : \"Vapor\" ) return request . eventLoop . makeSucceededFuture ( test ) } } This protocol requires you to implement authenticate(basic:for:) which will be called when an incoming request contains the Authorization: Basic ... header. A BasicAuthorization struct containing the username and password is passed to the method. In this test authenticator, the username and password are tested against hard-coded values. In a real authenticator, you might check against a database or external API. This is why the authenticate method allows you to return a future. Tip Passwords should never be stored in a database as plaintext. Always use password hashes for comparison. If the authentication parameters are correct, in this case matching the hard-coded values, a User named Vapor is returned. If the authentication parameters do not match, nil is returned, which signifies authentication failed. If you add this authenticator to your app, and test the route defined above, you should see the name \"Vapor\" returned for a successful login. If the credentials are not correct, you should see a 401 Unauthorized error.","title":"Basic"},{"location":"authentication/#bearer","text":"Bearer authentication sends a token in the Authorization header. The token is prefixed with \"Bearer \" . The following example request sends the token foo . GET /me HTTP / 1.1 Authorization : Bearer foo Bearer authentication is commonly used for authentication of API endpoints. The user typically requests a Bearer token by sending credentials like a username and password to a login endpoint. This token may last minutes or days depending on the application's needs. As long as the token is valid, the user can use it in place of his or her credentials to authenticate against the API. If the token becomes invalid, a new one can be generated using the login endpoint. To implement Bearer authentication in your app, create a new authenticator conforming to BearerAuthenticator . Below is an example authenticator hard-coded to verify the request from above. import Vapor struct UserAuthenticator : BearerAuthenticator { typealias User = App . User func authenticate ( bearer : BearerAuthorization , for request : Request ) -> EventLoopFuture < User ? > { guard bearer . token == \"foo\" else { return request . eventLoop . makeSucceededFuture ( nil ) } let test = User ( name : \"Vapor\" ) return request . eventLoop . makeSucceededFuture ( test ) } } This protocol requires you to implement authenticate(bearer:for:) which will be called when an incoming request contains the Authorization: Bearer ... header. A BearerAuthorization struct containing the token is passed to the method. In this test authenticator, the token is tested against a hard-coded value. In a real authenticator, you might verify the token by checking against a database or using cryptographic measures, like is done with JWT. This is why the authenticate method allows you to return a future. Tip When implementing token verification, it's important to consider horizontal scalability. If your application needs to handle many users concurrently, authentication can be a potential bottlneck. Consider how your design will scale across multiple instances of your application running at once. If the authentication parameters are correct, in this case matching the hard-coded value, a User named Vapor is returned. If the authentication parameters do not match, nil is returned, which signifies authentication failed. If you add this authenticator to your app, and test the route defined above, you should see the name \"Vapor\" returned for a successful login. If the credentials are not correct, you should see a 401 Unauthorized error.","title":"Bearer"},{"location":"authentication/#composition","text":"Multiple authenticators can be composed (combined together) to create more complex endpoint authentication. Since an authenticator middleware will not reject the request if authentication fails, more than one of these middleware can be chained together. Authenticators can composed in two key ways.","title":"Composition"},{"location":"authentication/#composing-methods","text":"The first method of authentication composition is chaining more than one authenticator for the same user type. Take the following example: app . grouped ( UserPasswordAuthenticator ()) . grouped ( UserTokenAuthenticator ()) . grouped ( User . guardMiddleware ()) . post ( \"login\" ) { req in let user = try req . auth . require ( User . self ) // Do something with user. } This example assumes two authenticators UserPasswordAuthenticator and UserTokenAuthenticator that both authenticate User . Both of these authenticators are added to the route group. Finally, GuardMiddleware is added after the authenticators to require that User was successfully authenticated. This composition of authenticators results in a route that can be accessed by either password or token. Such a route could allow a user to login and generate a token, then continue to use that token to generate new tokens.","title":"Composing Methods"},{"location":"authentication/#composing-users","text":"The second method of authentication composition is chaining authenticators for different user types. Take the following example: app . grouped ( AdminAuthenticator ()) . grouped ( UserAuthenticator ()) . get ( \"secure\" ) { req in guard req . auth . has ( Admin . self ) || req . auth . has ( User . self ) else { throw Abort (. unauthorized ) } // Do something. } This example assumes two authenticators AdminAuthenticator and UserAuthenticator that authenticate Admin and User , respectively. Both of these authenticators are added to the route group. Instead of using GuardMiddleware , a check in the route handler is added to see if either Admin or User were authenticated. If not, an error is thrown. This composition of authenticators results in a route that can be accessed by two different types of users with potentially different methods of authentication. Such a route could allow for normal user authentication while still giving access to a super-user.","title":"Composing Users"},{"location":"authentication/#manual","text":"You can also handle authentication manually using req.auth . This is especially useful for testing. To manually log a user in, use req.auth.login(_:) . Any Authenticatable user can be passed to this method. req . auth . login ( User ( name : \"Vapor\" )) To get the authenticated user, use req.auth.require(_:) let user : User = try req . auth . require ( User . self ) print ( user . name ) // String You can also use req.auth.get(_:) if you don't want to automatically throw an error when authentication fails. let user = req . auth . get ( User . self ) print ( user ?. name ) // String? To unauthenticate a user, pass the user type to req.auth.logout(_:) . req . auth . logout ( User . self )","title":"Manual"},{"location":"authentication/#fluent","text":"Fluent defines two protocols ModelAuthenticatable and ModelTokenAuthenticatable which can be added to your existing models. Conforming your models to these protocols allows for the creation of authenticators for protecting endpoints. ModelTokenAuthenticatable authenticates with a Bearer token. This is what you use to protect most of your endpoints. ModelAuthenticatable authenticates with username and password and is used by a single endpoint for generating tokens. This guide assumes you are familiar with Fluent and have successfully configured your app to use a database. If you are new to Fluent, start with the overview .","title":"Fluent"},{"location":"authentication/#user","text":"To start, you will need a model representing the user that will be authenticated. For this guide, we'll be using the following model, but you are free to use an existing model. import Fluent import Vapor final class User : Model , Content { static let schema = \"users\" @ ID ( key : . id ) var id : UUID ? @ Field ( key : \"name\" ) var name : String @ Field ( key : \"email\" ) var email : String @ Field ( key : \"password_hash\" ) var passwordHash : String init () { } init ( id : UUID ? = nil , name : String , email : String , passwordHash : String ) { self . id = id self . name = name self . email = email self . passwordHash = passwordHash } } The model must be able to store a username, in this case an email, and a password hash. The corresponding migration for this example model is here: import Fluent import Vapor extension User { struct Migration : Fluent . Migration { var name : String { \"CreateUser\" } func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"users\" ) . id () . field ( \"name\" , . string , . required ) . field ( \"email\" , . string , . required ) . field ( \"password_hash\" , . string , . required ) . create () } func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"users\" ). delete () } } } Don't forget to add the migration to app.migrations . app . migrations . add ( User . Migration ()) The first thing you will need is an endpoint to create new users. Let's use POST /users . Create a Content struct representing the data this endpoint expects. import Vapor extension User { struct Create : Content { var name : String var email : String var password : String var confirmPassword : String } } If you like, you can conform this struct to Validatable to add validation requirements. import Vapor extension User . Create : Validatable { static func validations ( _ validations : inout Validations ) { validations . add ( \"name\" , as : String . self , is : ! . empty ) validations . add ( \"email\" , as : String . self , is : . email ) validations . add ( \"password\" , as : String . self , is : . count ( 8. ..)) } } Now you can create the POST /users endpoint. app . post ( \"users\" ) { req -> EventLoopFuture < User > in try User . Create . validate ( req ) let create = try req . content . decode ( User . Create . self ) guard create . password == create . confirmPassword else { throw Abort (. badRequest , reason : \"Passwords did not match\" ) } let user = try User ( name : create . name , email : create . email , passwordHash : Bcrypt . hash ( create . password ) ) return user . save ( on : req . db ) . map { user } } This endpoint validates the incoming request, decodes the User.Create struct, and checks that the passwords match. It then uses the decoded data to create a new User and saves it to the database. The plaintext password is hashed using Bcrypt before saving to the database. Build and run the project, making sure to migrate the database first, then use the following request to create a new user. POST /users HTTP / 1.1 Content-Length : 97 Content-Type : application/json { \"name\" : \"Vapor\" , \"email\" : \"test@vapor.codes\" , \"password\" : \"secret\" , \"confirmPassword\" : \"secret\" }","title":"User"},{"location":"authentication/#model-authenticatable","text":"Now that you have a user model and an endpoint to create new users, let's conform the model to ModelAuthenticatable . This will allow for the model to be authenticated using username and password. import Fluent import Vapor extension User : ModelAuthenticatable { static let usernameKey = \\ User . $ email static let passwordHashKey = \\ User . $ passwordHash func verify ( password : String ) throws -> Bool { try Bcrypt . verify ( password , created : self . passwordHash ) } } This extension adds ModelAuthenticatable conformance to User . The first two properties specify which fields should be used for storing the username and password hash respectively. The \\ notation creates a key path to the fields that Fluent can use to access them. The last requirement is a method for verifying plaintext passwords sent in the Basic authentication header. Since we're using Bcrypt to hash the password during signup, we'll use Bcrypt to verify that the supplied password matches the stored password hash. Now that the User conforms to ModelAuthenticatable , we can create an authenticator for protecting the login route. let passwordProtected = app . grouped ( User . authenticator ()) passwordProtected . post ( \"login\" ) { req -> User in try req . auth . require ( User . self ) } ModelAuthenticatable adds a static method authenticator for creating an authenticator. Test that this route works by sending the following request. POST /login HTTP / 1.1 Authorization : Basic dGVzdEB2YXBvci5jb2RlczpzZWNyZXQ= This request passes the username test@vapor.codes and password secret via the Basic authentication header. You should see the previously created user returned. While you could theoretically use Basic authentication to protect all of your endpoints, it's recommended to use a separate token instead. This minimizes how often you must send the user's sensitive password over the Internet. It also makes authentication much faster since you only need to perform password hashing during login.","title":"Model Authenticatable"},{"location":"authentication/#user-token","text":"Create a new model for representing user tokens. import Fluent import Vapor final class UserToken : Model , Content { static let schema = \"user_tokens\" @ ID ( key : . id ) var id : UUID ? @ Field ( key : \"value\" ) var value : String @ Parent ( key : \"user_id\" ) var user : User init () { } init ( id : UUID ? = nil , value : String , userID : User . IDValue ) { self . id = id self . value = value self . $ user . id = userID } } This model must have a value field for storing the token's unique string. It must also have a parent-relation to the user model. You may add additional properties to this token as you see fit, such as an expiration date. Next, create a migration for this model. import Fluent extension UserToken { struct Migration : Fluent . Migration { var name : String { \"CreateUserToken\" } func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"user_tokens\" ) . id () . field ( \"value\" , . string , . required ) . field ( \"user_id\" , . uuid , . required , . references ( \"users\" , \"id\" )) . unique ( on : \"value\" ) . create () } func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"user_tokens\" ). delete () } } } Notice that this migration makes the value field unique. It also creates a foreign key reference between the user_id field and the users table. Don't forget to add the migration to app.migrations . app . migrations . add ( UserToken . Migration ()) Finally, add a method on User for generating a new token. This method will be used during login. extension User { func generateToken () throws -> UserToken { try . init ( value : [ UInt8 ]. random ( count : 16 ). base64 , userID : self . requireID () ) } } Here we're using [UInt8].random(count:) to generate a random token value. For this example, 16 bytes, or 128 bits, of random data are being used. You can adjust this number as you see fit. The random data is then base-64 encoded to make it easy to transmit in HTTP headers. Now that you can generate user tokens, update the POST /login route to create and return a token. let passwordProtected = app . grouped ( User . authenticator ()) passwordProtected . post ( \"login\" ) { req -> EventLoopFuture < UserToken > in let user = try req . auth . require ( User . self ) let token = try user . generateToken () return token . save ( on : req . db ) . map { token } } Test that this route works by using the same login request from above. You should now get a token upon logging in that looks something like: 8gtg300Jwdhc/Ffw784EXA== Hold onto the token you get as we'll use it shortly.","title":"User Token"},{"location":"authentication/#model-token-authenticatable","text":"Conform UserToken to ModelTokenAuthenticatable . This will allow for tokens to authenticate your User model. import Vapor import Fluent extension UserToken : ModelTokenAuthenticatable { static let valueKey = \\ UserToken . $ value static let userKey = \\ UserToken . $ user var isValid : Bool { true } } The first protocol requirement specifies which field stores the token's unique value. This is the value that will be sent in the Bearer authentication header. The second requirement specifies the parent-relation to the User model. This is how Fluent will look up the authenticated user. The final requirement is an isValid boolean. If this is false , the token will be deleted from the database and the user will not be authenticated. For simplicity, we'll make the tokens eternal by hard-coding this to true . Now that the token conforms to ModelTokenAuthenticatable , you can create an authenticator for protecting routes. Create a new endpoint GET /me for getting the currently authenticated user. let tokenProtected = app . grouped ( UserToken . authenticator ()) tokenProtected . get ( \"me\" ) { req -> User in try req . auth . require ( User . self ) } Similar to User , UserToken now has a static authenticator() method that can generate an authenticator. The authenticator will attempt to find a matching UserToken using the value provided in the Bearer authentication header. If it finds a match, it will fetch the related User and authenticate it. Test that this route works by sending the following HTTP request where the token is the value you saved from the POST /login request. GET /me HTTP / 1.1 Authorization : Bearer <token> You should see the authenticated User returned.","title":"Model Token Authenticatable"},{"location":"authentication/#session","text":"Vapor's Session API can be used to automatically persist user authentication between requests. This works by storing a unique identifier for the user in the request's session data after successful login. On subsequent requests, the user's identifier is fetched from the session and used to authenticate the user before calling your route handler. Sessions are great for front-end web applications built in Vapor that serve HTML directly to web browsers. For APIs, we recommend using stateless, token-based authentication to persist user data between requests.","title":"Session"},{"location":"authentication/#session-authenticatable","text":"To use session-based authentication, you will need a type that conforms to SessionAuthenticatable . For this example, we'll use a simple struct. import Vapor struct User { var email : String } To conform to SessionAuthenticatable , you will need to specify a sessionID . This is the value that will be stored in the session data and must uniquely identify the user. extension User : SessionAuthenticatable { var sessionID : String { self . email } } For our simple User type, we'll use the email address as the unique session identifier.","title":"Session Authenticatable"},{"location":"authentication/#session-authenticator","text":"Next, we'll need a SessionAuthenticator to handle resolving instances of our User from the persisted session identifier. struct UserSessionAuthenticator : SessionAuthenticator { typealias User = App . User func authenticate ( sessionID : String , for request : Request ) -> EventLoopFuture < Void > { let user = User ( email : sessionID ) request . auth . login ( user ) return request . eventLoop . makeSucceededFuture (()) } } Since all the information we need to initialize our example User is contained in the session identifier, we can create and login the user synchronously. In a real-world application, you would likely use the session identifier to perform a database lookup or API request to fetch the rest of the user data before authenticating. Next, let's create a simple bearer authenticator to perform the initial authentication. struct UserBearerAuthenticator : BearerAuthenticator { func authenticate ( bearer : BearerAuthorization , for request : Request ) -> EventLoopFuture < Void > { if bearer . token == \"test\" { let user = User ( name : \"hello@vapor.codes\" ) request . auth . login ( user ) } return request . eventLoop . makeSucceededFuture (()) } } This authenticator will authenticate a user with the email hello@vapor.codes when the bearer token test is sent. Finally, let's combine all these pieces together in your application. // Create protected route group which requires user auth. let protected = app . routes . grouped ([ app . sessions . middleware , UserSessionAuthenticator (), UserBearerAuthenticator (), User . guardMiddleware (), ]) // Add GET /me route for reading user's email. protected . get ( \"me\" ) { req -> String in try req . auth . require ( User . self ). email } SessionsMiddleware is added first to enable session support on the application. More information about configuring sessions can be found in the Session API section. Next, the SessionAuthenticator is added. This handles authenticating the user if a session is active. If the authentication has not been persisted in the session yet, the request will be forwarded to the next authenticator. UserBearerAuthenticator will check the bearer token and authenticate the user if it equals \"test\" . Finally, User.guardMiddleware() will ensure that User has been authenticated by one of the previous middleware. If the user has not been authenticated, an error will be thrown. To test this route, first send the following request: GET /me HTTP / 1.1 authorization : Bearer test This will cause UserBearerAuthenticator to authenticate the user. Once authenticated, UserSessionAuthenticator will persist the user's identifier in session storage and generate a cookie. Use the cookie from the response in a second request to the route. GET /me HTTP / 1.1 cookie : vapor_session=123 This time, UserSessionAuthenticator will authenticate the user and you should again see the user's email returned.","title":"Session Authenticator"},{"location":"authentication/#model-session-authenticatable","text":"Fluent models can generate SessionAuthenticator s by conforming to ModelSessionAuthenticatable . This will use the model's unique identifier as the session identifier and automatically perform a database lookup to restore the model from the session. import Fluent final class User : Model { ... } // Allow this model to be persisted in sessions. extension User : ModelSessionAuthenticatable { } You can add ModelSessionAuthenticatable to any existing model as an empty conformance. Once added, a new static method will be available for creating a SessionAuthenticator for that model. User . sessionAuthenticator () This will use the application's default database for resolving the user. To specify a database, pass the identifier. User . sessionAuthenticator (. sqlite )","title":"Model Session Authenticatable"},{"location":"client/","text":"Client \u00b6 Vapor's client API allows you to make HTTP calls to external resources. It is built on async-http-client and integrates with the content API. Overview \u00b6 You can get access to the default client via Application or in a route handler via Request . app . client // Client app . get ( \"test\" ) { req in req . client // Client } The application's client is useful for making HTTP requests during configuration time. If you are making HTTP requests in a route handler, always use the request's client. Methods \u00b6 To make a GET request, pass the desired URL to the get convenience method. req . client . get ( \"https://httpbin.org/status/200\" ). map { res in // Handle the response. } There are methods for each of the HTTP verbs like get , post , and delete . The client's response is returned as a future and contains the HTTP status, headers, and body. Content \u00b6 Vapor's content API is available for handling data in client requests and responses. To encode content or query parameters to the request, use the beforeSend closure. req . client . post ( \"https://httpbin.org/status/200\" ) { req in // Encode query string to the request URL. try req . query . encode ([ \"q\" : \"test\" ]) // Encode JSON to the request body. try req . content . encode ([ \"hello\" : \"world\" ]) }. map { res in // Handle the response. } To decode content from the response, use flatMapThrowing on the client's response future. req . client . get ( \"https://httpbin.org/json\" ). flatMapThrowing { res in try res . content . decode ( MyJSONResponse . self ) }. map { json in // Handle the json response. } Configuration \u00b6 You can configure the underlying HTTP client via the application. // Disable automatic redirect following. app . client . configuration . redirectConfiguration = . disallow Note that you must configure the default client before using it for the first time.","title":"Client"},{"location":"client/#client","text":"Vapor's client API allows you to make HTTP calls to external resources. It is built on async-http-client and integrates with the content API.","title":"Client"},{"location":"client/#overview","text":"You can get access to the default client via Application or in a route handler via Request . app . client // Client app . get ( \"test\" ) { req in req . client // Client } The application's client is useful for making HTTP requests during configuration time. If you are making HTTP requests in a route handler, always use the request's client.","title":"Overview"},{"location":"client/#methods","text":"To make a GET request, pass the desired URL to the get convenience method. req . client . get ( \"https://httpbin.org/status/200\" ). map { res in // Handle the response. } There are methods for each of the HTTP verbs like get , post , and delete . The client's response is returned as a future and contains the HTTP status, headers, and body.","title":"Methods"},{"location":"client/#content","text":"Vapor's content API is available for handling data in client requests and responses. To encode content or query parameters to the request, use the beforeSend closure. req . client . post ( \"https://httpbin.org/status/200\" ) { req in // Encode query string to the request URL. try req . query . encode ([ \"q\" : \"test\" ]) // Encode JSON to the request body. try req . content . encode ([ \"hello\" : \"world\" ]) }. map { res in // Handle the response. } To decode content from the response, use flatMapThrowing on the client's response future. req . client . get ( \"https://httpbin.org/json\" ). flatMapThrowing { res in try res . content . decode ( MyJSONResponse . self ) }. map { json in // Handle the json response. }","title":"Content"},{"location":"client/#configuration","text":"You can configure the underlying HTTP client via the application. // Disable automatic redirect following. app . client . configuration . redirectConfiguration = . disallow Note that you must configure the default client before using it for the first time.","title":"Configuration"},{"location":"commands/","text":"Commands \u00b6 Vapor's Command API allows you to build custom command-line functions and interact with the terminal. It is what Vapor's default commands like serve , routes , and migrate are built on. Default Commands \u00b6 You can learn more about Vapor's default commands using the --help option. vapor run --help You can use --help on a specific command to see what arguments and options it accepts. vapor run serve --help Custom Commands \u00b6 You can create your own commands by creating types conforming to Command . import Vapor struct HelloCommand : Command { ... } Adding the custom command to app.commands will make it available via vapor run . app . commands . use ( HelloCommand (), as : \"hello\" ) To conform to Command , you must implement the run method. This requires declaring a Signature . You must also provide default help text. import Vapor struct HelloCommand : Command { struct Signature : CommandSignature { } var help : String { \"Says hello\" } func run ( using context : CommandContext , signature : Signature ) throws { context . console . print ( \"Hello, world!\" ) } } This simple command example has no arguments or options, so leave the signature empty. You can get access to the current console via the supplied context. Console has many helpful methods for prompting user input, output formatting, and more. let name = context . console . ask ( \"What is your \\( \"name\" , color : . blue ) ?\" ) context . console . print ( \"Hello, \\( name ) \ud83d\udc4b\" ) Test your command by running: vapor run hello Cowsay \u00b6 Take a look at this re-creation of the famous cowsay command for an example of using @Argument and @Option . import Vapor struct Cowsay : Command { struct Signature : CommandSignature { @ Argument ( name : \"message\" ) var message : String @ Option ( name : \"eyes\" , short : \"e\" ) var eyes : String ? @ Option ( name : \"tongue\" , short : \"t\" ) var tongue : String ? } var help : String { \"Generates ASCII picture of a cow with a message.\" } func run ( using context : CommandContext , signature : Signature ) throws { let eyes = signature . eyes ?? \"oo\" let tongue = signature . tongue ?? \" \" let cow = # \"\"\" < $M > \\ ^__^ \\ ($E)\\_______ (__)\\ )\\/\\ $T ||----w | || || \"\"\" #. replacingOccurrences ( of : \"$M\" , with : signature . message ) . replacingOccurrences ( of : \"$E\" , with : eyes ) . replacingOccurrences ( of : \"$T\" , with : tongue ) context . console . print ( cow ) } } Try adding this to your application and running it. app . commands . use ( Cowsay (), as : \"cowsay\" ) vapor run cowsay sup --eyes ^^ --tongue \"U \"","title":"Commands"},{"location":"commands/#commands","text":"Vapor's Command API allows you to build custom command-line functions and interact with the terminal. It is what Vapor's default commands like serve , routes , and migrate are built on.","title":"Commands"},{"location":"commands/#default-commands","text":"You can learn more about Vapor's default commands using the --help option. vapor run --help You can use --help on a specific command to see what arguments and options it accepts. vapor run serve --help","title":"Default Commands"},{"location":"commands/#custom-commands","text":"You can create your own commands by creating types conforming to Command . import Vapor struct HelloCommand : Command { ... } Adding the custom command to app.commands will make it available via vapor run . app . commands . use ( HelloCommand (), as : \"hello\" ) To conform to Command , you must implement the run method. This requires declaring a Signature . You must also provide default help text. import Vapor struct HelloCommand : Command { struct Signature : CommandSignature { } var help : String { \"Says hello\" } func run ( using context : CommandContext , signature : Signature ) throws { context . console . print ( \"Hello, world!\" ) } } This simple command example has no arguments or options, so leave the signature empty. You can get access to the current console via the supplied context. Console has many helpful methods for prompting user input, output formatting, and more. let name = context . console . ask ( \"What is your \\( \"name\" , color : . blue ) ?\" ) context . console . print ( \"Hello, \\( name ) \ud83d\udc4b\" ) Test your command by running: vapor run hello","title":"Custom Commands"},{"location":"commands/#cowsay","text":"Take a look at this re-creation of the famous cowsay command for an example of using @Argument and @Option . import Vapor struct Cowsay : Command { struct Signature : CommandSignature { @ Argument ( name : \"message\" ) var message : String @ Option ( name : \"eyes\" , short : \"e\" ) var eyes : String ? @ Option ( name : \"tongue\" , short : \"t\" ) var tongue : String ? } var help : String { \"Generates ASCII picture of a cow with a message.\" } func run ( using context : CommandContext , signature : Signature ) throws { let eyes = signature . eyes ?? \"oo\" let tongue = signature . tongue ?? \" \" let cow = # \"\"\" < $M > \\ ^__^ \\ ($E)\\_______ (__)\\ )\\/\\ $T ||----w | || || \"\"\" #. replacingOccurrences ( of : \"$M\" , with : signature . message ) . replacingOccurrences ( of : \"$E\" , with : eyes ) . replacingOccurrences ( of : \"$T\" , with : tongue ) context . console . print ( cow ) } } Try adding this to your application and running it. app . commands . use ( Cowsay (), as : \"cowsay\" ) vapor run cowsay sup --eyes ^^ --tongue \"U \"","title":"Cowsay"},{"location":"content/","text":"Content \u00b6 Vapor's content API allows you to easily encode / decode Codable structs to / from HTTP messages. JSON encoding is used by default with out-of-the-box support for URL-Encoded Form and Multipart . The API is also configurable, allowing for you to add, modify, or replace encoding strategies for certain HTTP content types. Overview \u00b6 To understand how Vapor's content API works, you should first understand a few basics about HTTP messages. Take a look at the following example request. POST /greeting HTTP / 1.1 content-type : application/json content-length : 18 { \"hello\" : \"world\" } This request indicates that it contains JSON-encoded data using the content-type header and application/json media type. As promised, some JSON data follows after the headers in the body. Content Struct \u00b6 The first step to decoding this HTTP message is creating a Codable type that matches the expected structure. struct Greeting : Content { var hello : String } Conforming the type to Content will automatically add conformance to Codable alongside additional utilities for working with the content API. Once you have the content structure, you can decode it from the incoming request using req.content . app . post ( \"greeting\" ) { req in let greeting = try req . content . decode ( Greeting . self ) print ( greeting . hello ) // \"world\" return HTTPStatus . ok } The decode method uses the request's content type to find an appropriate decoder. If there is no decoder found, or the request does not contain the content type header, a 415 error will be thrown. That means that this route automatically accepts all of the other supported content types, such as url-encoded form: POST /greeting HTTP / 1.1 content-type : application/x-www-form-urlencoded content-length : 11 hello=world Supported Media Types \u00b6 Below are the media types the content API supports by default. name header value media type JSON application/json .json Multipart multipart/form-data .formData URL-Encoded Form application/x-www-form-urlencoded .urlEncodedForm Plaintext text/plain .plainText HTML text/html .html Not all media types support all Codable features. For example, JSON does not support top-level fragments and Plaintext does not support nested data. Query \u00b6 Vapor's Content APIs support handling URL encoded data in the URL's query string. Decoding \u00b6 To understand how decoding a URL query string works, take a look at the following example request. GET /hello?name=Vapor HTTP / 1.1 content-length : 0 Just like the APIs for handling HTTP message body content, the first step for parsing URL query strings is to create a struct that matches the expected structure. struct Hello : Content { var name : String ? } Note that name is an optional String since URL query strings should always be optional. If you want to require a parameter, use a route parameter instead. Now that you have a Content struct for this route's expected query string, you can decode it. app . get ( \"hello\" ) { req -> String in let hello = try req . query . decode ( Hello . self ) return \"Hello, \\( hello . name ?? \"Anonymous\" ) \" } This route would result in the following response given the example request from above: HTTP / 1.1 200 OK content-length : 12 Hello, Vapor If the query string were omitted, like in the following request, the name \"Anonymous\" would be used instead. GET /hello HTTP / 1.1 content-length : 0 Single Value \u00b6 In addition to decoding to a Content struct, Vapor also supports fetching single values from the query string using subscripts. let name : String ? = req . query [ \"name\" ] Override Defaults \u00b6 The default encoders and decoders used by Vapor's Content APIs can be configured. Global \u00b6 ContentConfiguration.global lets you change the encoders and decoders Vapor uses by default. This is useful for changing how your entire application parses and serializes data. // create a new JSON encoder that uses unix-timestamp dates let encoder = JSONEncoder () encoder . dateEncodingStrategy = . secondsSince1970 // override the global encoder used for the `.json` media type ContentConfiguration . global . use ( encoder : encoder , for : . json ) Mutating ContentConfiguration is usually done in configure.swift . One-Off \u00b6 Calls to encoding and decoding methods like req.content.decode support passing in custom coders for one-off usages. // create a new JSON decoder that uses unix-timestamp dates let decoder = JSONDecoder () decoder . dateDecodingStrategy = . secondsSince1970 // decodes Hello struct using custom decoder let hello = try req . content . decode ( Hello . self , using : decoder ) Custom Coders \u00b6 Applications and third-party packages can add support for media types that Vapor does not support by default by creating custom coders. Content \u00b6 Vapor specifies two protocols for coders capable of handling content in HTTP message bodies: ContentDecoder and ContentEncoder . public protocol ContentEncoder { func encode < E >( _ encodable : E , to body : inout ByteBuffer , headers : inout HTTPHeaders ) throws where E : Encodable } public protocol ContentDecoder { func decode < D >( _ decodable : D . Type , from body : ByteBuffer , headers : HTTPHeaders ) throws -> D where D : Decodable } Conforming to these protocols allows your custom coders to be registered to ContentConfiguration as specified above. URL Query \u00b6 Vapor specifies two protocols for coders capable of handling content in URL query strings: URLQueryDecoder and URLQueryEncoder . public protocol URLQueryDecoder { func decode < D >( _ decodable : D . Type , from url : URI ) throws -> D where D : Decodable } public protocol URLQueryEncoder { func encode < E >( _ encodable : E , to url : inout URI ) throws where E : Encodable } Conforming to these protocols allows your custom coders to be registered to ContentConfiguration for handling URL query strings using the use(urlEncoder:) and use(urlDecoder:) methods.","title":"Content"},{"location":"content/#content","text":"Vapor's content API allows you to easily encode / decode Codable structs to / from HTTP messages. JSON encoding is used by default with out-of-the-box support for URL-Encoded Form and Multipart . The API is also configurable, allowing for you to add, modify, or replace encoding strategies for certain HTTP content types.","title":"Content"},{"location":"content/#overview","text":"To understand how Vapor's content API works, you should first understand a few basics about HTTP messages. Take a look at the following example request. POST /greeting HTTP / 1.1 content-type : application/json content-length : 18 { \"hello\" : \"world\" } This request indicates that it contains JSON-encoded data using the content-type header and application/json media type. As promised, some JSON data follows after the headers in the body.","title":"Overview"},{"location":"content/#content-struct","text":"The first step to decoding this HTTP message is creating a Codable type that matches the expected structure. struct Greeting : Content { var hello : String } Conforming the type to Content will automatically add conformance to Codable alongside additional utilities for working with the content API. Once you have the content structure, you can decode it from the incoming request using req.content . app . post ( \"greeting\" ) { req in let greeting = try req . content . decode ( Greeting . self ) print ( greeting . hello ) // \"world\" return HTTPStatus . ok } The decode method uses the request's content type to find an appropriate decoder. If there is no decoder found, or the request does not contain the content type header, a 415 error will be thrown. That means that this route automatically accepts all of the other supported content types, such as url-encoded form: POST /greeting HTTP / 1.1 content-type : application/x-www-form-urlencoded content-length : 11 hello=world","title":"Content Struct"},{"location":"content/#supported-media-types","text":"Below are the media types the content API supports by default. name header value media type JSON application/json .json Multipart multipart/form-data .formData URL-Encoded Form application/x-www-form-urlencoded .urlEncodedForm Plaintext text/plain .plainText HTML text/html .html Not all media types support all Codable features. For example, JSON does not support top-level fragments and Plaintext does not support nested data.","title":"Supported Media Types"},{"location":"content/#query","text":"Vapor's Content APIs support handling URL encoded data in the URL's query string.","title":"Query"},{"location":"content/#decoding","text":"To understand how decoding a URL query string works, take a look at the following example request. GET /hello?name=Vapor HTTP / 1.1 content-length : 0 Just like the APIs for handling HTTP message body content, the first step for parsing URL query strings is to create a struct that matches the expected structure. struct Hello : Content { var name : String ? } Note that name is an optional String since URL query strings should always be optional. If you want to require a parameter, use a route parameter instead. Now that you have a Content struct for this route's expected query string, you can decode it. app . get ( \"hello\" ) { req -> String in let hello = try req . query . decode ( Hello . self ) return \"Hello, \\( hello . name ?? \"Anonymous\" ) \" } This route would result in the following response given the example request from above: HTTP / 1.1 200 OK content-length : 12 Hello, Vapor If the query string were omitted, like in the following request, the name \"Anonymous\" would be used instead. GET /hello HTTP / 1.1 content-length : 0","title":"Decoding"},{"location":"content/#single-value","text":"In addition to decoding to a Content struct, Vapor also supports fetching single values from the query string using subscripts. let name : String ? = req . query [ \"name\" ]","title":"Single Value"},{"location":"content/#override-defaults","text":"The default encoders and decoders used by Vapor's Content APIs can be configured.","title":"Override Defaults"},{"location":"content/#global","text":"ContentConfiguration.global lets you change the encoders and decoders Vapor uses by default. This is useful for changing how your entire application parses and serializes data. // create a new JSON encoder that uses unix-timestamp dates let encoder = JSONEncoder () encoder . dateEncodingStrategy = . secondsSince1970 // override the global encoder used for the `.json` media type ContentConfiguration . global . use ( encoder : encoder , for : . json ) Mutating ContentConfiguration is usually done in configure.swift .","title":"Global"},{"location":"content/#one-off","text":"Calls to encoding and decoding methods like req.content.decode support passing in custom coders for one-off usages. // create a new JSON decoder that uses unix-timestamp dates let decoder = JSONDecoder () decoder . dateDecodingStrategy = . secondsSince1970 // decodes Hello struct using custom decoder let hello = try req . content . decode ( Hello . self , using : decoder )","title":"One-Off"},{"location":"content/#custom-coders","text":"Applications and third-party packages can add support for media types that Vapor does not support by default by creating custom coders.","title":"Custom Coders"},{"location":"content/#content_1","text":"Vapor specifies two protocols for coders capable of handling content in HTTP message bodies: ContentDecoder and ContentEncoder . public protocol ContentEncoder { func encode < E >( _ encodable : E , to body : inout ByteBuffer , headers : inout HTTPHeaders ) throws where E : Encodable } public protocol ContentDecoder { func decode < D >( _ decodable : D . Type , from body : ByteBuffer , headers : HTTPHeaders ) throws -> D where D : Decodable } Conforming to these protocols allows your custom coders to be registered to ContentConfiguration as specified above.","title":"Content"},{"location":"content/#url-query","text":"Vapor specifies two protocols for coders capable of handling content in URL query strings: URLQueryDecoder and URLQueryEncoder . public protocol URLQueryDecoder { func decode < D >( _ decodable : D . Type , from url : URI ) throws -> D where D : Decodable } public protocol URLQueryEncoder { func encode < E >( _ encodable : E , to url : inout URI ) throws where E : Encodable } Conforming to these protocols allows your custom coders to be registered to ContentConfiguration for handling URL query strings using the use(urlEncoder:) and use(urlDecoder:) methods.","title":"URL Query"},{"location":"crypto/","text":"Crypto \u00b6 Vapor includes SwiftCrypto which is a Linux-compatible port of Apple's CryptoKit library. Some additional crypto APIs are exposed for things SwiftCrypto does not have yet, like Bcrypt and TOTP . SwiftCrypto \u00b6 Swift's Crypto library implements Apple's CryptoKit API. As such, the CryptoKit documentation and the WWDC talk are great resources for learning the API. These APIs will be available automatically when you import Vapor. import Vapor let digest = SHA256 . hash ( data : Data ( \"hello\" . utf8 )) print ( digest ) CryptoKit includes support for: Hashing: SHA512 , SHA384 , SHA256 Message Authentication Codes: HMAC Ciphers: AES , ChaChaPoly Public-Key Cryptography: Curve25519 , P521 , P384 , P256 Insecure hashing: SHA1 , MD5 Bcrypt \u00b6 Bcrypt is a password hashing algorithm that uses a randomized salt to ensure hashing the same password multiple times doesn't result in the same digest. Vapor provides a Bcrypt type for hashing and comparing passwords. import Vapor let digest = try Bcrypt . hash ( \"test\" ) Because Bcrypt uses a salt, password hashes cannot be compared directly. Both the plaintext password and the existing digest must be verified together. import Vapor let pass = try Bcrypt . verify ( \"test\" , created : digest ) if pass { // Password and digest match. } else { // Wrong password. } Login with Bcrypt passwords can be implemented by first fetching the user's password digest from the database by email or username. The known digest can then be verified against the supplied plaintext password. TOTP \u00b6 Coming soon.","title":"Crypto"},{"location":"crypto/#crypto","text":"Vapor includes SwiftCrypto which is a Linux-compatible port of Apple's CryptoKit library. Some additional crypto APIs are exposed for things SwiftCrypto does not have yet, like Bcrypt and TOTP .","title":"Crypto"},{"location":"crypto/#swiftcrypto","text":"Swift's Crypto library implements Apple's CryptoKit API. As such, the CryptoKit documentation and the WWDC talk are great resources for learning the API. These APIs will be available automatically when you import Vapor. import Vapor let digest = SHA256 . hash ( data : Data ( \"hello\" . utf8 )) print ( digest ) CryptoKit includes support for: Hashing: SHA512 , SHA384 , SHA256 Message Authentication Codes: HMAC Ciphers: AES , ChaChaPoly Public-Key Cryptography: Curve25519 , P521 , P384 , P256 Insecure hashing: SHA1 , MD5","title":"SwiftCrypto"},{"location":"crypto/#bcrypt","text":"Bcrypt is a password hashing algorithm that uses a randomized salt to ensure hashing the same password multiple times doesn't result in the same digest. Vapor provides a Bcrypt type for hashing and comparing passwords. import Vapor let digest = try Bcrypt . hash ( \"test\" ) Because Bcrypt uses a salt, password hashes cannot be compared directly. Both the plaintext password and the existing digest must be verified together. import Vapor let pass = try Bcrypt . verify ( \"test\" , created : digest ) if pass { // Password and digest match. } else { // Wrong password. } Login with Bcrypt passwords can be implemented by first fetching the user's password digest from the database by email or username. The known digest can then be verified against the supplied plaintext password.","title":"Bcrypt"},{"location":"crypto/#totp","text":"Coming soon.","title":"TOTP"},{"location":"environment/","text":"Environment \u00b6 Vapor's Environment API helps you configure your app dynamically. By default, your app will use the development environment. You can define other useful environments like production or staging and change how your app is configured in each case. You can also load in variables from the process's environment or .env (dotenv) files depending on your needs. To access the current environment, use app.environment . You can switch on this property in configure(_:) to execute different configuration logic. switch app . environment { case . production : app . databases . use (....) default : app . databases . use (...) } Changing Environment \u00b6 By default, your app will run in the development environment. You can change this by passing the --env ( -e ) flag during app boot. vapor run serve -- env production Vapor includes the following environments: name short description production prod Deployed to your users. development dev Local development. testing test For unit testing. Info The production environment will default to notice level logging unless otherwise specified. All other environments default to info . You can pass either the full or short name to the --env ( -e ) flag. vapor run serve - e prod Process Variables \u00b6 Environment offers a simple, string-based API for accessing the process's environment variables. let foo = Environment . get ( \"FOO\" ) print ( foo ) // String? In addition to get , Environment offers a dynamic member lookup API via process . let foo = Environment . process . FOO print ( foo ) // String? When running your app in the terminal, you can set environment variables using export . export FOO = BAR vapor run serve When running your app in Xcode, you can set environment variables by editing the Run scheme. .env (dotenv) \u00b6 Dotenv files contain a list of key-value pairs to be automatically loaded into the environment. These files make it easy to configure environment variables without needing to set them manually. Vapor will look for dotenv files in the current working directory. If you're using Xcode, make sure to set the working directory by editing the Run scheme. Assume the following .env file placed in your projects root folder: FOO = BAR When your application boots, you will be able to access the contents of this file like other process environment variables. let foo = Environment . get ( \"FOO\" ) print ( foo ) // String? Info Variables specified in .env files will not overwrite variables that already exist in the process environment. Alongside .env , Vapor will also attempt to load a dotenv file for the current environment. For example, when in the development environment, Vapor will load .env.development . Any values in the specific environment file will take precedence over the general .env file. A typical pattern is for projects to include a .env file as a template with default values. Specific environment files are ignored with the following pattern in .gitignore : .env.* When the project is cloned to a new computer, the template .env file can be copied and have the correct values inserted. cp .env .env.development vim .env.development Warning Dotenv files with sensitive information such as passwords should not be committed to version control. If you're having difficulty getting dotenv files to load, try enabling debug logging with --log debug for more information. Custom Environments \u00b6 To define a custom environment name, extend Environment . extension Environment { static var staging : Environment { . custom ( name : \"staging\" ) } } The application's environment is usually set in main.swift using Environment.detect() . import Vapor var env = try Environment . detect () try LoggingSystem . bootstrap ( from : & env ) let app = Application ( env ) defer { app . shutdown () } The detect method uses the process's command line arguments and parses the --env flag automatically. You can override this behavior by initializing a custom Environment struct. let env = Environment ( name : \"testing\" , arguments : [ \"vapor\" ]) The arguments array must contain at least one argument which represents the executable name. Further arguments can be supplied to simulate passing arguments via the command line. This is especially useful for testing.","title":"Environment"},{"location":"environment/#environment","text":"Vapor's Environment API helps you configure your app dynamically. By default, your app will use the development environment. You can define other useful environments like production or staging and change how your app is configured in each case. You can also load in variables from the process's environment or .env (dotenv) files depending on your needs. To access the current environment, use app.environment . You can switch on this property in configure(_:) to execute different configuration logic. switch app . environment { case . production : app . databases . use (....) default : app . databases . use (...) }","title":"Environment"},{"location":"environment/#changing-environment","text":"By default, your app will run in the development environment. You can change this by passing the --env ( -e ) flag during app boot. vapor run serve -- env production Vapor includes the following environments: name short description production prod Deployed to your users. development dev Local development. testing test For unit testing. Info The production environment will default to notice level logging unless otherwise specified. All other environments default to info . You can pass either the full or short name to the --env ( -e ) flag. vapor run serve - e prod","title":"Changing Environment"},{"location":"environment/#process-variables","text":"Environment offers a simple, string-based API for accessing the process's environment variables. let foo = Environment . get ( \"FOO\" ) print ( foo ) // String? In addition to get , Environment offers a dynamic member lookup API via process . let foo = Environment . process . FOO print ( foo ) // String? When running your app in the terminal, you can set environment variables using export . export FOO = BAR vapor run serve When running your app in Xcode, you can set environment variables by editing the Run scheme.","title":"Process Variables"},{"location":"environment/#env-dotenv","text":"Dotenv files contain a list of key-value pairs to be automatically loaded into the environment. These files make it easy to configure environment variables without needing to set them manually. Vapor will look for dotenv files in the current working directory. If you're using Xcode, make sure to set the working directory by editing the Run scheme. Assume the following .env file placed in your projects root folder: FOO = BAR When your application boots, you will be able to access the contents of this file like other process environment variables. let foo = Environment . get ( \"FOO\" ) print ( foo ) // String? Info Variables specified in .env files will not overwrite variables that already exist in the process environment. Alongside .env , Vapor will also attempt to load a dotenv file for the current environment. For example, when in the development environment, Vapor will load .env.development . Any values in the specific environment file will take precedence over the general .env file. A typical pattern is for projects to include a .env file as a template with default values. Specific environment files are ignored with the following pattern in .gitignore : .env.* When the project is cloned to a new computer, the template .env file can be copied and have the correct values inserted. cp .env .env.development vim .env.development Warning Dotenv files with sensitive information such as passwords should not be committed to version control. If you're having difficulty getting dotenv files to load, try enabling debug logging with --log debug for more information.","title":".env (dotenv)"},{"location":"environment/#custom-environments","text":"To define a custom environment name, extend Environment . extension Environment { static var staging : Environment { . custom ( name : \"staging\" ) } } The application's environment is usually set in main.swift using Environment.detect() . import Vapor var env = try Environment . detect () try LoggingSystem . bootstrap ( from : & env ) let app = Application ( env ) defer { app . shutdown () } The detect method uses the process's command line arguments and parses the --env flag automatically. You can override this behavior by initializing a custom Environment struct. let env = Environment ( name : \"testing\" , arguments : [ \"vapor\" ]) The arguments array must contain at least one argument which represents the executable name. Further arguments can be supplied to simulate passing arguments via the command line. This is especially useful for testing.","title":"Custom Environments"},{"location":"errors/","text":"Errors \u00b6 Vapor builds on Swift's Error protocol for error handling. Route handlers can either throw an error or return a failed EventLoopFuture . Throwing or returning a Swift Error will result in a 500 status response and the error will be logged. AbortError and DebuggableError can be used to change the resulting response and logging respectively. The handling of errors is done by ErrorMiddleware . This middleware is added to the application by default and can be replaced with custom logic if desired. Abort \u00b6 Vapor provides a default error struct named Abort . This struct conforms to both AbortError and DebuggableError . You can initialize it with an HTTP status and optional failure reason. // 400 error, default \"Not Found\" reason used. throw Abort (. notFound ) // 401 error, custom reason used. throw Abort (. unauthorized , reason : \"Invalid Credentials\" ) In asynchronous situations where throwing is not supported, like in a flatMap closure, you can return a failed future. guard let user = user else { req . eventLoop . makeFailedFuture ( Abort (. notFound )) } return user . save () Vapor includes a helper extension for unwrapping futures with optional values: unwrap(or:) . User . find ( id , on : db ) . unwrap ( or : Abort (. notFound )) . flatMap { user in // Non-optional User supplied to closure. } If User.find returns nil , the future will be failed with the supplied error. Otherwise, the flatMap will be supplied with a non-optional value. Abort Error \u00b6 By default, any Swift Error thrown or returned by a route closure will result in a 500 Internal Server Error response. When built in debug mode, ErrorMiddleware will include a description of the error. This is stripped out for security reasons when the project is built in release mode. To configure the resulting HTTP response status or reason for a particular error, conform it to AbortError . import Vapor enum MyError { case userNotLoggedIn case invalidEmail ( String ) } extension MyError : AbortError { var reason : String { switch self { case . userNotLoggedIn : return \"User is not logged in.\" case . invalidEmail ( let email ): return \"Email address is not valid: \\( email ) .\" } } var status : HTTPStatus { switch self { case . userNotLoggedIn : return . unauthorized case . invalidEmail : return . badRequest } } } Debuggable Error \u00b6 ErrorMiddleware uses the Logger.report(error:) method for logging errors thrown by your routes. This method will check for conformance to protocols like CustomStringConvertible and LocalizedError to log readable messages. To customize error logging, you can conform your errors to DebuggableError . This protocol includes a number of helpful properties like a unique identifier, source location, and stack trace. Most of these properties are optional which makes adopting the conformance easy. To best conform to DebuggableError , your error should be a struct so that it can store source and stack trace information if needed. Below is an example of the aforementioned MyError enum updated to use a struct and capture error source information. import Vapor struct MyError : DebuggableError { enum Value { case userNotLoggedIn case invalidEmail ( String ) } var identifier : String { switch self . value { case . userNotLoggedIn : return \"userNotLoggedIn\" case . invalidEmail : return \"invalidEmail\" } } var reason : String { switch self . value { case . userNotLoggedIn : return \"User is not logged in.\" case . invalidEmail ( let email ): return \"Email address is not valid: \\( email ) .\" } } var value : Value var source : ErrorSource ? init ( _ value : Value , file : String = #file , function : String = #function , line : UInt = #line , column : UInt = #column ) { self . value = value self . source = . init ( file : file , function : function , line : line , column : column ) } } DebuggableError has several other properties like possibleCauses and suggestedFixes that you can use to improve the debuggability of your errors. Take a look at the protocol itself for more information. Stack Traces \u00b6 Vapor includes support for viewing stack traces for both normal Swift errors and crashes. Swift Backtrace \u00b6 Vapor uses the SwiftBacktrace library to provide stack traces after a fatal error or assertion on Linux. In order for this to work, your app must include debug symbols during compilation. swift build -c release -Xswiftc -g Error Traces \u00b6 By default, Abort will capture the current stack trace when initialized. Your custom error types can achieve this by conforming to DebuggableError and storing StackTrace.capture() . import Vapor struct MyError : DebuggableError { var identifier : String var reason : String var stackTrace : StackTrace ? init ( identifier : String , reason : String , stackTrace : StackTrace ? = . capture () ) { self . identifier = identifier self . reason = reason self . stackTrace = stackTrace } } When your application's log level is set to .debug or lower, error stack traces will be included in log output. Stack traces will not be captured when the log level is greater than .debug . To override this behavior, set StackTrace.isCaptureEnabled manually in configure . // Always capture stack traces, regardless of log level. StackTrace . isCaptureEnabled = true Error Middleware \u00b6 ErrorMiddleware is the only middleware added to your application by default. This middleware converts Swift errors that have been thrown or returned by your route handlers into HTTP responses. Without this middleware, errors thrown will result in the connection being closed without a response. To customize error handling beyond what AbortError and DebuggableError provide, you can replace ErrorMiddleware with your own error handling logic. To do this, first remove the default error middleware by setting app.middleware to an empty configuration. Then, add your own error handling middleware as the first middleware to your application. // Remove all existing middleware. app . middleware = . init () // Add custom error handling middleware first. app . middleware . use ( MyErrorMiddleware ()) Very few middleware should go before the error handling middleware. A notable exception to this rule is CORSMiddleware .","title":"Errors"},{"location":"errors/#errors","text":"Vapor builds on Swift's Error protocol for error handling. Route handlers can either throw an error or return a failed EventLoopFuture . Throwing or returning a Swift Error will result in a 500 status response and the error will be logged. AbortError and DebuggableError can be used to change the resulting response and logging respectively. The handling of errors is done by ErrorMiddleware . This middleware is added to the application by default and can be replaced with custom logic if desired.","title":"Errors"},{"location":"errors/#abort","text":"Vapor provides a default error struct named Abort . This struct conforms to both AbortError and DebuggableError . You can initialize it with an HTTP status and optional failure reason. // 400 error, default \"Not Found\" reason used. throw Abort (. notFound ) // 401 error, custom reason used. throw Abort (. unauthorized , reason : \"Invalid Credentials\" ) In asynchronous situations where throwing is not supported, like in a flatMap closure, you can return a failed future. guard let user = user else { req . eventLoop . makeFailedFuture ( Abort (. notFound )) } return user . save () Vapor includes a helper extension for unwrapping futures with optional values: unwrap(or:) . User . find ( id , on : db ) . unwrap ( or : Abort (. notFound )) . flatMap { user in // Non-optional User supplied to closure. } If User.find returns nil , the future will be failed with the supplied error. Otherwise, the flatMap will be supplied with a non-optional value.","title":"Abort"},{"location":"errors/#abort-error","text":"By default, any Swift Error thrown or returned by a route closure will result in a 500 Internal Server Error response. When built in debug mode, ErrorMiddleware will include a description of the error. This is stripped out for security reasons when the project is built in release mode. To configure the resulting HTTP response status or reason for a particular error, conform it to AbortError . import Vapor enum MyError { case userNotLoggedIn case invalidEmail ( String ) } extension MyError : AbortError { var reason : String { switch self { case . userNotLoggedIn : return \"User is not logged in.\" case . invalidEmail ( let email ): return \"Email address is not valid: \\( email ) .\" } } var status : HTTPStatus { switch self { case . userNotLoggedIn : return . unauthorized case . invalidEmail : return . badRequest } } }","title":"Abort Error"},{"location":"errors/#debuggable-error","text":"ErrorMiddleware uses the Logger.report(error:) method for logging errors thrown by your routes. This method will check for conformance to protocols like CustomStringConvertible and LocalizedError to log readable messages. To customize error logging, you can conform your errors to DebuggableError . This protocol includes a number of helpful properties like a unique identifier, source location, and stack trace. Most of these properties are optional which makes adopting the conformance easy. To best conform to DebuggableError , your error should be a struct so that it can store source and stack trace information if needed. Below is an example of the aforementioned MyError enum updated to use a struct and capture error source information. import Vapor struct MyError : DebuggableError { enum Value { case userNotLoggedIn case invalidEmail ( String ) } var identifier : String { switch self . value { case . userNotLoggedIn : return \"userNotLoggedIn\" case . invalidEmail : return \"invalidEmail\" } } var reason : String { switch self . value { case . userNotLoggedIn : return \"User is not logged in.\" case . invalidEmail ( let email ): return \"Email address is not valid: \\( email ) .\" } } var value : Value var source : ErrorSource ? init ( _ value : Value , file : String = #file , function : String = #function , line : UInt = #line , column : UInt = #column ) { self . value = value self . source = . init ( file : file , function : function , line : line , column : column ) } } DebuggableError has several other properties like possibleCauses and suggestedFixes that you can use to improve the debuggability of your errors. Take a look at the protocol itself for more information.","title":"Debuggable Error"},{"location":"errors/#stack-traces","text":"Vapor includes support for viewing stack traces for both normal Swift errors and crashes.","title":"Stack Traces"},{"location":"errors/#swift-backtrace","text":"Vapor uses the SwiftBacktrace library to provide stack traces after a fatal error or assertion on Linux. In order for this to work, your app must include debug symbols during compilation. swift build -c release -Xswiftc -g","title":"Swift Backtrace"},{"location":"errors/#error-traces","text":"By default, Abort will capture the current stack trace when initialized. Your custom error types can achieve this by conforming to DebuggableError and storing StackTrace.capture() . import Vapor struct MyError : DebuggableError { var identifier : String var reason : String var stackTrace : StackTrace ? init ( identifier : String , reason : String , stackTrace : StackTrace ? = . capture () ) { self . identifier = identifier self . reason = reason self . stackTrace = stackTrace } } When your application's log level is set to .debug or lower, error stack traces will be included in log output. Stack traces will not be captured when the log level is greater than .debug . To override this behavior, set StackTrace.isCaptureEnabled manually in configure . // Always capture stack traces, regardless of log level. StackTrace . isCaptureEnabled = true","title":"Error Traces"},{"location":"errors/#error-middleware","text":"ErrorMiddleware is the only middleware added to your application by default. This middleware converts Swift errors that have been thrown or returned by your route handlers into HTTP responses. Without this middleware, errors thrown will result in the connection being closed without a response. To customize error handling beyond what AbortError and DebuggableError provide, you can replace ErrorMiddleware with your own error handling logic. To do this, first remove the default error middleware by setting app.middleware to an empty configuration. Then, add your own error handling middleware as the first middleware to your application. // Remove all existing middleware. app . middleware = . init () // Add custom error handling middleware first. app . middleware . use ( MyErrorMiddleware ()) Very few middleware should go before the error handling middleware. A notable exception to this rule is CORSMiddleware .","title":"Error Middleware"},{"location":"folder-structure/","text":"Folder Structure \u00b6 \u60a8\u5df2\u7ecf\u521b\u5efa\uff0c\u6784\u5efa\u5e76\u8fd0\u884c\u4e86\u7b2c\u4e00\u4e2a Vapor \u5e94\u7528\u7a0b\u5e8f\uff0c\u73b0\u5728\u8ba9\u6211\u4eec\u82b1\u70b9\u65f6\u95f4\u719f\u6089\u4e00\u4e0b Vapor \u7684\u6587\u4ef6\u5939\u7ed3\u6784\u3002\u8be5\u7ed3\u6784\u57fa\u4e8e SPM \u7684\u6587\u4ef6\u5939\u7ed3\u6784\uff0c\u56e0\u6b64\uff0c\u5982\u679c\u60a8\u4e0d\u4e86\u89e3 SPM \u4e86\uff0c\u5e94\u8be5\u5148\u719f\u6089\u4e00\u4e0b\u3002 . \u251c\u2500\u2500 Public \u251c\u2500\u2500 Sources \u2502 \u251c\u2500\u2500 App \u2502 \u2502 \u251c\u2500\u2500 Controllers \u2502 \u2502 \u251c\u2500\u2500 Migrations \u2502 \u2502 \u251c\u2500\u2500 Models \u2502 \u2502 \u251c\u2500\u2500 app.swift \u2502 \u2502 \u251c\u2500\u2500 configure.swift \u2502 \u2502 \u2514\u2500\u2500 routes.swift \u2502 \u2514\u2500\u2500 Run \u2502 \u2514\u2500\u2500 main.swift \u251c\u2500\u2500 Tests \u2502 \u2514\u2500\u2500 AppTests \u2514\u2500\u2500 Package.swift \u4ee5\u4e0b\u5404\u8282\u5c06\u66f4\u8be6\u7ec6\u5730\u8bf4\u660e\u6587\u4ef6\u5939\u7ed3\u6784\u7684\u6bcf\u4e2a\u90e8\u5206 Public \u00b6 \u5982\u679c\u542f\u7528\u4e86 FileMiddleware \uff0c\u6b64\u6587\u4ef6\u5939\u5305\u542b\u5e94\u7528\u6240\u9700\u7684\u6240\u6709\u516c\u5171\u6587\u4ef6\u3002\u8fd9\u4e9b\u6587\u4ef6\u901a\u5e38\u662f\u56fe\u50cf\uff0c\u6837\u5f0f\u8868\u548c\u6d4f\u89c8\u5668\u811a\u672c\u3002\u4f8b\u5982\uff0c\u5bf9 localhost:8080/favicon.ico \u7684\u8bf7\u6c42\u5c06\u68c0\u67e5\u662f\u5426\u5b58\u5728 Public/favicon.ico \u5e76\u5c06\u5176\u8fd4\u56de \u5728Vapor\u53ef\u4ee5\u63d0\u4f9b\u516c\u5171\u6587\u4ef6\u4e4b\u524d\uff0c\u60a8\u9700\u8981\u5728 configure.swift \u6587\u4ef6\u4e2d\u542f\u7528 FileMiddleware // Serves files from `Public/` directory let fileMiddleware = FileMiddleware ( publicDirectory : app . directory . publicDirectory ) app . middleware . use ( fileMiddleware ) Sources \u00b6 \u8be5\u6587\u4ef6\u5939\u5305\u542b\u9879\u76ee\u7684\u6240\u6709 Swift \u6e90\u6587\u4ef6\u3002\u9876\u5c42\u6587\u4ef6\u5939 App \u548c Run \u5bf9\u5e94\u5305\u7684\u6a21\u5757\uff0c SPM \u4e2d\u6709\u76f8\u5e94\u7684\u58f0\u660e\u3002 App \u00b6 \u5e94\u7528\u7684\u903b\u8f91\u5904\u7406\u653e\u5165\u5230\u8fd9\u4e2a\u6587\u4ef6\u4e2d\u3002 Controllers \u00b6 Controller \u662f\u5c06\u5e94\u7528\u903b\u8f91\u5904\u7406\u5206\u7ec4\u5728\u4e00\u8d77\u7684\u597d\u65b9\u6cd5\u3002\u5927\u591a\u6570\u7684 Controller \u6709\u8bb8\u591a\u5904\u7406\u63a5\u53d7\u8bf7\u6c42\u5e76\u8fd4\u56de\u54cd\u5e94\u7684\u51fd\u6570 Migrations \u00b6 \u5982\u679c\u60a8\u4f7f\u7528 Fluent\uff0c \u53ef\u4ee5\u5c06\u6570\u636e\u5e93\u8fc1\u79fb\u7684\u5185\u5bb9\u653e\u5165\u5230\u8fd9\u4e2a\u6587\u4ef6\u5939\u3002 Models \u00b6 \u7528\u4e8e\u5b58\u653e Content structs \u6216\u8005 Fluent Model s app.swift \u00b6 \u8be5\u6587\u4ef6\u5305\u542b app(_:) \u51fd\u6570\uff0c\u8be5\u51fd\u6570\u521b\u5efa Vapor Application \u7684\u914d\u7f6e\u5b9e\u4f8b\u3002\u5728 Run \u91cc\u9762\u7684 main.swift \u4f7f\u7528\u6b64\u65b9\u6cd5\u6765\u521b\u5efa\u548c\u8fd0\u884c\u60a8\u7684\u5e94\u7528\u3002\u6d4b\u8bd5\u4e2d\u8fd8\u4f7f\u7528\u6b64\u65b9\u6cd5\u6765\u521b\u5efa\u5e94\u7528\u7a0b\u5e8f\u5b9e\u4f8b\u4ee5\u8fdb\u884c\u6d4b\u8bd5 configure.swift \u00b6 \u8fd9\u4e2a\u6587\u4ef6\u5305\u542b configure(_:) \u51fd\u6570\u3002 app(_:) \u8c03\u7528\u6b64\u51fd\u6570\u4ee5\u914d\u7f6e\u65b0\u521b\u5efa\u7684 Application\u3002\u5728\u8fd9\u91cc\u60a8\u5e94\u8be5\u6ce8\u518c\u8bf8\u5982routes\uff0cdatabases\uff0cproviders \u7b49\u670d\u52a1\u3002 routes.swift \u00b6 \u8fd9\u4e2a\u6587\u4ef6\u5305\u542b routes(_:) \u51fd\u6570\u3002\u8fd9\u4e2a\u65b9\u6cd5\u5728 configure(_ :) \u7684\u7ed3\u5c3e\u5904\u88ab\u8c03\u7528\uff0c\u4ee5\u6ce8\u518c\u8def\u7531\u5230\u60a8\u7684 Application \u4e2d\u3002 Tests \u00b6 Sources\u6587\u4ef6\u5939\u4e2d\u7684\u6bcf\u4e2a\u4e0d\u53ef\u6267\u884c\u6a21\u5757\u5728Tests\u4e2d\u90fd\u53ef\u4ee5\u6709\u4e00\u4e2a\u5bf9\u5e94\u7684\u6587\u4ef6\u5939\u3002\u8fd9\u5305\u542b\u5728 XCTest \u6a21\u5757\u4e0a\u6784\u5efa\u7684\u4ee3\u7801\uff0c\u7528\u4e8e\u6d4b\u8bd5\u60a8\u7684\u8f6f\u4ef6\u5305\u3002\u53ef\u4ee5\u5728\u547d\u4ee4\u884c\u4e0a\u4f7f\u7528 swift test \u6216\u5728Xcode\u4e2d\u6309 \u2318 + U \u6765\u8fd0\u884c\u6d4b\u8bd5\u3002 AppTests \u00b6 \u6b64\u6587\u4ef6\u5939\u5305\u542b App \u6a21\u5757\u4e2d\u4ee3\u7801\u7684\u5355\u5143\u6d4b\u8bd5\u3002 Package.swift \u00b6 \u6700\u540e\u662f SPM \u7684\u8f6f\u4ef6\u5305\u6e05\u5355","title":"Folder Structure"},{"location":"folder-structure/#folder-structure","text":"\u60a8\u5df2\u7ecf\u521b\u5efa\uff0c\u6784\u5efa\u5e76\u8fd0\u884c\u4e86\u7b2c\u4e00\u4e2a Vapor \u5e94\u7528\u7a0b\u5e8f\uff0c\u73b0\u5728\u8ba9\u6211\u4eec\u82b1\u70b9\u65f6\u95f4\u719f\u6089\u4e00\u4e0b Vapor \u7684\u6587\u4ef6\u5939\u7ed3\u6784\u3002\u8be5\u7ed3\u6784\u57fa\u4e8e SPM \u7684\u6587\u4ef6\u5939\u7ed3\u6784\uff0c\u56e0\u6b64\uff0c\u5982\u679c\u60a8\u4e0d\u4e86\u89e3 SPM \u4e86\uff0c\u5e94\u8be5\u5148\u719f\u6089\u4e00\u4e0b\u3002 . \u251c\u2500\u2500 Public \u251c\u2500\u2500 Sources \u2502 \u251c\u2500\u2500 App \u2502 \u2502 \u251c\u2500\u2500 Controllers \u2502 \u2502 \u251c\u2500\u2500 Migrations \u2502 \u2502 \u251c\u2500\u2500 Models \u2502 \u2502 \u251c\u2500\u2500 app.swift \u2502 \u2502 \u251c\u2500\u2500 configure.swift \u2502 \u2502 \u2514\u2500\u2500 routes.swift \u2502 \u2514\u2500\u2500 Run \u2502 \u2514\u2500\u2500 main.swift \u251c\u2500\u2500 Tests \u2502 \u2514\u2500\u2500 AppTests \u2514\u2500\u2500 Package.swift \u4ee5\u4e0b\u5404\u8282\u5c06\u66f4\u8be6\u7ec6\u5730\u8bf4\u660e\u6587\u4ef6\u5939\u7ed3\u6784\u7684\u6bcf\u4e2a\u90e8\u5206","title":"Folder Structure"},{"location":"folder-structure/#public","text":"\u5982\u679c\u542f\u7528\u4e86 FileMiddleware \uff0c\u6b64\u6587\u4ef6\u5939\u5305\u542b\u5e94\u7528\u6240\u9700\u7684\u6240\u6709\u516c\u5171\u6587\u4ef6\u3002\u8fd9\u4e9b\u6587\u4ef6\u901a\u5e38\u662f\u56fe\u50cf\uff0c\u6837\u5f0f\u8868\u548c\u6d4f\u89c8\u5668\u811a\u672c\u3002\u4f8b\u5982\uff0c\u5bf9 localhost:8080/favicon.ico \u7684\u8bf7\u6c42\u5c06\u68c0\u67e5\u662f\u5426\u5b58\u5728 Public/favicon.ico \u5e76\u5c06\u5176\u8fd4\u56de \u5728Vapor\u53ef\u4ee5\u63d0\u4f9b\u516c\u5171\u6587\u4ef6\u4e4b\u524d\uff0c\u60a8\u9700\u8981\u5728 configure.swift \u6587\u4ef6\u4e2d\u542f\u7528 FileMiddleware // Serves files from `Public/` directory let fileMiddleware = FileMiddleware ( publicDirectory : app . directory . publicDirectory ) app . middleware . use ( fileMiddleware )","title":"Public"},{"location":"folder-structure/#sources","text":"\u8be5\u6587\u4ef6\u5939\u5305\u542b\u9879\u76ee\u7684\u6240\u6709 Swift \u6e90\u6587\u4ef6\u3002\u9876\u5c42\u6587\u4ef6\u5939 App \u548c Run \u5bf9\u5e94\u5305\u7684\u6a21\u5757\uff0c SPM \u4e2d\u6709\u76f8\u5e94\u7684\u58f0\u660e\u3002","title":"Sources"},{"location":"folder-structure/#app","text":"\u5e94\u7528\u7684\u903b\u8f91\u5904\u7406\u653e\u5165\u5230\u8fd9\u4e2a\u6587\u4ef6\u4e2d\u3002","title":"App"},{"location":"folder-structure/#controllers","text":"Controller \u662f\u5c06\u5e94\u7528\u903b\u8f91\u5904\u7406\u5206\u7ec4\u5728\u4e00\u8d77\u7684\u597d\u65b9\u6cd5\u3002\u5927\u591a\u6570\u7684 Controller \u6709\u8bb8\u591a\u5904\u7406\u63a5\u53d7\u8bf7\u6c42\u5e76\u8fd4\u56de\u54cd\u5e94\u7684\u51fd\u6570","title":"Controllers"},{"location":"folder-structure/#migrations","text":"\u5982\u679c\u60a8\u4f7f\u7528 Fluent\uff0c \u53ef\u4ee5\u5c06\u6570\u636e\u5e93\u8fc1\u79fb\u7684\u5185\u5bb9\u653e\u5165\u5230\u8fd9\u4e2a\u6587\u4ef6\u5939\u3002","title":"Migrations"},{"location":"folder-structure/#models","text":"\u7528\u4e8e\u5b58\u653e Content structs \u6216\u8005 Fluent Model s","title":"Models"},{"location":"folder-structure/#appswift","text":"\u8be5\u6587\u4ef6\u5305\u542b app(_:) \u51fd\u6570\uff0c\u8be5\u51fd\u6570\u521b\u5efa Vapor Application \u7684\u914d\u7f6e\u5b9e\u4f8b\u3002\u5728 Run \u91cc\u9762\u7684 main.swift \u4f7f\u7528\u6b64\u65b9\u6cd5\u6765\u521b\u5efa\u548c\u8fd0\u884c\u60a8\u7684\u5e94\u7528\u3002\u6d4b\u8bd5\u4e2d\u8fd8\u4f7f\u7528\u6b64\u65b9\u6cd5\u6765\u521b\u5efa\u5e94\u7528\u7a0b\u5e8f\u5b9e\u4f8b\u4ee5\u8fdb\u884c\u6d4b\u8bd5","title":"app.swift"},{"location":"folder-structure/#configureswift","text":"\u8fd9\u4e2a\u6587\u4ef6\u5305\u542b configure(_:) \u51fd\u6570\u3002 app(_:) \u8c03\u7528\u6b64\u51fd\u6570\u4ee5\u914d\u7f6e\u65b0\u521b\u5efa\u7684 Application\u3002\u5728\u8fd9\u91cc\u60a8\u5e94\u8be5\u6ce8\u518c\u8bf8\u5982routes\uff0cdatabases\uff0cproviders \u7b49\u670d\u52a1\u3002","title":"configure.swift"},{"location":"folder-structure/#routesswift","text":"\u8fd9\u4e2a\u6587\u4ef6\u5305\u542b routes(_:) \u51fd\u6570\u3002\u8fd9\u4e2a\u65b9\u6cd5\u5728 configure(_ :) \u7684\u7ed3\u5c3e\u5904\u88ab\u8c03\u7528\uff0c\u4ee5\u6ce8\u518c\u8def\u7531\u5230\u60a8\u7684 Application \u4e2d\u3002","title":"routes.swift"},{"location":"folder-structure/#tests","text":"Sources\u6587\u4ef6\u5939\u4e2d\u7684\u6bcf\u4e2a\u4e0d\u53ef\u6267\u884c\u6a21\u5757\u5728Tests\u4e2d\u90fd\u53ef\u4ee5\u6709\u4e00\u4e2a\u5bf9\u5e94\u7684\u6587\u4ef6\u5939\u3002\u8fd9\u5305\u542b\u5728 XCTest \u6a21\u5757\u4e0a\u6784\u5efa\u7684\u4ee3\u7801\uff0c\u7528\u4e8e\u6d4b\u8bd5\u60a8\u7684\u8f6f\u4ef6\u5305\u3002\u53ef\u4ee5\u5728\u547d\u4ee4\u884c\u4e0a\u4f7f\u7528 swift test \u6216\u5728Xcode\u4e2d\u6309 \u2318 + U \u6765\u8fd0\u884c\u6d4b\u8bd5\u3002","title":"Tests"},{"location":"folder-structure/#apptests","text":"\u6b64\u6587\u4ef6\u5939\u5305\u542b App \u6a21\u5757\u4e2d\u4ee3\u7801\u7684\u5355\u5143\u6d4b\u8bd5\u3002","title":"AppTests"},{"location":"folder-structure/#packageswift","text":"\u6700\u540e\u662f SPM \u7684\u8f6f\u4ef6\u5305\u6e05\u5355","title":"Package.swift"},{"location":"hello-world/","text":"\u4f60\u597d\uff0c\u4e16\u754c \u00b6 \u672c\u6307\u5357\u5c06\u5f15\u5bfc\u60a8\u9010\u6b65\u6784\u5efa Vapor \u9879\u76ee\u5e76\u8fd0\u884c\u3002 \u5982\u679c\u5c1a\u672a\u5b89\u88c5 Swift \u6216 Vapor Toolbox\uff0c\u8bf7\u67e5\u770b\u5b89\u88c5\u90e8\u5206\uff1a \u5b89\u88c5 \u2192 macOS \u5b89\u88c5 \u2192 Ubuntu \u65b0\u9879\u76ee \u00b6 \u9996\u5148\u5728\u8ba1\u7b97\u673a\u4e0a\u521b\u5efa\u4e00\u4e2a\u65b0\u7684 Vapor \u9879\u76ee\u3002 \u6253\u5f00 Terminal \u5e76\u4f7f\u7528\u5982\u4e0b\u547d\u4ee4\u884c\u6765\u521b\u5efa\u65b0\u9879\u76ee\u3002\u8fd9\u5c06\u4f1a\u5728\u5f53\u524d\u76ee\u5f55\u4e2d\u521b\u5efa\u4e00\u4e2a\u5305\u542b\u65b0\u9879\u76ee\u7684\u6587\u4ef6\u5939\u3002 vapor-beta new hello -n \u6ce8\u610f \u4f7f\u7528 -n \u53c2\u6570\u4f1a\u4e3a\u60a8\u63d0\u4f9b\u4e00\u4e2a\u7b80\u5355\u7684\u6a21\u677f\u3002 \u547d\u4ee4\u5b8c\u6210\u540e\uff0c\u8fdb\u5165\u65b0\u521b\u5efa\u7684 Vapor \u9879\u76ee\u6587\u4ef6\u5939\uff0c\u5e76\u5728 Xcode \u4e2d\u6253\u5f00\u9879\u76ee\u3002 cd hello open Package.swift \u7f16\u8bd1\u548c\u8fd0\u884c \u00b6 \u60a8\u73b0\u5728\u53ef\u4ee5\u6253\u5f00 Xcode\uff0c\u5355\u51fb Run \u6309\u94ae\u4ee5\u6784\u5efa\u5e76\u8fd0\u884c\u60a8\u7684\u9879\u76ee\u3002 \u60a8\u5e94\u8be5\u53ef\u4ee5\u770b\u5230\u5728\u5c4f\u5e55\u5e95\u90e8\u8f93\u51fa\u7684\u542f\u52a8\u4fe1\u606f\u3002 [ INFO ] Server starting on http://127.0.0.1:8080 \u672c\u5730\u8bbf\u95ee \u00b6 \u6253\u5f00\u60a8\u7684 Web \u6d4f\u89c8\u5668\uff0c\u7136\u540e\u8bbf\u95ee localhost:8080/hello \u60a8\u5e94\u8be5\u80fd\u591f\u770b\u5230\u4ee5\u4e0b\u9875\u9762\u5185\u5bb9\uff1a Hello, world! \u90a3\u4e48\u606d\u559c\u60a8\uff01\u6210\u529f\u5730\u521b\u5efa\u548c\u8fd0\u884c\u4e86\u60a8\u7684\u7b2c\u4e00\u4e2a Vapor \u5e94\u7528\u7a0b\u5e8f\uff01 \ud83c\udf89","title":"Hello, world"},{"location":"hello-world/#_1","text":"\u672c\u6307\u5357\u5c06\u5f15\u5bfc\u60a8\u9010\u6b65\u6784\u5efa Vapor \u9879\u76ee\u5e76\u8fd0\u884c\u3002 \u5982\u679c\u5c1a\u672a\u5b89\u88c5 Swift \u6216 Vapor Toolbox\uff0c\u8bf7\u67e5\u770b\u5b89\u88c5\u90e8\u5206\uff1a \u5b89\u88c5 \u2192 macOS \u5b89\u88c5 \u2192 Ubuntu","title":"\u4f60\u597d\uff0c\u4e16\u754c"},{"location":"hello-world/#_2","text":"\u9996\u5148\u5728\u8ba1\u7b97\u673a\u4e0a\u521b\u5efa\u4e00\u4e2a\u65b0\u7684 Vapor \u9879\u76ee\u3002 \u6253\u5f00 Terminal \u5e76\u4f7f\u7528\u5982\u4e0b\u547d\u4ee4\u884c\u6765\u521b\u5efa\u65b0\u9879\u76ee\u3002\u8fd9\u5c06\u4f1a\u5728\u5f53\u524d\u76ee\u5f55\u4e2d\u521b\u5efa\u4e00\u4e2a\u5305\u542b\u65b0\u9879\u76ee\u7684\u6587\u4ef6\u5939\u3002 vapor-beta new hello -n \u6ce8\u610f \u4f7f\u7528 -n \u53c2\u6570\u4f1a\u4e3a\u60a8\u63d0\u4f9b\u4e00\u4e2a\u7b80\u5355\u7684\u6a21\u677f\u3002 \u547d\u4ee4\u5b8c\u6210\u540e\uff0c\u8fdb\u5165\u65b0\u521b\u5efa\u7684 Vapor \u9879\u76ee\u6587\u4ef6\u5939\uff0c\u5e76\u5728 Xcode \u4e2d\u6253\u5f00\u9879\u76ee\u3002 cd hello open Package.swift","title":"\u65b0\u9879\u76ee"},{"location":"hello-world/#_3","text":"\u60a8\u73b0\u5728\u53ef\u4ee5\u6253\u5f00 Xcode\uff0c\u5355\u51fb Run \u6309\u94ae\u4ee5\u6784\u5efa\u5e76\u8fd0\u884c\u60a8\u7684\u9879\u76ee\u3002 \u60a8\u5e94\u8be5\u53ef\u4ee5\u770b\u5230\u5728\u5c4f\u5e55\u5e95\u90e8\u8f93\u51fa\u7684\u542f\u52a8\u4fe1\u606f\u3002 [ INFO ] Server starting on http://127.0.0.1:8080","title":"\u7f16\u8bd1\u548c\u8fd0\u884c"},{"location":"hello-world/#_4","text":"\u6253\u5f00\u60a8\u7684 Web \u6d4f\u89c8\u5668\uff0c\u7136\u540e\u8bbf\u95ee localhost:8080/hello \u60a8\u5e94\u8be5\u80fd\u591f\u770b\u5230\u4ee5\u4e0b\u9875\u9762\u5185\u5bb9\uff1a Hello, world! \u90a3\u4e48\u606d\u559c\u60a8\uff01\u6210\u529f\u5730\u521b\u5efa\u548c\u8fd0\u884c\u4e86\u60a8\u7684\u7b2c\u4e00\u4e2a Vapor \u5e94\u7528\u7a0b\u5e8f\uff01 \ud83c\udf89","title":"\u672c\u5730\u8bbf\u95ee"},{"location":"logging/","text":"Logging \u00b6 Vapor's logging API is built on top of SwiftLog . This means Vapor is compatible with all of SwiftLog's backend implementations . Logger \u00b6 Instances of Logger are used for outputting log messages. Vapor provides a few easy ways to get access to a logger. Request \u00b6 Each incoming Request has a unique logger that you should use for any logs specific to that request. app . get ( \"hello\" ) { req -> String in req . logger . info ( \"Hello, logs!\" ) return \"Hello, world!\" } The request logger includes a unique UUID identifying the incoming request to make tracking logs easier. [ INFO ] Hello, logs! [request-id: C637065A-8CB0-4502-91DC-9B8615C5D315] (App/routes.swift:10) Info Logger metadata will only be shown in debug log level or lower. Application \u00b6 For log messages during app boot and configuration, use Application 's logger. app . logger . info ( \"Setting up migrations...\" ) app . migrations . use (...) Custom Logger \u00b6 In situations where you don't have access to Application or Request , you can initialize a new Logger . let logger = Logger ( label : \"dev.logger.my\" ) logger . info (...) While custom loggers will still output to your configured logging backend, they will not have important metadata attached like request UUID. Use the request or application specific loggers wherever possible. Level \u00b6 SwiftLog supports several different logging levels. name description trace Appropriate for messages that contain information only when debugging a program. debug Appropriate for messages that contain information normally of use only when debugging a program. info Appropriate for informational messages. notice Appropriate for conditions that are not error conditions, but that may require special handling. warning Appropriate for messages that are not error conditions, but more severe than notice. error Appropriate for error conditions. critical Appropriate for critical error conditions that usually require immediate attention. When a critical message is logged, the logging backend is free to perform more heavy-weight operations to capture system state (such as capturing stack traces) to facilitate debugging. By default, Vapor will use info level logging. When run with the production environment, notice will be used to improve performance. Changing Log Level \u00b6 Regardless of environment mode, you can override the logging level to increase or decrease the amount of logs produced. The first method is to pass the optional --log flag when booting your application. vapor run serve --log debug The second method is to set the LOG_LEVEL environment variable. export LOG_LEVEL = debug vapor run serve Both of these can be done in Xcode by editing the Run scheme. Configuration \u00b6 SwiftLog is configured by boostrapping the LoggingSystem once per process. Vapor projects typically do this in main.swift . import Vapor var env = try Environment . detect () try LoggingSystem . bootstrap ( from : & env ) bootstrap(from:) is a helper method provided by Vapor that will configure the default log handler based on command-line arguments and environment variables. The default log handler supports outputting messages to the terminal with ANSI color support. Custom Handler \u00b6 You can override Vapor's default log handler and register your own. import Logging LoggingSystem . bootstrap { label in StreamLogHandler . standardOutput ( label : label ) } All of SwiftLog's supported backends will work with Vapor. However, changing the log level with command-line arguments and environment variables is only compatible with Vapor's default log handler.","title":"Logging"},{"location":"logging/#logging","text":"Vapor's logging API is built on top of SwiftLog . This means Vapor is compatible with all of SwiftLog's backend implementations .","title":"Logging"},{"location":"logging/#logger","text":"Instances of Logger are used for outputting log messages. Vapor provides a few easy ways to get access to a logger.","title":"Logger"},{"location":"logging/#request","text":"Each incoming Request has a unique logger that you should use for any logs specific to that request. app . get ( \"hello\" ) { req -> String in req . logger . info ( \"Hello, logs!\" ) return \"Hello, world!\" } The request logger includes a unique UUID identifying the incoming request to make tracking logs easier. [ INFO ] Hello, logs! [request-id: C637065A-8CB0-4502-91DC-9B8615C5D315] (App/routes.swift:10) Info Logger metadata will only be shown in debug log level or lower.","title":"Request"},{"location":"logging/#application","text":"For log messages during app boot and configuration, use Application 's logger. app . logger . info ( \"Setting up migrations...\" ) app . migrations . use (...)","title":"Application"},{"location":"logging/#custom-logger","text":"In situations where you don't have access to Application or Request , you can initialize a new Logger . let logger = Logger ( label : \"dev.logger.my\" ) logger . info (...) While custom loggers will still output to your configured logging backend, they will not have important metadata attached like request UUID. Use the request or application specific loggers wherever possible.","title":"Custom Logger"},{"location":"logging/#level","text":"SwiftLog supports several different logging levels. name description trace Appropriate for messages that contain information only when debugging a program. debug Appropriate for messages that contain information normally of use only when debugging a program. info Appropriate for informational messages. notice Appropriate for conditions that are not error conditions, but that may require special handling. warning Appropriate for messages that are not error conditions, but more severe than notice. error Appropriate for error conditions. critical Appropriate for critical error conditions that usually require immediate attention. When a critical message is logged, the logging backend is free to perform more heavy-weight operations to capture system state (such as capturing stack traces) to facilitate debugging. By default, Vapor will use info level logging. When run with the production environment, notice will be used to improve performance.","title":"Level"},{"location":"logging/#changing-log-level","text":"Regardless of environment mode, you can override the logging level to increase or decrease the amount of logs produced. The first method is to pass the optional --log flag when booting your application. vapor run serve --log debug The second method is to set the LOG_LEVEL environment variable. export LOG_LEVEL = debug vapor run serve Both of these can be done in Xcode by editing the Run scheme.","title":"Changing Log Level"},{"location":"logging/#configuration","text":"SwiftLog is configured by boostrapping the LoggingSystem once per process. Vapor projects typically do this in main.swift . import Vapor var env = try Environment . detect () try LoggingSystem . bootstrap ( from : & env ) bootstrap(from:) is a helper method provided by Vapor that will configure the default log handler based on command-line arguments and environment variables. The default log handler supports outputting messages to the terminal with ANSI color support.","title":"Configuration"},{"location":"logging/#custom-handler","text":"You can override Vapor's default log handler and register your own. import Logging LoggingSystem . bootstrap { label in StreamLogHandler . standardOutput ( label : label ) } All of SwiftLog's supported backends will work with Vapor. However, changing the log level with command-line arguments and environment variables is only compatible with Vapor's default log handler.","title":"Custom Handler"},{"location":"middleware/","text":"Middleware \u00b6 Middleware \u662f client \u548c\u8def\u7531\u5904\u7406\u7a0b\u5e8f\u95f4\u7684\u4e00\u4e2a\u903b\u8f91\u94fe\u3002\u5b83\u5141\u8bb8\u60a8\u5728\u4f20\u5165\u8bf7\u6c42\u5230\u8fbe\u8def\u7531\u5904\u7406\u7a0b\u5e8f\u4e4b\u524d\u5bf9\u4f20\u5165\u8bf7\u6c42\u6267\u884c\u64cd\u4f5c\u5e76\u4e14\u5728\u8f93\u51fa\u54cd\u5e94\u5230\u8fbeclient\u4e4b\u524d\u5bf9\u4f20\u51fa\u54cd\u5e94\u6267\u884c\u64cd\u4f5c\u3002 Configuration \u00b6 Middleware \u53ef\u4ee5\u5728 configure(_:) \u4f7f\u7528 app.middleware \u5168\u5c40\u6ce8\u518c(\u6bcf\u4e00\u4e2a\u8def\u7531) app . middleware . use ( MyMiddleware ()) \u4f60\u4e5f\u53ef\u4ee5\u901a\u8fc7\u8def\u7531\u7ec4\u7684\u65b9\u5f0f\u7ed9\u4e2a\u522b\u8def\u7531\u6dfb\u52a0 middleware let group = app . grouped ( MyMiddleware ()) group . get ( \"foo\" ) { req in // This request has passed through MyMiddleware. } Order \u00b6 Middleware \u7684\u6dfb\u52a0\u987a\u5e8f\u975e\u5e38\u91cd\u8981\u3002\u8fdb\u5165\u60a8\u5e94\u7528\u7a0b\u5e8f\u7684\u8bf7\u6c42\u5c06\u6309\u7167 middleware \u6dfb\u52a0\u7684\u987a\u5e8f\u4f9d\u6b21\u6267\u884c\u3002\u8fd4\u56de\u7ed9 client \u7684\u54cd\u5e94\u5c06\u4ee5\u4e2d\u95f4\u4ef6\u6dfb\u52a0\u987a\u5e8f\u7684\u9006\u5e8f\u65b9\u5f0f\u4f9d\u6b21\u6267\u884c\u3002Route-specific middleware \u603b\u662f\u5728 application middleware \u4e4b\u540e\u6267\u884c\u3002\u6bd4\u5982\u4e0b\u9762\u7684 example: app . middleware . use ( MiddlewareA ()) app . middleware . use ( MiddlewareB ()) app . group ( MiddlewareC ()) { $0 . get ( \"hello\" ) { req in \"Hello, middleware.\" } } GET /hello \u8fd9\u4e2a\u8bf7\u6c42\u5c06\u6309\u7167\u4ee5\u4e0b\u987a\u5e8f\u8bbf\u95ee\u4e2d\u95f4\u4ef6\uff1a Request \u2192 A \u2192 B \u2192 C \u2192 Handler \u2192 C \u2192 B \u2192 A \u2192 Response File Middleware \u00b6 FileMiddleware \u5141\u8bb8\u4ece\u9879\u76ee\u7684 Public \u6587\u4ef6\u5939\u5411 client \u63d0\u4f9b\u8d44\u6e90\u3002\u60a8\u53ef\u80fd\u5728\u8fd9\u91cc\u5b58\u653e css \u6216\u8005\u4f4d\u56fe\u56fe\u7247\u7b49\u9759\u6001\u6587\u4ef6\u3002 let file = FileMiddleware(publicDirectory: app.directory.publicDirectory) app.middleware.use(file) \u4e00\u65e6\u6ce8\u518c\u4e86 FileMiddleware \uff0c\u6bd4\u5982 Public/images/logo.png \u7684\u6587\u4ef6\u53ef\u4ee5\u5728 Leaf \u6a21\u677f\u901a\u8fc7 <img src=\"/images/logo.png\"/> \u65b9\u5f0f\u5f15\u7528\u3002 CORS Middleware \u00b6 \u8de8\u57df\u8d44\u6e90\u5171\u4eab\uff08\u82f1\u8a9e\uff1aCross-origin resource sharing\uff0c\u7f29\u5199\uff1a CORS \uff09\uff0c\u7528\u4e8e\u8ba9\u7f51\u9875\u7684\u53d7\u9650\u8d44\u6e90\u80fd\u591f\u88ab\u5176\u4ed6\u57df\u540d\u7684\u9875\u9762\u8bbf\u95ee\u7684\u4e00\u79cd\u673a\u5236\u3002 \u901a\u8fc7\u8be5\u673a\u5236\uff0c\u9875\u9762\u80fd\u591f\u81ea\u7531\u5730\u4f7f\u7528\u4e0d\u540c\u6e90\uff08\u82f1\u8a9e\uff1across-origin\uff09\u7684\u56fe\u7247\u3001\u6837\u5f0f\u3001\u811a\u672c\u3001iframes\u4ee5\u53ca\u89c6\u9891\u3002Vapor\u5185\u7f6e\u7684 REST API \u5c06\u9700\u8981CORS\u7b56\u7565\uff0c\u4ee5\u4fbf\u5c06\u8bf7\u6c42\u5b89\u5168\u5730\u8fd4\u56de\u5230\u73b0\u4ee3 Web \u6d4f\u89c8\u5668\u3002 \u914d\u7f6e\u793a\u4f8b\u5982\u4e0b\u6240\u793a\uff1a: let corsConfiguration = CORSMiddleware . Configuration ( allowedOrigin : . all , allowedMethods : [. GET , . POST , . PUT , . OPTIONS , . DELETE , . PATCH ], allowedHeaders : [. accept , . authorization , . contentType , . origin , . xRequestedWith , . userAgent , . accessControlAllowOrigin ] ) let cors = CORSMiddleware ( configuration : corsConfiguration ) let error = ErrorMiddleware . default ( environment : app . environment ) // Clear any existing middleware. app . middleware = . init () app . middleware . use ( cors ) app . middleware . use ( error ) \u7531\u4e8e\u629b\u51fa\u7684\u9519\u8bef\u4f1a\u7acb\u5373\u8fd4\u56de\u7ed9\u5ba2\u6237\u7aef\uff0c\u56e0\u6b64\u5fc5\u987b\u5728 ErrorMiddleware \u4e4b\u524d\u6ce8\u518c CORSMiddleware \u3002\u5426\u5219\uff0c\u5c06\u8fd4\u56de\u4e0d\u5e26 CORS \u6807\u5934\u7684 HTTP \u9519\u8bef\u54cd\u5e94\u4e14\u6d4f\u89c8\u5668\u65e0\u6cd5\u8bfb\u53d6\u8be5\u9519\u8bef\u54cd\u5e94\u3002","title":"Middleware"},{"location":"middleware/#middleware","text":"Middleware \u662f client \u548c\u8def\u7531\u5904\u7406\u7a0b\u5e8f\u95f4\u7684\u4e00\u4e2a\u903b\u8f91\u94fe\u3002\u5b83\u5141\u8bb8\u60a8\u5728\u4f20\u5165\u8bf7\u6c42\u5230\u8fbe\u8def\u7531\u5904\u7406\u7a0b\u5e8f\u4e4b\u524d\u5bf9\u4f20\u5165\u8bf7\u6c42\u6267\u884c\u64cd\u4f5c\u5e76\u4e14\u5728\u8f93\u51fa\u54cd\u5e94\u5230\u8fbeclient\u4e4b\u524d\u5bf9\u4f20\u51fa\u54cd\u5e94\u6267\u884c\u64cd\u4f5c\u3002","title":"Middleware"},{"location":"middleware/#configuration","text":"Middleware \u53ef\u4ee5\u5728 configure(_:) \u4f7f\u7528 app.middleware \u5168\u5c40\u6ce8\u518c(\u6bcf\u4e00\u4e2a\u8def\u7531) app . middleware . use ( MyMiddleware ()) \u4f60\u4e5f\u53ef\u4ee5\u901a\u8fc7\u8def\u7531\u7ec4\u7684\u65b9\u5f0f\u7ed9\u4e2a\u522b\u8def\u7531\u6dfb\u52a0 middleware let group = app . grouped ( MyMiddleware ()) group . get ( \"foo\" ) { req in // This request has passed through MyMiddleware. }","title":"Configuration"},{"location":"middleware/#order","text":"Middleware \u7684\u6dfb\u52a0\u987a\u5e8f\u975e\u5e38\u91cd\u8981\u3002\u8fdb\u5165\u60a8\u5e94\u7528\u7a0b\u5e8f\u7684\u8bf7\u6c42\u5c06\u6309\u7167 middleware \u6dfb\u52a0\u7684\u987a\u5e8f\u4f9d\u6b21\u6267\u884c\u3002\u8fd4\u56de\u7ed9 client \u7684\u54cd\u5e94\u5c06\u4ee5\u4e2d\u95f4\u4ef6\u6dfb\u52a0\u987a\u5e8f\u7684\u9006\u5e8f\u65b9\u5f0f\u4f9d\u6b21\u6267\u884c\u3002Route-specific middleware \u603b\u662f\u5728 application middleware \u4e4b\u540e\u6267\u884c\u3002\u6bd4\u5982\u4e0b\u9762\u7684 example: app . middleware . use ( MiddlewareA ()) app . middleware . use ( MiddlewareB ()) app . group ( MiddlewareC ()) { $0 . get ( \"hello\" ) { req in \"Hello, middleware.\" } } GET /hello \u8fd9\u4e2a\u8bf7\u6c42\u5c06\u6309\u7167\u4ee5\u4e0b\u987a\u5e8f\u8bbf\u95ee\u4e2d\u95f4\u4ef6\uff1a Request \u2192 A \u2192 B \u2192 C \u2192 Handler \u2192 C \u2192 B \u2192 A \u2192 Response","title":"Order"},{"location":"middleware/#file-middleware","text":"FileMiddleware \u5141\u8bb8\u4ece\u9879\u76ee\u7684 Public \u6587\u4ef6\u5939\u5411 client \u63d0\u4f9b\u8d44\u6e90\u3002\u60a8\u53ef\u80fd\u5728\u8fd9\u91cc\u5b58\u653e css \u6216\u8005\u4f4d\u56fe\u56fe\u7247\u7b49\u9759\u6001\u6587\u4ef6\u3002 let file = FileMiddleware(publicDirectory: app.directory.publicDirectory) app.middleware.use(file) \u4e00\u65e6\u6ce8\u518c\u4e86 FileMiddleware \uff0c\u6bd4\u5982 Public/images/logo.png \u7684\u6587\u4ef6\u53ef\u4ee5\u5728 Leaf \u6a21\u677f\u901a\u8fc7 <img src=\"/images/logo.png\"/> \u65b9\u5f0f\u5f15\u7528\u3002","title":"File Middleware"},{"location":"middleware/#cors-middleware","text":"\u8de8\u57df\u8d44\u6e90\u5171\u4eab\uff08\u82f1\u8a9e\uff1aCross-origin resource sharing\uff0c\u7f29\u5199\uff1a CORS \uff09\uff0c\u7528\u4e8e\u8ba9\u7f51\u9875\u7684\u53d7\u9650\u8d44\u6e90\u80fd\u591f\u88ab\u5176\u4ed6\u57df\u540d\u7684\u9875\u9762\u8bbf\u95ee\u7684\u4e00\u79cd\u673a\u5236\u3002 \u901a\u8fc7\u8be5\u673a\u5236\uff0c\u9875\u9762\u80fd\u591f\u81ea\u7531\u5730\u4f7f\u7528\u4e0d\u540c\u6e90\uff08\u82f1\u8a9e\uff1across-origin\uff09\u7684\u56fe\u7247\u3001\u6837\u5f0f\u3001\u811a\u672c\u3001iframes\u4ee5\u53ca\u89c6\u9891\u3002Vapor\u5185\u7f6e\u7684 REST API \u5c06\u9700\u8981CORS\u7b56\u7565\uff0c\u4ee5\u4fbf\u5c06\u8bf7\u6c42\u5b89\u5168\u5730\u8fd4\u56de\u5230\u73b0\u4ee3 Web \u6d4f\u89c8\u5668\u3002 \u914d\u7f6e\u793a\u4f8b\u5982\u4e0b\u6240\u793a\uff1a: let corsConfiguration = CORSMiddleware . Configuration ( allowedOrigin : . all , allowedMethods : [. GET , . POST , . PUT , . OPTIONS , . DELETE , . PATCH ], allowedHeaders : [. accept , . authorization , . contentType , . origin , . xRequestedWith , . userAgent , . accessControlAllowOrigin ] ) let cors = CORSMiddleware ( configuration : corsConfiguration ) let error = ErrorMiddleware . default ( environment : app . environment ) // Clear any existing middleware. app . middleware = . init () app . middleware . use ( cors ) app . middleware . use ( error ) \u7531\u4e8e\u629b\u51fa\u7684\u9519\u8bef\u4f1a\u7acb\u5373\u8fd4\u56de\u7ed9\u5ba2\u6237\u7aef\uff0c\u56e0\u6b64\u5fc5\u987b\u5728 ErrorMiddleware \u4e4b\u524d\u6ce8\u518c CORSMiddleware \u3002\u5426\u5219\uff0c\u5c06\u8fd4\u56de\u4e0d\u5e26 CORS \u6807\u5934\u7684 HTTP \u9519\u8bef\u54cd\u5e94\u4e14\u6d4f\u89c8\u5668\u65e0\u6cd5\u8bfb\u53d6\u8be5\u9519\u8bef\u54cd\u5e94\u3002","title":"CORS Middleware"},{"location":"passwords/","text":"Passwords \u00b6 Vapor includes a password hashing API to help you store and verify passwords securely. This API is configurable based on environment and supports asynchronous hashing. Configuration \u00b6 To configure the Application's password hasher, use app.passwords . import Vapor app . passwords . use (...) Bcrypt \u00b6 To use Vapor's Bcrypt API for password hashing, specify .bcrypt . This is the default. app . passwords . use (. bcrypt ) Bcrypt will use a cost of 12 unless otherwise specified. You can configure this by passing the cost parameter. app . passwords . use (. bcrypt ( cost : 8 )) Plaintext \u00b6 Vapor includes an insecure password hasher that stores and verifies passwords as plaintext. This should not be used in production but can be useful for testing. switch app . environment { case . testing : app . passwords . use (. plaintext ) default : break } Hashing \u00b6 To hash passwords, use the password helper available on Request . let digest = try req . password . hash ( \"vapor\" ) Password digests can be verified against the plaintext password using the verify method. let bool = try req . password . verify ( \"vapor\" , created : digest ) The same API is available on Application for use during boot. let digest = try app . password . hash ( \"vapor\" ) Async \u00b6 Password hashing algorithms are designed to be slow and CPU intensive. Because of this, you may want to avoid blocking the event loop while hashing passwords. Vapor provides an asynchronous password hashing API that dispatches hashing to a background thread pool. To use the asynchronous API, use the async property on a password hasher. req . password . async . hash ( \"vapor\" ). map { digest in // Handle digest. } Verifying digests works similarly: req . password . async . verify ( \"vapor\" , created : digest ). map { bool in // Handle result. } Calculating hashes on background threads can free your application's event loops up to handle more incoming requests.","title":"Passwords"},{"location":"passwords/#passwords","text":"Vapor includes a password hashing API to help you store and verify passwords securely. This API is configurable based on environment and supports asynchronous hashing.","title":"Passwords"},{"location":"passwords/#configuration","text":"To configure the Application's password hasher, use app.passwords . import Vapor app . passwords . use (...)","title":"Configuration"},{"location":"passwords/#bcrypt","text":"To use Vapor's Bcrypt API for password hashing, specify .bcrypt . This is the default. app . passwords . use (. bcrypt ) Bcrypt will use a cost of 12 unless otherwise specified. You can configure this by passing the cost parameter. app . passwords . use (. bcrypt ( cost : 8 ))","title":"Bcrypt"},{"location":"passwords/#plaintext","text":"Vapor includes an insecure password hasher that stores and verifies passwords as plaintext. This should not be used in production but can be useful for testing. switch app . environment { case . testing : app . passwords . use (. plaintext ) default : break }","title":"Plaintext"},{"location":"passwords/#hashing","text":"To hash passwords, use the password helper available on Request . let digest = try req . password . hash ( \"vapor\" ) Password digests can be verified against the plaintext password using the verify method. let bool = try req . password . verify ( \"vapor\" , created : digest ) The same API is available on Application for use during boot. let digest = try app . password . hash ( \"vapor\" )","title":"Hashing"},{"location":"passwords/#async","text":"Password hashing algorithms are designed to be slow and CPU intensive. Because of this, you may want to avoid blocking the event loop while hashing passwords. Vapor provides an asynchronous password hashing API that dispatches hashing to a background thread pool. To use the asynchronous API, use the async property on a password hasher. req . password . async . hash ( \"vapor\" ). map { digest in // Handle digest. } Verifying digests works similarly: req . password . async . verify ( \"vapor\" , created : digest ). map { bool in // Handle result. } Calculating hashes on background threads can free your application's event loops up to handle more incoming requests.","title":"Async"},{"location":"queues/","text":"Queues \u00b6 Vapor Queues ( vapor/queues ) is a pure Swift queuing system that allows you to offload task responsibility to a side worker. Some of the tasks this package works well for: Sending emails outside of the main request thread Performing complex or long-running database operations Ensuring job integrity and resilience Speeding up response time by delaying non-critical processing Scheduling jobs to occur at a specific time This package is similar to Ruby Sidekiq . It provides the following features: Safe handling of SIGTERM and SIGINT signals sent by hosting providers to indicate a shutdown, restart, or new deploy. Different queue priorities. For example, you can specify a queue job to be run on the email queue and another job to be run on the data-processing queue. Implements the reliable queue process to help with unexpected failures. Includes a maxRetryCount feature that will repeat the job until it succeeds up until a specified count. Uses NIO to utilize all available cores and EventLoops for jobs. Allows users to schedule repeating tasks Queues currently has one officially supported driver which interfaces with the main protocol: QueuesRedisDriver Queues also has community-based drivers: - JobsPostgresqlDriver Tip You should not install the vapor/queues package directly unless you are building a new driver. Install one of the driver packages instead. Getting Started \u00b6 Let's take a look at how you can get started using Queues. Package \u00b6 The first step to using Queues is adding one of the drivers as a dependency to your project in your SwiftPM package manifest file. In this example, we'll use the Redis driver. // swift-tools-version:5.2 import PackageDescription let package = Package ( name : \"MyApp\" , dependencies : [ /// Any other dependencies ... . package ( url : \"https://github.com/vapor/queues-redis-driver.git\" , from : \"1.0.0\" ), ], targets : [ . target ( name : \"App\" , dependencies : [ . product ( name : \"QueuesRedisDriver\" , package : \"queues-redis-driver\" ) ]), . target ( name : \"Run\" , dependencies : [. target ( name : \"App\" )]), . testTarget ( name : \"AppTests\" , dependencies : [. target ( name : \"App\" )]), ] ) If you edit the manifest directly inside Xcode, it will automatically pick up the changes and fetch the new dependency when the file is saved. Otherwise, from Terminal, run swift package resolve to fetch the new dependency. Config \u00b6 The next step is to configure Queues in configure.swift . We'll use the Redis library as an example: try app . queues . use (. redis ( url : \"redis://127.0.0.1:6379\" )) Registering a Job \u00b6 After modeling a job you must add it to your configuration section like this: //Register jobs let emailJob = EmailJob () app . queues . add ( emailJob ) Running Workers as Processes \u00b6 To start a new queue worker, run vapor run queues . You can also specify a specific type of worker to run: vapor run queues --queue emails . Tip Workers should stay running in production. Consult your hosting provider to find out how to keep long-running processes alive. Heroku, for example, allows you to specify \"worker\" dynos like this in your Procfile: worker: Run run queues Running Workers in-process \u00b6 To run a worker in the same process as your application (as opposed to starting a whole separate server to handle it), call the convenience methods on Application : try app . queues . startInProcessJobs ( on : . default ) To run scheduled jobs in process, call the following method: try app . queues . startScheduledJobs () Warning If you don't start the queue worker either via command line or the in-process worker the jobs will not dispatch. The Job Protocol \u00b6 Jobs are defined by the Job protocol. Modeling a Job object: \u00b6 import Vapor import Foundation import Queues struct Email : Codable { let to : String let message : String } struct EmailJob : Job { typealias Payload = Email func dequeue ( _ context : QueueContext , _ payload : Email ) -> EventLoopFuture < Void > { // This is where you would send the email return context . eventLoop . future () } func error ( _ context : QueueContext , _ error : Error , _ payload : Email ) -> EventLoopFuture < Void > { // If you don't want to handle errors you can simply return a future. You can also omit this function entirely. return context . eventLoop . future () } } Tip Don't forget to follow the instructions in Getting Started to add this job to your configuration file. Dispatching Jobs \u00b6 To dispatch a queue job, you need access to an instance of Application or Request . You will most likely be dispatching jobs inside of a route handler: app . get ( \"email\" ) { req -> EventLoopFuture < String > in return req . queue . dispatch ( EmailJob . self , . init ( to : \"email@email.com\" , message : \"message\" ) ). map { \"done\" } } Setting maxRetryCount \u00b6 Jobs will automatically retry themselves upon error if you specify a maxRetryCount . For example: app . get ( \"email\" ) { req -> EventLoopFuture < String > in return req . queue . dispatch ( EmailJob . self , . init ( to : \"email@email.com\" , message : \"message\" ), maxRetryCount : 3 ). map { \"done\" } } Specifying a delay \u00b6 Jobs can also be set to only run after a certain Date has passed. To specify a delay, pass a Date into the delayUntil parameter in dispatch : app . get ( \"email\" ) { req -> EventLoopFuture < String > in let futureDate = Date ( timeIntervalSinceNow : 60 * 60 * 24 ) // One day return req . queue . dispatch ( EmailJob . self , . init ( to : \"email@email.com\" , message : \"message\" ), maxRetryCount : 3 , delayUntil : futureDate ). map { \"done\" } } If a job is dequeued before its delay parameter, the job will be re-queued by the driver. Specify a priority \u00b6 Jobs can be sorted into different queue types/priorities depending on your needs. For example, you may want to open an email queue and a background-processing queue to sort jobs. Start by extending JobsQueueName : extension JobsQueueName { static let emails = JobsQueueName ( string : \"emails\" ) } Then, specify the queue type when you retrieve the jobs object: app . get ( \"email\" ) { req -> EventLoopFuture < String > in let futureDate = Date ( timeIntervalSinceNow : 60 * 60 * 24 ) // One day return req . queues (. emails ) . dispatch ( EmailJob . self , . init ( to : \"email@email.com\" , message : \"message\" ), maxRetryCount : 3 , delayUntil : futureDate ). map { \"done\" } } If you do not specify a queue the job will be run on the default queue. Make sure to follow the instructions in Getting Started to start workers for each queue type. Scheduling Jobs \u00b6 The Queues package also allows you to schedule jobs to occur at certain points in time. Starting the scheduler worker \u00b6 The scheduler requires a separate worker process to be running, similar to the queue worker. You can start the worker by running this command: swift run Run queues --scheduled Tip Workers should stay running in production. Consult your hosting provider to find out how to keep long-running processes alive. Heroku, for example, allows you to specify \"worker\" dynos like this in your Procfile: worker: Run run queues --scheduled Creating a ScheduledJob \u00b6 To being, start by creating a new ScheduledJob : import Vapor import Jobs struct CleanupJob : ScheduledJob { // Add extra services here via dependency injection, if you need them. func run ( context : QueueContext ) -> EventLoopFuture < Void > { // Do some work here, perhaps queue up another job. return context . eventLoop . makeSucceededFuture (()) } } Then, in your configure code, register the scheduled job: app . queues . schedule ( CleanupJob ()) . yearly () . in (. may ) . on ( 23 ) . at (. noon ) The job in the example above will be run every year on May 23rd at 12:00 PM. Tip The Scheduler takes the timezone of your server. Available builder methods \u00b6 There are five main methods that can be called on a scheduler, each of which creates its respective builder object that contains more helper methods. You should continue building out a scheduler object until the compiler does not give you a warning about an unused result. See below for all available methods: Helper Function Available Modifiers Description yearly() in(_ month: Month) -> Monthly The month to run the job in. Returns a Monthly object for further building. monthly() on(_ day: Day) -> Daily The day to run the job in. Returns a Daily object for further building. weekly() on(_ weekday: Weekday) -> Daily The day of the week to run the job on. Returns a Daily object. daily() at(_ time: Time) The time to run the job on. Final method in the chain. at(_ hour: Hour24, _ minute: Minute) The hour and minute to run the job on. Final method in the chain. at(_ hour: Hour12, _ minute: Minute, _ period: HourPeriod) The hour, minute, and period to run the job on. Final method of the chain hourly() at(_ minute: Minute) The minute to run the job at. Final method of the chain. Available helpers \u00b6 Queues ships with some helpers enums to make scheduling easier: Helper Function Available Helper Enum yearly() .january , .february , .march , ... monthly() .first , .last , .exact(1) weekly() .sunday , .monday , .tuesday , ... daily() .midnight , .noon To use the helper enum, call in to the appropriate modifier on the helper function and pass the value. For example: // Every year in January . yearly (). in (. january ) // Every month on the first day . monthly (). on (. first ) // Every week on Sunday . weekly (). on (. sunday ) // Every day at midnight . daily (). at (. midnight )","title":"Queues"},{"location":"queues/#queues","text":"Vapor Queues ( vapor/queues ) is a pure Swift queuing system that allows you to offload task responsibility to a side worker. Some of the tasks this package works well for: Sending emails outside of the main request thread Performing complex or long-running database operations Ensuring job integrity and resilience Speeding up response time by delaying non-critical processing Scheduling jobs to occur at a specific time This package is similar to Ruby Sidekiq . It provides the following features: Safe handling of SIGTERM and SIGINT signals sent by hosting providers to indicate a shutdown, restart, or new deploy. Different queue priorities. For example, you can specify a queue job to be run on the email queue and another job to be run on the data-processing queue. Implements the reliable queue process to help with unexpected failures. Includes a maxRetryCount feature that will repeat the job until it succeeds up until a specified count. Uses NIO to utilize all available cores and EventLoops for jobs. Allows users to schedule repeating tasks Queues currently has one officially supported driver which interfaces with the main protocol: QueuesRedisDriver Queues also has community-based drivers: - JobsPostgresqlDriver Tip You should not install the vapor/queues package directly unless you are building a new driver. Install one of the driver packages instead.","title":"Queues"},{"location":"queues/#getting-started","text":"Let's take a look at how you can get started using Queues.","title":"Getting Started"},{"location":"queues/#package","text":"The first step to using Queues is adding one of the drivers as a dependency to your project in your SwiftPM package manifest file. In this example, we'll use the Redis driver. // swift-tools-version:5.2 import PackageDescription let package = Package ( name : \"MyApp\" , dependencies : [ /// Any other dependencies ... . package ( url : \"https://github.com/vapor/queues-redis-driver.git\" , from : \"1.0.0\" ), ], targets : [ . target ( name : \"App\" , dependencies : [ . product ( name : \"QueuesRedisDriver\" , package : \"queues-redis-driver\" ) ]), . target ( name : \"Run\" , dependencies : [. target ( name : \"App\" )]), . testTarget ( name : \"AppTests\" , dependencies : [. target ( name : \"App\" )]), ] ) If you edit the manifest directly inside Xcode, it will automatically pick up the changes and fetch the new dependency when the file is saved. Otherwise, from Terminal, run swift package resolve to fetch the new dependency.","title":"Package"},{"location":"queues/#config","text":"The next step is to configure Queues in configure.swift . We'll use the Redis library as an example: try app . queues . use (. redis ( url : \"redis://127.0.0.1:6379\" ))","title":"Config"},{"location":"queues/#registering-a-job","text":"After modeling a job you must add it to your configuration section like this: //Register jobs let emailJob = EmailJob () app . queues . add ( emailJob )","title":"Registering a Job"},{"location":"queues/#running-workers-as-processes","text":"To start a new queue worker, run vapor run queues . You can also specify a specific type of worker to run: vapor run queues --queue emails . Tip Workers should stay running in production. Consult your hosting provider to find out how to keep long-running processes alive. Heroku, for example, allows you to specify \"worker\" dynos like this in your Procfile: worker: Run run queues","title":"Running Workers as Processes"},{"location":"queues/#running-workers-in-process","text":"To run a worker in the same process as your application (as opposed to starting a whole separate server to handle it), call the convenience methods on Application : try app . queues . startInProcessJobs ( on : . default ) To run scheduled jobs in process, call the following method: try app . queues . startScheduledJobs () Warning If you don't start the queue worker either via command line or the in-process worker the jobs will not dispatch.","title":"Running Workers in-process"},{"location":"queues/#the-job-protocol","text":"Jobs are defined by the Job protocol.","title":"The Job Protocol"},{"location":"queues/#modeling-a-job-object","text":"import Vapor import Foundation import Queues struct Email : Codable { let to : String let message : String } struct EmailJob : Job { typealias Payload = Email func dequeue ( _ context : QueueContext , _ payload : Email ) -> EventLoopFuture < Void > { // This is where you would send the email return context . eventLoop . future () } func error ( _ context : QueueContext , _ error : Error , _ payload : Email ) -> EventLoopFuture < Void > { // If you don't want to handle errors you can simply return a future. You can also omit this function entirely. return context . eventLoop . future () } } Tip Don't forget to follow the instructions in Getting Started to add this job to your configuration file.","title":"Modeling a Job object:"},{"location":"queues/#dispatching-jobs","text":"To dispatch a queue job, you need access to an instance of Application or Request . You will most likely be dispatching jobs inside of a route handler: app . get ( \"email\" ) { req -> EventLoopFuture < String > in return req . queue . dispatch ( EmailJob . self , . init ( to : \"email@email.com\" , message : \"message\" ) ). map { \"done\" } }","title":"Dispatching Jobs"},{"location":"queues/#setting-maxretrycount","text":"Jobs will automatically retry themselves upon error if you specify a maxRetryCount . For example: app . get ( \"email\" ) { req -> EventLoopFuture < String > in return req . queue . dispatch ( EmailJob . self , . init ( to : \"email@email.com\" , message : \"message\" ), maxRetryCount : 3 ). map { \"done\" } }","title":"Setting maxRetryCount"},{"location":"queues/#specifying-a-delay","text":"Jobs can also be set to only run after a certain Date has passed. To specify a delay, pass a Date into the delayUntil parameter in dispatch : app . get ( \"email\" ) { req -> EventLoopFuture < String > in let futureDate = Date ( timeIntervalSinceNow : 60 * 60 * 24 ) // One day return req . queue . dispatch ( EmailJob . self , . init ( to : \"email@email.com\" , message : \"message\" ), maxRetryCount : 3 , delayUntil : futureDate ). map { \"done\" } } If a job is dequeued before its delay parameter, the job will be re-queued by the driver.","title":"Specifying a delay"},{"location":"queues/#specify-a-priority","text":"Jobs can be sorted into different queue types/priorities depending on your needs. For example, you may want to open an email queue and a background-processing queue to sort jobs. Start by extending JobsQueueName : extension JobsQueueName { static let emails = JobsQueueName ( string : \"emails\" ) } Then, specify the queue type when you retrieve the jobs object: app . get ( \"email\" ) { req -> EventLoopFuture < String > in let futureDate = Date ( timeIntervalSinceNow : 60 * 60 * 24 ) // One day return req . queues (. emails ) . dispatch ( EmailJob . self , . init ( to : \"email@email.com\" , message : \"message\" ), maxRetryCount : 3 , delayUntil : futureDate ). map { \"done\" } } If you do not specify a queue the job will be run on the default queue. Make sure to follow the instructions in Getting Started to start workers for each queue type.","title":"Specify a priority"},{"location":"queues/#scheduling-jobs","text":"The Queues package also allows you to schedule jobs to occur at certain points in time.","title":"Scheduling Jobs"},{"location":"queues/#starting-the-scheduler-worker","text":"The scheduler requires a separate worker process to be running, similar to the queue worker. You can start the worker by running this command: swift run Run queues --scheduled Tip Workers should stay running in production. Consult your hosting provider to find out how to keep long-running processes alive. Heroku, for example, allows you to specify \"worker\" dynos like this in your Procfile: worker: Run run queues --scheduled","title":"Starting the scheduler worker"},{"location":"queues/#creating-a-scheduledjob","text":"To being, start by creating a new ScheduledJob : import Vapor import Jobs struct CleanupJob : ScheduledJob { // Add extra services here via dependency injection, if you need them. func run ( context : QueueContext ) -> EventLoopFuture < Void > { // Do some work here, perhaps queue up another job. return context . eventLoop . makeSucceededFuture (()) } } Then, in your configure code, register the scheduled job: app . queues . schedule ( CleanupJob ()) . yearly () . in (. may ) . on ( 23 ) . at (. noon ) The job in the example above will be run every year on May 23rd at 12:00 PM. Tip The Scheduler takes the timezone of your server.","title":"Creating a ScheduledJob"},{"location":"queues/#available-builder-methods","text":"There are five main methods that can be called on a scheduler, each of which creates its respective builder object that contains more helper methods. You should continue building out a scheduler object until the compiler does not give you a warning about an unused result. See below for all available methods: Helper Function Available Modifiers Description yearly() in(_ month: Month) -> Monthly The month to run the job in. Returns a Monthly object for further building. monthly() on(_ day: Day) -> Daily The day to run the job in. Returns a Daily object for further building. weekly() on(_ weekday: Weekday) -> Daily The day of the week to run the job on. Returns a Daily object. daily() at(_ time: Time) The time to run the job on. Final method in the chain. at(_ hour: Hour24, _ minute: Minute) The hour and minute to run the job on. Final method in the chain. at(_ hour: Hour12, _ minute: Minute, _ period: HourPeriod) The hour, minute, and period to run the job on. Final method of the chain hourly() at(_ minute: Minute) The minute to run the job at. Final method of the chain.","title":"Available builder methods"},{"location":"queues/#available-helpers","text":"Queues ships with some helpers enums to make scheduling easier: Helper Function Available Helper Enum yearly() .january , .february , .march , ... monthly() .first , .last , .exact(1) weekly() .sunday , .monday , .tuesday , ... daily() .midnight , .noon To use the helper enum, call in to the appropriate modifier on the helper function and pass the value. For example: // Every year in January . yearly (). in (. january ) // Every month on the first day . monthly (). on (. first ) // Every week on Sunday . weekly (). on (. sunday ) // Every day at midnight . daily (). at (. midnight )","title":"Available helpers"},{"location":"routing/","text":"Routing \u00b6 \u8def\u7531\u662f\u4e3a\u4f20\u5165\u8bf7\u6c42\u627e\u5230\u5176\u5bf9\u5e94 handler \u7684\u5904\u7406\u8fc7\u7a0b\u3002 RoutingKit \u662f Vapor \u8def\u7531\u7684\u6838\u5fc3\u3002 Overview \u00b6 \u8981\u4e86\u89e3\u8def\u7531\u5728 Vapor \u4e2d\u7684\u5de5\u4f5c\u65b9\u5f0f\uff0c\u60a8\u9996\u5148\u5e94\u8be5\u4e86\u89e3\u6709\u5173 HTTP \u8bf7\u6c42\u7684\u4e00\u4e9b\u57fa\u7840\u77e5\u8bc6\u3002\u770b\u4e00\u4e0b\u4ee5\u4e0b\u8bf7\u6c42\u793a\u4f8b\u3002 GET /hello/vapor HTTP / 1.1 host : vapor.codes content-length : 0 \u8fd9\u662f\u5bf9URL /hello/vapor \u53d1\u9001\u4e00\u4e2a\u7b80\u5355\u7684 HTTP \u7684 GET \u8bf7\u6c42\u3002\u5982\u679c\u60a8\u5728\u8fdb\u5165\u4e0b\u9762 URL\uff0c\u5219\u6d4f\u89c8\u5668\u4f1a\u53d1\u51fa\u8fd9\u79cd HTTP \u8bf7\u6c42\u3002 http://vapor.codes/hello/vapor HTTP Method \u00b6 \u8bf7\u6c42\u7684\u7b2c\u4e00\u90e8\u5206\u662f HTTP \u65b9\u6cd5\u3002\"GET\"\u662f\u6700\u5e38\u89c1\u7684 HTTP \u65b9\u6cd5\uff0c\u4f46\u6709\u5176\u4ed6\u51e0\u4e2a\u4e5f\u7ecf\u5e38\u4f7f\u7528\u3002\u8fd9\u4e9b HTTP \u65b9\u6cd5\u901a\u5e38\u4e0e CRUD \u8bed\u4e49\u76f8\u5173\u8054\u3002 method crud GET Read POST Create PUT Replace PATCH Update DELETE Delete Request Path \u00b6 \u5728 HTTP \u8bf7\u6c42\u65b9\u6cd5\u4e4b\u540e\u662f\u8bf7\u6c42\u7684 URI\u3002\u5b83\u7531\u4ee5 / \u5f00\u5934\u7684\u8def\u5f84\u548c\u5728 ? \u4e4b\u540e\u7684\u53ef\u9009\u67e5\u8be2\u5b57\u7b26\u4e32\u7ec4\u6210\u3002HTTP \u7684\u65b9\u6cd5\u548c\u8def\u5f84\u7528\u4e8e Vapor \u7684\u8def\u7531\u8bf7\u6c42\u3002 URI \u4e4b\u540e\u662f HTTP version\uff0c\u968f\u540e\u662f\u96f6\u4e2a\u6216\u591a\u4e2aheader\uff0c\u6700\u540e\u662fbody\u3002\u7531\u4e8e\u8fd9\u662f\u4e00\u4e2a GET \u8bf7\u6c42\uff0c\u56e0\u6b64\u6ca1\u6709 body\u3002 Router Methods \u00b6 \u8ba9\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u5728Vapor\u4e2d\u5904\u7406\u6b64\u8bf7\u6c42\u3002 app . get ( \"hello\" , \"vapor\" ) { req in return \"Hello, vapor!\" } \u6240\u6709\u5e38\u89c1\u7684 HTTP \u65b9\u6cd5\u90fd\u53ef\u4ee5\u4f5c\u4e3a\u65b9\u6cd5\u5728 Application \u4e0a\u4f7f\u7528\u3002\u5b83\u4eec\u63a5\u53d7\u4e00\u4e2a\u6216\u591a\u4e2a\u5b57\u7b26\u4e32\u53c2\u6570\uff0c\u8fd9\u4e9b\u53c2\u6570\u8868\u793a\u4ee5 / \u5206\u9694\u7684\u8bf7\u6c42\u8def\u5f84\u3002 \u8bf7\u6ce8\u610f\uff0c\u60a8\u4e5f\u53ef\u4ee5\u4f7f\u7528 on \u65b9\u6cd5\u6765\u5b9e\u73b0\u3002 app . on (. GET , \"hello\" , \"vapor\" ) { ... } \u6ce8\u518c\u6b64\u8def\u7531\u540e, \u4e0a\u9762\u7684 HTTP \u8bf7\u6c42\u5c31\u4f1a\u6536\u5230\u4e0b\u9762\u7684 HTTP \u54cd\u5e94\u3002 HTTP / 1.1 200 OK content-length : 13 content-type : text/plain; charset=utf-8 Hello, vapor! Route Parameters \u00b6 \u73b0\u5728\u6211\u4eec\u7ed9\u57fa\u4e8e HTTP method \u548c path \u7684\u8bf7\u6c42\u5b9e\u73b0\u4e86\u8def\u7531\uff0c\u6211\u4eec\u53ef\u4ee5\u5c1d\u8bd5\u4f7f\u8def\u5f84\u6210\u4e3a\u52a8\u6001\u7684\u3002\u4e0a\u9762 vapor \u5728 path \u548c\u54cd\u5e94\u4e2d\u90fd\u662f\u4e2a\u786c\u7f16\u7801\u3002\u6211\u4eec\u8ba9\u5b83\u53d8\u6210\u52a8\u6001\uff0c\u8fd9\u6837\u4f60\u5c31\u53ef\u4ee5\u8bbf\u95ee /hello/<any name> \uff0c\u5e76\u83b7\u5f97\u54cd\u5e94\u3002 app . get ( \"hello\" , \":name\" ) { req -> String in let name = req . parameters . get ( \"name\" ) ! return \"Hello, \\( name ) !\" } \u6211\u4eec\u901a\u8fc7\u4f7f\u7528\u524d\u7f00\u4e3a : \u7684\u8def\u5f84\u7ec4\u4ef6\uff0c\u5411\u8def\u7531\u6307\u660e\u8fd9\u662f\u52a8\u6001\u7ec4\u4ef6\u3002\u73b0\u5728\uff0c\u6b64\u5904\u63d0\u4f9b\u7684\u4efb\u4f55\u5b57\u7b26\u4e32\u90fd\u5c06\u4e0e\u6b64\u8def\u7531\u5339\u914d\u3002\u7136\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 req.parameters \u8bbf\u95ee\u5b57\u7b26\u4e32\u7684\u503c\u3002 If you run the example request again, you'll still get a response that says hello to vapor. However, you can now include any name after /hello/ and see it included in the response. Let's try /hello/swift . \u5982\u679c\u518d\u6b21\u8fd0\u884c\u793a\u4f8b\u8bf7\u6c42\uff0c\u60a8\u4ecd\u7136\u4f1a\u6536\u5230\u4e00\u6761 hello to vapor \u54cd\u5e94\u3002 \u7136\u800c\uff0c\u73b0\u5728\u53ef\u4ee5\u5728 /hello/ \u4e4b\u540e\u6dfb\u52a0\u4efb\u4f55\u540d\u79f0\uff0c\u5e76\u5728\u54cd\u5e94\u4e2d\u770b\u5230\u5b83\u3002\u6bd4\u5982 /hello/swift \u3002 GET /hello/swift HTTP / 1.1 content-length : 0 HTTP / 1.1 200 OK content-length : 13 content-type : text/plain; charset=utf-8 Hello, swift! \u73b0\u5728\u60a8\u5df2\u7ecf\u4e86\u89e3\u4e86\u57fa\u7840\u77e5\u8bc6\uff0c\u8bf7\u67e5\u770b\u540e\u7eed\u90e8\u5206\uff0c\u4ee5\u4e86\u89e3\u6709\u5173 parameters\uff0cgroups \u7684\u66f4\u591a\u4fe1\u606f\u3002 Routes \u00b6 \u8def\u7531\u4e3a\u7ed9\u5b9a\u7684HTTP\u65b9\u6cd5\u548cURI\u8def\u5f84\u6307\u5b9a\u8bf7\u6c42\u5904\u7406\u7a0b\u5e8f\u3002\u5b83\u8fd8\u53ef\u4ee5\u5b58\u50a8\u5176\u4ed6\u5143\u6570\u636e\u3002 Methods \u00b6 \u53ef\u4ee5\u4f7f\u7528\u5404\u79cd HTTP \u65b9\u6cd5\u5e2e\u52a9\u5668\u5c06\u8def\u7531\u76f4\u63a5\u6ce8\u518c\u5230\u60a8\u7684 Application \u3002 // responds to GET /foo/bar/baz app . get ( \"foo\" , \"bar\" , \"baz\" ) { req in ... } Route handlers support returning anything that is ResponseEncodable . This includes Content and any EventLoopFuture 's where the future value is ResponseEncodable . You can specify the return type of a route using -> T before in . This can be useful in situations where the compiler cannot determine the return type. app . get ( \"foo\" ) { req -> String in return \"bar\" } These are the supported route helper methods: get post patch put delete In addition to the HTTP method helpers, there is an on function that accepts HTTP method as an input parameter. // responds to OPTIONS /foo/bar/baz app . on (. OPTIONS , \"foo\" , \"bar\" , \"baz\" ) { req in ... } Path Component \u00b6 Each route registration method accepts a variadic list of PathComponent . This type is expressible by string literal and has four cases: Constant ( foo ) Parameter ( :foo ) Anything ( : ) Catchall ( * ) Constant \u00b6 This is a static route component. Only requests with an exactly matching string at this position will be permitted. // responds to GET /foo/bar/baz app . get ( \"foo\" , \"bar\" , \"baz\" ) { req in ... } Parameter \u00b6 This is a dynamic route component. Any string at this position will be allowed. A parameter path component is specified with a : prefix. The string following the : will be used as the parameter's name. You can use the name to later fetch the parameters value from the request. // responds to GET /foo/bar/baz // responds to GET /foo/qux/baz // ... app . get ( \"foo\" , \":bar\" , \"baz\" ) { req in ... } Anything \u00b6 This is very similar to parameter except the value is discarded. This path component is specified as just : . // responds to GET /foo/bar/baz // responds to GET /foo/qux/baz // ... app . get ( \"foo\" , \":\" , \"baz\" ) { req in ... } Catchall \u00b6 This is a dynamic route component that matches one or more components. It is specified using just * . Any string at this position or later positions will be allowed in the request. // responds to GET /foo/bar // responds to GET /foo/bar/baz // ... app . get ( \"foo\" , \"*\" ) { req in ... } Parameters \u00b6 When using a parameter path component (prefixed with : ), the value of the URI at that position will be stored in req.parameters . You can use the name of the path component to access the value. // responds to GET /hello/foo // responds to GET /hello/bar // ... app . get ( \"hello\" , \":name\" ) { req -> String in let name = req . parameters . get ( \"name\" ) ! return \"Hello, \\( name ) !\" } Tip We can be sure that req.parameters.get will never return nil here since our route path includes :name . However, if you are accessing route parameters in middleware or in code triggered by multiple routes, you will want to handle the possibility of nil . req.parameters also supports casting the parameter to LosslessStringConvertible types automatically. // responds to GET /hello/42 // responds to GET /hello/1337 // ... app . get ( \"number\" , \":x\" ) { req -> String in guard let int = req . parameters . get ( \"x\" , as : Int . self ) else { throw Abort (. badRequest ) } return \" \\( int ) is a great number\" } Body Streaming \u00b6 \u4f7f\u7528 on \u65b9\u6cd5\u6ce8\u518c\u8def\u7531\u65f6\uff0c\u60a8\u53ef\u4ee5\u6307\u5b9a\u5982\u4f55\u5904\u7406\u8bf7\u6c42\u4e3b\u4f53\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u8bf7\u6c42\u4e3b\u4f53\u5728\u8c03\u7528\u5904\u7406\u7a0b\u5e8f\u4e4b\u524d\u88ab\u6536\u96c6\u5230\u5185\u5b58\u4e2d\u3002\u8fd9\u662f\u6709\u7528\u7684\uff0c\u56e0\u4e3a\u5b83\u5141\u8bb8\u8bf7\u6c42\u5185\u5bb9\u89e3\u7801\u662f\u540c\u6b65\u7684\u3002\u4f46\u662f\uff0c\u5bf9\u4e8e\u6587\u4ef6\u4e0a\u4f20\u7b49\u5927\u578b\u8bf7\u6c42\uff0c\u8fd9\u53ef\u80fd\u4f1a\u5360\u7528\u60a8\u7684\u7cfb\u7edf\u5185\u5b58\u3002 \u8981\u66f4\u6539\u8bf7\u6c42\u6b63\u6587\u7684\u5904\u7406\u65b9\u5f0f\uff0c\u8bf7\u5728\u6ce8\u518c\u8def\u7531\u65f6\u4f7f\u7528 body \u53c2\u6570\u3002\u6709\u4e24\u79cd\u65b9\u6cd5\uff1a collect : \u6536\u96c6\u8bf7\u6c42\u4e3b\u9898\u5230\u5185\u5b58 stream : \u8bf7\u6c42\u4e3b\u9898\u6d41\u5316 app . on (. POST , \"file-upload\" , body : . stream ) { req in ... } \u5f53\u8bf7\u6c42\u4e3b\u4f53\u88ab\u6d41\u5f0f\u4f20\u8f93\u65f6\uff0c req.body.data \u5c06\u53d8\u4e3a nil \u3002\u60a8\u5fc5\u987b\u4f7f\u7528 req.body.drain \u6765\u5904\u7406\u6bcf\u4e2a\u53d1\u9001\u5230\u8def\u7531\u7684\u5757\u3002 Viewing Routes \u00b6 \u60a8\u53ef\u4ee5\u901a\u8fc7\u63d0\u4f9b Routes \u670d\u52a1\u6216\u4f7f\u7528 app.routes \u6765\u8bbf\u95ee\u5e94\u7528\u7a0b\u5e8f\u7684\u5168\u90e8\u8def\u7531\u3002 print ( app . routes . all ) // [Route] Vapor \u8fd8\u9644\u5e26\u4e86\u4e00\u4e2a routes \u547d\u4ee4\uff0c\u8be5\u547d\u4ee4\u4ee5 ASCII \u683c\u5f0f\u7684\u8868\u683c\u6253\u5370\u6240\u6709\u53ef\u7528\u7684\u8def\u7531\u3002 $ swift run Run routes +--------+----------------+ | GET | / | +--------+----------------+ | GET | /hello/ | +--------+----------------+ | GET | /todos | +--------+----------------+ | POST | /todos | +--------+----------------+ | DELETE | /todos/:todoID | +--------+----------------+ Metadata \u00b6 \u6240\u6709\u8def\u7531\u6ce8\u518c\u65b9\u6cd5\u90fd\u4f1a\u8fd4\u56de\u521b\u5efa\u7684 Route \u3002\u8fd9\u4f7f\u60a8\u53ef\u4ee5\u5c06\u5143\u6570\u636e\u6dfb\u52a0\u5230\u8def\u7531\u7684 userInfo \u5b57\u5178\u4e2d\u3002\u6709\u4e00\u4e9b\u9ed8\u8ba4\u65b9\u6cd5\u53ef\u7528\uff0c\u4f8b\u5982\u6dfb\u52a0 description\u3002 app . get ( \"hello\" , \":name\" ) { req in ... }. description ( \"says hello\" ) Route Groups \u00b6 \u901a\u8fc7\u5bf9\u8def\u7531\u8fdb\u884c\u5206\u7ec4\uff0c\u6211\u4eec\u53ef\u4ee5\u521b\u5efa\u5e26\u6709\u8def\u5f84\u524d\u7f00\u6216\u7279\u5b9a\u4e2d\u95f4\u4ef6\u7684\u4e00\u7ec4\u8def\u7531\u3002\u652f\u6301\u57fa\u4e8e\u6784\u5efa\u5668\u548c\u95ed\u5305\u7684\u8bed\u6cd5\u3002 \u6240\u6709\u5206\u7ec4\u65b9\u6cd5\u90fd\u8fd4\u56de\u4e00\u4e2a RouteBuilder \uff0c\u8fd9\u610f\u5473\u7740\u60a8\u53ef\u4ee5\u5c06\u7ec4\u4e0e\u5176\u4ed6\u8def\u7531\u7684\u6784\u5efa\u65b9\u6cd5\u65e0\u9650\u5730\u6df7\u5408\uff0c\u5339\u914d\u548c\u5d4c\u5957\u3002 Path Prefix \u00b6 \u8def\u5f84\u524d\u7f00\u8def\u7531\u7ec4\u5141\u8bb8\u60a8\u5728\u4e00\u4e2a\u8def\u7531\u7ec4\u4e4b\u524d\u6dfb\u52a0\u4e00\u4e2a\u6216\u591a\u4e2a\u8def\u5f84\u7ec4\u4ef6\u3002 let users = app . grouped ( \"users\" ) // GET /users users . get { req in ... } // POST /users users . post { req in ... } // GET /users/:id users . get ( \":id\" ) { req in let id = req . parameters . get ( \"id\" ) ! ... } \u53e6\u4e00\u79cd\u57fa\u4e8e\u95ed\u5305\u7684\u8bed\u6cd5\u3002 app . group ( \"users\" ) { users in // GET /users users . get { req in ... } // POST /users users . post { req in ... } // GET /users/:id users . get ( \":id\" ) { req in let id = req . parameters . get ( \"id\" ) ! ... } } \u5d4c\u5957\u8def\u5f84\u524d\u7f00\u8def\u7531\u7ec4\u4f7f\u60a8\u53ef\u4ee5\u7b80\u6d01\u5730\u5b9a\u4e49 CRUD \u7684 API\u3002 app . group ( \"users\" ) { users in // GET /users users . get { ... } // POST /users users . post { ... } users . group ( \":id\" ) { user in // GET /users/:id user . get { ... } // PATCH /users/:id user . patch { ... } // PUT /users/:id user . put { ... } } } Middleware \u00b6 \u9664\u4e86\u53ef\u4ee5\u6dfb\u52a0\u8def\u7531\u524d\u7f00\uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u7ed9\u8def\u7531\u7ec4\u6dfb\u52a0 middleware\u3002 app . get ( \"fast-thing\" ) { req in ... } app . group ( RateLimitMiddleware ( requestsPerMinute : 5 )) { rateLimited in rateLimited . get ( \"slow-thing\" ) { req in ... } } \u4e3a\u67d0\u4e9b\u8def\u7531\u5b50\u96c6\u6dfb\u52a0 authentication middleware \u8fdb\u884c\u8ba4\u8bc1\u4fdd\u62a4\u975e\u5e38\u6709\u7528\u3002 app . post ( \"login\" ) { ... } let auth = app . grouped ( AuthMiddleware ()) auth . get ( \"dashboard\" ) { ... } auth . get ( \"logout\" ) { ... }","title":"Routing"},{"location":"routing/#routing","text":"\u8def\u7531\u662f\u4e3a\u4f20\u5165\u8bf7\u6c42\u627e\u5230\u5176\u5bf9\u5e94 handler \u7684\u5904\u7406\u8fc7\u7a0b\u3002 RoutingKit \u662f Vapor \u8def\u7531\u7684\u6838\u5fc3\u3002","title":"Routing"},{"location":"routing/#overview","text":"\u8981\u4e86\u89e3\u8def\u7531\u5728 Vapor \u4e2d\u7684\u5de5\u4f5c\u65b9\u5f0f\uff0c\u60a8\u9996\u5148\u5e94\u8be5\u4e86\u89e3\u6709\u5173 HTTP \u8bf7\u6c42\u7684\u4e00\u4e9b\u57fa\u7840\u77e5\u8bc6\u3002\u770b\u4e00\u4e0b\u4ee5\u4e0b\u8bf7\u6c42\u793a\u4f8b\u3002 GET /hello/vapor HTTP / 1.1 host : vapor.codes content-length : 0 \u8fd9\u662f\u5bf9URL /hello/vapor \u53d1\u9001\u4e00\u4e2a\u7b80\u5355\u7684 HTTP \u7684 GET \u8bf7\u6c42\u3002\u5982\u679c\u60a8\u5728\u8fdb\u5165\u4e0b\u9762 URL\uff0c\u5219\u6d4f\u89c8\u5668\u4f1a\u53d1\u51fa\u8fd9\u79cd HTTP \u8bf7\u6c42\u3002 http://vapor.codes/hello/vapor","title":"Overview"},{"location":"routing/#http-method","text":"\u8bf7\u6c42\u7684\u7b2c\u4e00\u90e8\u5206\u662f HTTP \u65b9\u6cd5\u3002\"GET\"\u662f\u6700\u5e38\u89c1\u7684 HTTP \u65b9\u6cd5\uff0c\u4f46\u6709\u5176\u4ed6\u51e0\u4e2a\u4e5f\u7ecf\u5e38\u4f7f\u7528\u3002\u8fd9\u4e9b HTTP \u65b9\u6cd5\u901a\u5e38\u4e0e CRUD \u8bed\u4e49\u76f8\u5173\u8054\u3002 method crud GET Read POST Create PUT Replace PATCH Update DELETE Delete","title":"HTTP Method"},{"location":"routing/#request-path","text":"\u5728 HTTP \u8bf7\u6c42\u65b9\u6cd5\u4e4b\u540e\u662f\u8bf7\u6c42\u7684 URI\u3002\u5b83\u7531\u4ee5 / \u5f00\u5934\u7684\u8def\u5f84\u548c\u5728 ? \u4e4b\u540e\u7684\u53ef\u9009\u67e5\u8be2\u5b57\u7b26\u4e32\u7ec4\u6210\u3002HTTP \u7684\u65b9\u6cd5\u548c\u8def\u5f84\u7528\u4e8e Vapor \u7684\u8def\u7531\u8bf7\u6c42\u3002 URI \u4e4b\u540e\u662f HTTP version\uff0c\u968f\u540e\u662f\u96f6\u4e2a\u6216\u591a\u4e2aheader\uff0c\u6700\u540e\u662fbody\u3002\u7531\u4e8e\u8fd9\u662f\u4e00\u4e2a GET \u8bf7\u6c42\uff0c\u56e0\u6b64\u6ca1\u6709 body\u3002","title":"Request Path"},{"location":"routing/#router-methods","text":"\u8ba9\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u5728Vapor\u4e2d\u5904\u7406\u6b64\u8bf7\u6c42\u3002 app . get ( \"hello\" , \"vapor\" ) { req in return \"Hello, vapor!\" } \u6240\u6709\u5e38\u89c1\u7684 HTTP \u65b9\u6cd5\u90fd\u53ef\u4ee5\u4f5c\u4e3a\u65b9\u6cd5\u5728 Application \u4e0a\u4f7f\u7528\u3002\u5b83\u4eec\u63a5\u53d7\u4e00\u4e2a\u6216\u591a\u4e2a\u5b57\u7b26\u4e32\u53c2\u6570\uff0c\u8fd9\u4e9b\u53c2\u6570\u8868\u793a\u4ee5 / \u5206\u9694\u7684\u8bf7\u6c42\u8def\u5f84\u3002 \u8bf7\u6ce8\u610f\uff0c\u60a8\u4e5f\u53ef\u4ee5\u4f7f\u7528 on \u65b9\u6cd5\u6765\u5b9e\u73b0\u3002 app . on (. GET , \"hello\" , \"vapor\" ) { ... } \u6ce8\u518c\u6b64\u8def\u7531\u540e, \u4e0a\u9762\u7684 HTTP \u8bf7\u6c42\u5c31\u4f1a\u6536\u5230\u4e0b\u9762\u7684 HTTP \u54cd\u5e94\u3002 HTTP / 1.1 200 OK content-length : 13 content-type : text/plain; charset=utf-8 Hello, vapor!","title":"Router Methods"},{"location":"routing/#route-parameters","text":"\u73b0\u5728\u6211\u4eec\u7ed9\u57fa\u4e8e HTTP method \u548c path \u7684\u8bf7\u6c42\u5b9e\u73b0\u4e86\u8def\u7531\uff0c\u6211\u4eec\u53ef\u4ee5\u5c1d\u8bd5\u4f7f\u8def\u5f84\u6210\u4e3a\u52a8\u6001\u7684\u3002\u4e0a\u9762 vapor \u5728 path \u548c\u54cd\u5e94\u4e2d\u90fd\u662f\u4e2a\u786c\u7f16\u7801\u3002\u6211\u4eec\u8ba9\u5b83\u53d8\u6210\u52a8\u6001\uff0c\u8fd9\u6837\u4f60\u5c31\u53ef\u4ee5\u8bbf\u95ee /hello/<any name> \uff0c\u5e76\u83b7\u5f97\u54cd\u5e94\u3002 app . get ( \"hello\" , \":name\" ) { req -> String in let name = req . parameters . get ( \"name\" ) ! return \"Hello, \\( name ) !\" } \u6211\u4eec\u901a\u8fc7\u4f7f\u7528\u524d\u7f00\u4e3a : \u7684\u8def\u5f84\u7ec4\u4ef6\uff0c\u5411\u8def\u7531\u6307\u660e\u8fd9\u662f\u52a8\u6001\u7ec4\u4ef6\u3002\u73b0\u5728\uff0c\u6b64\u5904\u63d0\u4f9b\u7684\u4efb\u4f55\u5b57\u7b26\u4e32\u90fd\u5c06\u4e0e\u6b64\u8def\u7531\u5339\u914d\u3002\u7136\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 req.parameters \u8bbf\u95ee\u5b57\u7b26\u4e32\u7684\u503c\u3002 If you run the example request again, you'll still get a response that says hello to vapor. However, you can now include any name after /hello/ and see it included in the response. Let's try /hello/swift . \u5982\u679c\u518d\u6b21\u8fd0\u884c\u793a\u4f8b\u8bf7\u6c42\uff0c\u60a8\u4ecd\u7136\u4f1a\u6536\u5230\u4e00\u6761 hello to vapor \u54cd\u5e94\u3002 \u7136\u800c\uff0c\u73b0\u5728\u53ef\u4ee5\u5728 /hello/ \u4e4b\u540e\u6dfb\u52a0\u4efb\u4f55\u540d\u79f0\uff0c\u5e76\u5728\u54cd\u5e94\u4e2d\u770b\u5230\u5b83\u3002\u6bd4\u5982 /hello/swift \u3002 GET /hello/swift HTTP / 1.1 content-length : 0 HTTP / 1.1 200 OK content-length : 13 content-type : text/plain; charset=utf-8 Hello, swift! \u73b0\u5728\u60a8\u5df2\u7ecf\u4e86\u89e3\u4e86\u57fa\u7840\u77e5\u8bc6\uff0c\u8bf7\u67e5\u770b\u540e\u7eed\u90e8\u5206\uff0c\u4ee5\u4e86\u89e3\u6709\u5173 parameters\uff0cgroups \u7684\u66f4\u591a\u4fe1\u606f\u3002","title":"Route Parameters"},{"location":"routing/#routes","text":"\u8def\u7531\u4e3a\u7ed9\u5b9a\u7684HTTP\u65b9\u6cd5\u548cURI\u8def\u5f84\u6307\u5b9a\u8bf7\u6c42\u5904\u7406\u7a0b\u5e8f\u3002\u5b83\u8fd8\u53ef\u4ee5\u5b58\u50a8\u5176\u4ed6\u5143\u6570\u636e\u3002","title":"Routes"},{"location":"routing/#methods","text":"\u53ef\u4ee5\u4f7f\u7528\u5404\u79cd HTTP \u65b9\u6cd5\u5e2e\u52a9\u5668\u5c06\u8def\u7531\u76f4\u63a5\u6ce8\u518c\u5230\u60a8\u7684 Application \u3002 // responds to GET /foo/bar/baz app . get ( \"foo\" , \"bar\" , \"baz\" ) { req in ... } Route handlers support returning anything that is ResponseEncodable . This includes Content and any EventLoopFuture 's where the future value is ResponseEncodable . You can specify the return type of a route using -> T before in . This can be useful in situations where the compiler cannot determine the return type. app . get ( \"foo\" ) { req -> String in return \"bar\" } These are the supported route helper methods: get post patch put delete In addition to the HTTP method helpers, there is an on function that accepts HTTP method as an input parameter. // responds to OPTIONS /foo/bar/baz app . on (. OPTIONS , \"foo\" , \"bar\" , \"baz\" ) { req in ... }","title":"Methods"},{"location":"routing/#path-component","text":"Each route registration method accepts a variadic list of PathComponent . This type is expressible by string literal and has four cases: Constant ( foo ) Parameter ( :foo ) Anything ( : ) Catchall ( * )","title":"Path Component"},{"location":"routing/#constant","text":"This is a static route component. Only requests with an exactly matching string at this position will be permitted. // responds to GET /foo/bar/baz app . get ( \"foo\" , \"bar\" , \"baz\" ) { req in ... }","title":"Constant"},{"location":"routing/#parameter","text":"This is a dynamic route component. Any string at this position will be allowed. A parameter path component is specified with a : prefix. The string following the : will be used as the parameter's name. You can use the name to later fetch the parameters value from the request. // responds to GET /foo/bar/baz // responds to GET /foo/qux/baz // ... app . get ( \"foo\" , \":bar\" , \"baz\" ) { req in ... }","title":"Parameter"},{"location":"routing/#anything","text":"This is very similar to parameter except the value is discarded. This path component is specified as just : . // responds to GET /foo/bar/baz // responds to GET /foo/qux/baz // ... app . get ( \"foo\" , \":\" , \"baz\" ) { req in ... }","title":"Anything"},{"location":"routing/#catchall","text":"This is a dynamic route component that matches one or more components. It is specified using just * . Any string at this position or later positions will be allowed in the request. // responds to GET /foo/bar // responds to GET /foo/bar/baz // ... app . get ( \"foo\" , \"*\" ) { req in ... }","title":"Catchall"},{"location":"routing/#parameters","text":"When using a parameter path component (prefixed with : ), the value of the URI at that position will be stored in req.parameters . You can use the name of the path component to access the value. // responds to GET /hello/foo // responds to GET /hello/bar // ... app . get ( \"hello\" , \":name\" ) { req -> String in let name = req . parameters . get ( \"name\" ) ! return \"Hello, \\( name ) !\" } Tip We can be sure that req.parameters.get will never return nil here since our route path includes :name . However, if you are accessing route parameters in middleware or in code triggered by multiple routes, you will want to handle the possibility of nil . req.parameters also supports casting the parameter to LosslessStringConvertible types automatically. // responds to GET /hello/42 // responds to GET /hello/1337 // ... app . get ( \"number\" , \":x\" ) { req -> String in guard let int = req . parameters . get ( \"x\" , as : Int . self ) else { throw Abort (. badRequest ) } return \" \\( int ) is a great number\" }","title":"Parameters"},{"location":"routing/#body-streaming","text":"\u4f7f\u7528 on \u65b9\u6cd5\u6ce8\u518c\u8def\u7531\u65f6\uff0c\u60a8\u53ef\u4ee5\u6307\u5b9a\u5982\u4f55\u5904\u7406\u8bf7\u6c42\u4e3b\u4f53\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u8bf7\u6c42\u4e3b\u4f53\u5728\u8c03\u7528\u5904\u7406\u7a0b\u5e8f\u4e4b\u524d\u88ab\u6536\u96c6\u5230\u5185\u5b58\u4e2d\u3002\u8fd9\u662f\u6709\u7528\u7684\uff0c\u56e0\u4e3a\u5b83\u5141\u8bb8\u8bf7\u6c42\u5185\u5bb9\u89e3\u7801\u662f\u540c\u6b65\u7684\u3002\u4f46\u662f\uff0c\u5bf9\u4e8e\u6587\u4ef6\u4e0a\u4f20\u7b49\u5927\u578b\u8bf7\u6c42\uff0c\u8fd9\u53ef\u80fd\u4f1a\u5360\u7528\u60a8\u7684\u7cfb\u7edf\u5185\u5b58\u3002 \u8981\u66f4\u6539\u8bf7\u6c42\u6b63\u6587\u7684\u5904\u7406\u65b9\u5f0f\uff0c\u8bf7\u5728\u6ce8\u518c\u8def\u7531\u65f6\u4f7f\u7528 body \u53c2\u6570\u3002\u6709\u4e24\u79cd\u65b9\u6cd5\uff1a collect : \u6536\u96c6\u8bf7\u6c42\u4e3b\u9898\u5230\u5185\u5b58 stream : \u8bf7\u6c42\u4e3b\u9898\u6d41\u5316 app . on (. POST , \"file-upload\" , body : . stream ) { req in ... } \u5f53\u8bf7\u6c42\u4e3b\u4f53\u88ab\u6d41\u5f0f\u4f20\u8f93\u65f6\uff0c req.body.data \u5c06\u53d8\u4e3a nil \u3002\u60a8\u5fc5\u987b\u4f7f\u7528 req.body.drain \u6765\u5904\u7406\u6bcf\u4e2a\u53d1\u9001\u5230\u8def\u7531\u7684\u5757\u3002","title":"Body Streaming"},{"location":"routing/#viewing-routes","text":"\u60a8\u53ef\u4ee5\u901a\u8fc7\u63d0\u4f9b Routes \u670d\u52a1\u6216\u4f7f\u7528 app.routes \u6765\u8bbf\u95ee\u5e94\u7528\u7a0b\u5e8f\u7684\u5168\u90e8\u8def\u7531\u3002 print ( app . routes . all ) // [Route] Vapor \u8fd8\u9644\u5e26\u4e86\u4e00\u4e2a routes \u547d\u4ee4\uff0c\u8be5\u547d\u4ee4\u4ee5 ASCII \u683c\u5f0f\u7684\u8868\u683c\u6253\u5370\u6240\u6709\u53ef\u7528\u7684\u8def\u7531\u3002 $ swift run Run routes +--------+----------------+ | GET | / | +--------+----------------+ | GET | /hello/ | +--------+----------------+ | GET | /todos | +--------+----------------+ | POST | /todos | +--------+----------------+ | DELETE | /todos/:todoID | +--------+----------------+","title":"Viewing Routes"},{"location":"routing/#metadata","text":"\u6240\u6709\u8def\u7531\u6ce8\u518c\u65b9\u6cd5\u90fd\u4f1a\u8fd4\u56de\u521b\u5efa\u7684 Route \u3002\u8fd9\u4f7f\u60a8\u53ef\u4ee5\u5c06\u5143\u6570\u636e\u6dfb\u52a0\u5230\u8def\u7531\u7684 userInfo \u5b57\u5178\u4e2d\u3002\u6709\u4e00\u4e9b\u9ed8\u8ba4\u65b9\u6cd5\u53ef\u7528\uff0c\u4f8b\u5982\u6dfb\u52a0 description\u3002 app . get ( \"hello\" , \":name\" ) { req in ... }. description ( \"says hello\" )","title":"Metadata"},{"location":"routing/#route-groups","text":"\u901a\u8fc7\u5bf9\u8def\u7531\u8fdb\u884c\u5206\u7ec4\uff0c\u6211\u4eec\u53ef\u4ee5\u521b\u5efa\u5e26\u6709\u8def\u5f84\u524d\u7f00\u6216\u7279\u5b9a\u4e2d\u95f4\u4ef6\u7684\u4e00\u7ec4\u8def\u7531\u3002\u652f\u6301\u57fa\u4e8e\u6784\u5efa\u5668\u548c\u95ed\u5305\u7684\u8bed\u6cd5\u3002 \u6240\u6709\u5206\u7ec4\u65b9\u6cd5\u90fd\u8fd4\u56de\u4e00\u4e2a RouteBuilder \uff0c\u8fd9\u610f\u5473\u7740\u60a8\u53ef\u4ee5\u5c06\u7ec4\u4e0e\u5176\u4ed6\u8def\u7531\u7684\u6784\u5efa\u65b9\u6cd5\u65e0\u9650\u5730\u6df7\u5408\uff0c\u5339\u914d\u548c\u5d4c\u5957\u3002","title":"Route Groups"},{"location":"routing/#path-prefix","text":"\u8def\u5f84\u524d\u7f00\u8def\u7531\u7ec4\u5141\u8bb8\u60a8\u5728\u4e00\u4e2a\u8def\u7531\u7ec4\u4e4b\u524d\u6dfb\u52a0\u4e00\u4e2a\u6216\u591a\u4e2a\u8def\u5f84\u7ec4\u4ef6\u3002 let users = app . grouped ( \"users\" ) // GET /users users . get { req in ... } // POST /users users . post { req in ... } // GET /users/:id users . get ( \":id\" ) { req in let id = req . parameters . get ( \"id\" ) ! ... } \u53e6\u4e00\u79cd\u57fa\u4e8e\u95ed\u5305\u7684\u8bed\u6cd5\u3002 app . group ( \"users\" ) { users in // GET /users users . get { req in ... } // POST /users users . post { req in ... } // GET /users/:id users . get ( \":id\" ) { req in let id = req . parameters . get ( \"id\" ) ! ... } } \u5d4c\u5957\u8def\u5f84\u524d\u7f00\u8def\u7531\u7ec4\u4f7f\u60a8\u53ef\u4ee5\u7b80\u6d01\u5730\u5b9a\u4e49 CRUD \u7684 API\u3002 app . group ( \"users\" ) { users in // GET /users users . get { ... } // POST /users users . post { ... } users . group ( \":id\" ) { user in // GET /users/:id user . get { ... } // PATCH /users/:id user . patch { ... } // PUT /users/:id user . put { ... } } }","title":"Path Prefix"},{"location":"routing/#middleware","text":"\u9664\u4e86\u53ef\u4ee5\u6dfb\u52a0\u8def\u7531\u524d\u7f00\uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u7ed9\u8def\u7531\u7ec4\u6dfb\u52a0 middleware\u3002 app . get ( \"fast-thing\" ) { req in ... } app . group ( RateLimitMiddleware ( requestsPerMinute : 5 )) { rateLimited in rateLimited . get ( \"slow-thing\" ) { req in ... } } \u4e3a\u67d0\u4e9b\u8def\u7531\u5b50\u96c6\u6dfb\u52a0 authentication middleware \u8fdb\u884c\u8ba4\u8bc1\u4fdd\u62a4\u975e\u5e38\u6709\u7528\u3002 app . post ( \"login\" ) { ... } let auth = app . grouped ( AuthMiddleware ()) auth . get ( \"dashboard\" ) { ... } auth . get ( \"logout\" ) { ... }","title":"Middleware"},{"location":"server/","text":"Server \u00b6 Vapor includes a high-performance, asynchronous HTTP server built on SwiftNIO . This server supports HTTP/1, HTTP/2, and protocol upgrades like WebSockets . The server also supports enabling TLS (SSL). Configuration \u00b6 Vapor's default HTTP server can be configured via app.http.server . // Only support HTTP/2 app . http . server . configuration . supportVersions = [. two ] The HTTP server supports several configuration options. Hostname \u00b6 The hostname controls which address the server will accept new connections on. The default is 127.0.0.1 . // Configure custom hostname. app . http . server . configuration . hostname = \"dev.local\" The server configuration's hostname can be overridden by passing the --hostname ( -H ) flag to the serve command or by passing the hostname parameter to app.server.start(...) . # Override configured hostname. vapor run serve --hostname dev.local Port \u00b6 The port option controls which port at the specified address the server will accept new connections on. The default is 8080 . // Configure custom port. app . http . server . configuration . port = 1337 Info sudo may be required for binding to ports less than 1024 . Ports greater than 65535 are not supported. The server configuration's port can be overridden by passing the --port ( -p ) flag to the serve command or by passing the port parameter to app.server.start(...) . # Override configured port. vapor run serve --port 1337 Backlog \u00b6 The backlog parameter defines the maximum length for the queue of pending connections. The default is 256 . // Configure custom backlog. app . http . server . configuration . backlog = 128 Reuse Address \u00b6 The reuseAddress parameter allows for reuse of local addresses. Defaults to true . // Disable address reuse. app . http . server . configuration . reuseAddress = false TCP No Delay \u00b6 Enabling the tcpNoDelay parameter will attempt to minimize TCP packet delay. Defaults to true . // Minimize packet delay. app . http . server . configuration . tcpNoDelay = true Response Compression \u00b6 The responseCompression parameter controls HTTP response compression using gzip. The default is .disabled . // Enable HTTP response compression. app . http . server . configuration . responseCompression = . enabled To specify an initial buffer capacity, use the initialByteBufferCapacity parameter. . enabled ( initialByteBufferCapacity : 1024 ) Request Decompression \u00b6 The requestDecompression parameter controls HTTP request decompression using gzip. The default is .disabled . // Enable HTTP request decompression. app . http . server . configuration . requestDecompression = . enabled To specify a decompression limit, use the limit parameter. The default is .ratio(10) . // No decompression size limit . enabled ( limit : . none ) Available options are: size : Maximum decompressed size in bytes. ratio : Maximum decompressed size as ratio of compressed bytes. none : No size limits. Setting decompression size limits can help prevent maliciously compressed HTTP requests from using large amounts of memory. Pipelining \u00b6 The supportPipelining parameter enables support for HTTP request and response pipelining. The default is false . // Support HTTP pipelining. app . http . server . configuration . supportPipelining = true Versions \u00b6 The supportVersions parameter controls which HTTP versions the server will use. By default, Vapor will support both HTTP/1 and HTTP/2 when TLS is enabled. Only HTTP/1 is supported when TLS is disabled. // Disable HTTP/1 support. app . http . server . configuration . supportVersions = [. two ] TLS \u00b6 The tlsConfiguration parameter controls whether TLS (SSL) is enabled on the server. The default is nil . // Enable TLS. try app . http . server . configuration . tlsConfiguration = . forServer ( certificateChain : [ . certificate (. init ( file : \"/path/to/cert.pem\" , format : . pem )) ], privateKey : . file ( \"/path/to/key.pem\" ) ) Name \u00b6 The serverName parameter controls the Server header on outgoing HTTP responses. The default is nil . // Add 'Server: vapor' header to responses. app . http . server . configuration . serverName = \"vapor\" Serve Command \u00b6 To start up Vapor's server, use the serve command. This command will run by default if no other commands are specified. vapor run serve The serve command accepts the following parameters: hostname ( -H ): Overrides configured hostname. port ( -p ): Overrides configured port. bind ( -b ): Overrides configured hostname and port joined by : . An example using the --bind ( -b ) flag: vapor run serve - b 0.0 . 0.0 : 80 Use vapor run serve --help for more information. The serve command will listen for SIGTERM and SIGINT to gracefully shutdown the server. Use ctrl+c ( ^c ) to send a SIGINT signal. When the log level is set to debug or lower, information about the status of graceful shutdown will be logged. Manual Start \u00b6 Vapor's server can be started manually using app.server . // Start Vapor's server. try app . server . start () // Request server shutdown. app . server . shutdown () // Wait for the server to shutdown. try app . server . onShutdown . wait () Servers \u00b6 The server Vapor uses is configurable. By default, the built in HTTP server is used. app . servers . use (. http ) Custom Server \u00b6 Vapor's default HTTP server can be replaced by any type conforming to Server . import Vapor final class MyServer : Server { ... } app . servers . use { app in MyServer () } Custom servers can extend Application.Servers.Provider for leading-dot syntax. extension Application . Servers . Provider { static var myServer : Self { . init { $0 . servers . use { app in MyServer () } } } } app . servers . use (. myServer )","title":"Server"},{"location":"server/#server","text":"Vapor includes a high-performance, asynchronous HTTP server built on SwiftNIO . This server supports HTTP/1, HTTP/2, and protocol upgrades like WebSockets . The server also supports enabling TLS (SSL).","title":"Server"},{"location":"server/#configuration","text":"Vapor's default HTTP server can be configured via app.http.server . // Only support HTTP/2 app . http . server . configuration . supportVersions = [. two ] The HTTP server supports several configuration options.","title":"Configuration"},{"location":"server/#hostname","text":"The hostname controls which address the server will accept new connections on. The default is 127.0.0.1 . // Configure custom hostname. app . http . server . configuration . hostname = \"dev.local\" The server configuration's hostname can be overridden by passing the --hostname ( -H ) flag to the serve command or by passing the hostname parameter to app.server.start(...) . # Override configured hostname. vapor run serve --hostname dev.local","title":"Hostname"},{"location":"server/#port","text":"The port option controls which port at the specified address the server will accept new connections on. The default is 8080 . // Configure custom port. app . http . server . configuration . port = 1337 Info sudo may be required for binding to ports less than 1024 . Ports greater than 65535 are not supported. The server configuration's port can be overridden by passing the --port ( -p ) flag to the serve command or by passing the port parameter to app.server.start(...) . # Override configured port. vapor run serve --port 1337","title":"Port"},{"location":"server/#backlog","text":"The backlog parameter defines the maximum length for the queue of pending connections. The default is 256 . // Configure custom backlog. app . http . server . configuration . backlog = 128","title":"Backlog"},{"location":"server/#reuse-address","text":"The reuseAddress parameter allows for reuse of local addresses. Defaults to true . // Disable address reuse. app . http . server . configuration . reuseAddress = false","title":"Reuse Address"},{"location":"server/#tcp-no-delay","text":"Enabling the tcpNoDelay parameter will attempt to minimize TCP packet delay. Defaults to true . // Minimize packet delay. app . http . server . configuration . tcpNoDelay = true","title":"TCP No Delay"},{"location":"server/#response-compression","text":"The responseCompression parameter controls HTTP response compression using gzip. The default is .disabled . // Enable HTTP response compression. app . http . server . configuration . responseCompression = . enabled To specify an initial buffer capacity, use the initialByteBufferCapacity parameter. . enabled ( initialByteBufferCapacity : 1024 )","title":"Response Compression"},{"location":"server/#request-decompression","text":"The requestDecompression parameter controls HTTP request decompression using gzip. The default is .disabled . // Enable HTTP request decompression. app . http . server . configuration . requestDecompression = . enabled To specify a decompression limit, use the limit parameter. The default is .ratio(10) . // No decompression size limit . enabled ( limit : . none ) Available options are: size : Maximum decompressed size in bytes. ratio : Maximum decompressed size as ratio of compressed bytes. none : No size limits. Setting decompression size limits can help prevent maliciously compressed HTTP requests from using large amounts of memory.","title":"Request Decompression"},{"location":"server/#pipelining","text":"The supportPipelining parameter enables support for HTTP request and response pipelining. The default is false . // Support HTTP pipelining. app . http . server . configuration . supportPipelining = true","title":"Pipelining"},{"location":"server/#versions","text":"The supportVersions parameter controls which HTTP versions the server will use. By default, Vapor will support both HTTP/1 and HTTP/2 when TLS is enabled. Only HTTP/1 is supported when TLS is disabled. // Disable HTTP/1 support. app . http . server . configuration . supportVersions = [. two ]","title":"Versions"},{"location":"server/#tls","text":"The tlsConfiguration parameter controls whether TLS (SSL) is enabled on the server. The default is nil . // Enable TLS. try app . http . server . configuration . tlsConfiguration = . forServer ( certificateChain : [ . certificate (. init ( file : \"/path/to/cert.pem\" , format : . pem )) ], privateKey : . file ( \"/path/to/key.pem\" ) )","title":"TLS"},{"location":"server/#name","text":"The serverName parameter controls the Server header on outgoing HTTP responses. The default is nil . // Add 'Server: vapor' header to responses. app . http . server . configuration . serverName = \"vapor\"","title":"Name"},{"location":"server/#serve-command","text":"To start up Vapor's server, use the serve command. This command will run by default if no other commands are specified. vapor run serve The serve command accepts the following parameters: hostname ( -H ): Overrides configured hostname. port ( -p ): Overrides configured port. bind ( -b ): Overrides configured hostname and port joined by : . An example using the --bind ( -b ) flag: vapor run serve - b 0.0 . 0.0 : 80 Use vapor run serve --help for more information. The serve command will listen for SIGTERM and SIGINT to gracefully shutdown the server. Use ctrl+c ( ^c ) to send a SIGINT signal. When the log level is set to debug or lower, information about the status of graceful shutdown will be logged.","title":"Serve Command"},{"location":"server/#manual-start","text":"Vapor's server can be started manually using app.server . // Start Vapor's server. try app . server . start () // Request server shutdown. app . server . shutdown () // Wait for the server to shutdown. try app . server . onShutdown . wait ()","title":"Manual Start"},{"location":"server/#servers","text":"The server Vapor uses is configurable. By default, the built in HTTP server is used. app . servers . use (. http )","title":"Servers"},{"location":"server/#custom-server","text":"Vapor's default HTTP server can be replaced by any type conforming to Server . import Vapor final class MyServer : Server { ... } app . servers . use { app in MyServer () } Custom servers can extend Application.Servers.Provider for leading-dot syntax. extension Application . Servers . Provider { static var myServer : Self { . init { $0 . servers . use { app in MyServer () } } } } app . servers . use (. myServer )","title":"Custom Server"},{"location":"services/","text":"Services \u00b6 Vapor's Application and Request are built to be extended by your application and third-party packages. New functionality added to these types are often called services. Read Only \u00b6 The simplest type of service is read-only. These services consist of computed variables or methods added to either application or request. import Vapor struct MyAPI { let client : Client func foos () -> EventLoopFuture < [ String ] > { ... } } extension Request { var myAPI : MyAPI { . init ( client : self . client ) } } Read-only services can depend on any pre-existing services, like client in this example. Once the extension has been added, your custom service can be used like any other property on request. req . myAPI . foos () Writable \u00b6 Services that need state or configuration can utilize Application and Request storage for storing data. Let's assume you want to add the following MyConfiguration struct to your application. struct MyConfiguration { var apiKey : String } To use storage, you must declare a StorageKey . struct MyConfigurationKey : StorageKey { typealias Value = MyConfiguration } This is an empty struct with a Value typealias specifying which type is being stored. By using an empty type as the key, you can control what code is able to access your storage value. If the type is internal or private, only your code will be able to modify the associated value in storage. Finally, add an extension to Application for getting and setting the MyConfiguration struct. extension Application { var myConfiguration : MyConfiguration ? { get { self . storage [ MyConfigurationKey . self ] } set { self . storage [ MyConfigurationKey . self ] = newValue } } } Once the extension is added, you can use myConfiguration like a normal property on Application . app . myConfiguration = . init ( apiKey : ...) print ( app . myConfiguration ?. apiKey ) Lifecycle \u00b6 Vapor's Application allows you to register lifecycle handlers. These let you hook into events such as boot and shutdown. // Prints hello during boot. struct Hello : LifecycleHandler { // Called before application boots. func willBoot ( _ app : Application ) throws { app . logger . info ( \"Hello!\" ) } } // Add lifecycle handler. app . lifecycle . use ( Hello ()) Locks \u00b6 Vapor's Application includes conveniences for synchronizing code using locks. By declaring a LockKey , you can get a unique, shared lock to synchronize access to your code. struct TestKey : LockKey { } let test = app . locks . lock ( for : TestKey . self ) test . withLock { // Do something. } Each call to lock(for:) with the same LockKey will return the same lock. This method is thread-safe. For an application-wide lock, you can use app.sync . app . sync . withLock { // Do something. } Request \u00b6 Services that are intended to be used in route handlers should be added to Request . Request services should use the request's logger and event loop. It is important that a request stay on the same event loop or an assertion will be hit when the response is returned to Vapor. If a service must leave the request's event loop to do work, it should make sure to return to the event loop before finishing. This can be done using the hop(to:) on EventLoopFuture . Request services that need access to application services, such as configurations, can use req.application . Take care to consider thread-safety when accessing the application from a route handler. Generally, only read operations should be performed by requests. Write operations must be protected by locks.","title":"Services"},{"location":"services/#services","text":"Vapor's Application and Request are built to be extended by your application and third-party packages. New functionality added to these types are often called services.","title":"Services"},{"location":"services/#read-only","text":"The simplest type of service is read-only. These services consist of computed variables or methods added to either application or request. import Vapor struct MyAPI { let client : Client func foos () -> EventLoopFuture < [ String ] > { ... } } extension Request { var myAPI : MyAPI { . init ( client : self . client ) } } Read-only services can depend on any pre-existing services, like client in this example. Once the extension has been added, your custom service can be used like any other property on request. req . myAPI . foos ()","title":"Read Only"},{"location":"services/#writable","text":"Services that need state or configuration can utilize Application and Request storage for storing data. Let's assume you want to add the following MyConfiguration struct to your application. struct MyConfiguration { var apiKey : String } To use storage, you must declare a StorageKey . struct MyConfigurationKey : StorageKey { typealias Value = MyConfiguration } This is an empty struct with a Value typealias specifying which type is being stored. By using an empty type as the key, you can control what code is able to access your storage value. If the type is internal or private, only your code will be able to modify the associated value in storage. Finally, add an extension to Application for getting and setting the MyConfiguration struct. extension Application { var myConfiguration : MyConfiguration ? { get { self . storage [ MyConfigurationKey . self ] } set { self . storage [ MyConfigurationKey . self ] = newValue } } } Once the extension is added, you can use myConfiguration like a normal property on Application . app . myConfiguration = . init ( apiKey : ...) print ( app . myConfiguration ?. apiKey )","title":"Writable"},{"location":"services/#lifecycle","text":"Vapor's Application allows you to register lifecycle handlers. These let you hook into events such as boot and shutdown. // Prints hello during boot. struct Hello : LifecycleHandler { // Called before application boots. func willBoot ( _ app : Application ) throws { app . logger . info ( \"Hello!\" ) } } // Add lifecycle handler. app . lifecycle . use ( Hello ())","title":"Lifecycle"},{"location":"services/#locks","text":"Vapor's Application includes conveniences for synchronizing code using locks. By declaring a LockKey , you can get a unique, shared lock to synchronize access to your code. struct TestKey : LockKey { } let test = app . locks . lock ( for : TestKey . self ) test . withLock { // Do something. } Each call to lock(for:) with the same LockKey will return the same lock. This method is thread-safe. For an application-wide lock, you can use app.sync . app . sync . withLock { // Do something. }","title":"Locks"},{"location":"services/#request","text":"Services that are intended to be used in route handlers should be added to Request . Request services should use the request's logger and event loop. It is important that a request stay on the same event loop or an assertion will be hit when the response is returned to Vapor. If a service must leave the request's event loop to do work, it should make sure to return to the event loop before finishing. This can be done using the hop(to:) on EventLoopFuture . Request services that need access to application services, such as configurations, can use req.application . Take care to consider thread-safety when accessing the application from a route handler. Generally, only read operations should be performed by requests. Write operations must be protected by locks.","title":"Request"},{"location":"sessions/","text":"Sessions \u00b6 Sessions allow you to persist a user's data between multiple requests. Sessions work by creating and returning a unique cookie alongside the HTTP response when a new session is initialized. Browsers will automatically detect this cookie and include it in future requests. This allows Vapor to automatically restore a specific user's session in your request handler. Sessions are great for front-end web applications built in Vapor that serve HTML directly to web browsers. For APIs, we recommend using stateless, token-based authentication to persist user data between requests. Configuration \u00b6 To use sessions in a route, the request must pass through SessionsMiddleware . The easiest way to achieve this is by adding this middleware globally. app . middleware . use ( app . sessions . middleware ) If only a subset of your routes utilize sessions, you can instead add SessionsMiddleware to a route group. let sessions = app . grouped ( app . sessions . middleware ) The HTTP cookie generated by sessions can be configured using app.sessions.configuration . You can change the cookie name and declare a custom function for generating cookie values. // Change the cookie name to \"foo\". app . sessions . configuration . cookieName = \"foo\" // Configures cookie value creation. app . sessions . configuration . cookieFactory = { sessionID in . init ( string : sessionID . string , isSecure : true ) } By default, Vapor will use vapor_session as the cookie name. Drivers \u00b6 Session drivers are responsible for storing and retrieving session data by identifier. You can create custom drivers by conforming to the SessionDriver protocol. In-Memory \u00b6 Vapor utilizes in-memory sessions by default. In-memory sessions require zero configuration and do not persist between application launches which makes them great for testing. To enable in-memory sessions manually, use .memory : app . sessions . use (. memory ) For production use cases, take a look at the other session drivers which utilize databases to persist and share sessions across multiple instances of your app. Fluent \u00b6 Fluent includes support for storing session data in your application's database. This section assumes you have configured Fluent and can connect to a database. The first step is to enable the Fluent sessions driver. import Fluent app . sessions . use (. fluent ) This will configure sessions to use the application's default database. To specify a specific database, pass the database's identifier. app . sessions . use (. fluent (. sqlite )) Finally, add SessionRecord 's migration to your database's migrations. This will prepare your database for storing session data in the _fluent_sessions schema. app . migrations . add ( SessionRecord . migration ) Make sure to run your application's migrations after adding the new migration. Sessions will now be stored in your application's database allowing them to persist between restarts and be shared between multiple instances of your app. Session Data \u00b6 Now that sessions are configured, you are ready to persist data between requests. New sessions are initialized automatically when data is added to req.session . The example route handler below accepts a dynamic route parameter and adds the value to req.session.data . app . get ( \"set\" , \":value\" ) { req -> HTTPStatus in req . session . data [ \"name\" ] = req . parameters . get ( \"value\" ) return . ok } Use the following request to initialize a session with the name Vapor. GET /set/vapor HTTP / 1.1 content-length : 0 You should receive a response similar to the following: HTTP / 1.1 200 OK content-length : 0 set-cookie : vapor-session=123; Expires=Fri, 10 Apr 2020 21:08:09 GMT; Path=/ Notice the set-cookie header has been added automatically to the response after adding data to req.session . Including this cookie in subsequent requests will allow access to the session data. Add the following route handler for accessing the name value from the session. app . get ( \"get\" ) { req -> String in req . session . data [ \"name\" ] ?? \"n/a\" } Use the following request to access this route while making sure to pass the cookie value from the previous response. GET /get HTTP / 1.1 cookie : vapor-session=123 You should see the name Vapor returned in the response. You can add or remove data from the session as you see fit. Session data will be synchronized with the session driver automatically before returning the HTTP response. To end a session, use req.session.destroy . This will delete the data from the session driver and invalidate the session cookie. app . get ( \"del\" ) { req -> HTTPStatus in req . session . destroy () return . ok }","title":"Sessions"},{"location":"sessions/#sessions","text":"Sessions allow you to persist a user's data between multiple requests. Sessions work by creating and returning a unique cookie alongside the HTTP response when a new session is initialized. Browsers will automatically detect this cookie and include it in future requests. This allows Vapor to automatically restore a specific user's session in your request handler. Sessions are great for front-end web applications built in Vapor that serve HTML directly to web browsers. For APIs, we recommend using stateless, token-based authentication to persist user data between requests.","title":"Sessions"},{"location":"sessions/#configuration","text":"To use sessions in a route, the request must pass through SessionsMiddleware . The easiest way to achieve this is by adding this middleware globally. app . middleware . use ( app . sessions . middleware ) If only a subset of your routes utilize sessions, you can instead add SessionsMiddleware to a route group. let sessions = app . grouped ( app . sessions . middleware ) The HTTP cookie generated by sessions can be configured using app.sessions.configuration . You can change the cookie name and declare a custom function for generating cookie values. // Change the cookie name to \"foo\". app . sessions . configuration . cookieName = \"foo\" // Configures cookie value creation. app . sessions . configuration . cookieFactory = { sessionID in . init ( string : sessionID . string , isSecure : true ) } By default, Vapor will use vapor_session as the cookie name.","title":"Configuration"},{"location":"sessions/#drivers","text":"Session drivers are responsible for storing and retrieving session data by identifier. You can create custom drivers by conforming to the SessionDriver protocol.","title":"Drivers"},{"location":"sessions/#in-memory","text":"Vapor utilizes in-memory sessions by default. In-memory sessions require zero configuration and do not persist between application launches which makes them great for testing. To enable in-memory sessions manually, use .memory : app . sessions . use (. memory ) For production use cases, take a look at the other session drivers which utilize databases to persist and share sessions across multiple instances of your app.","title":"In-Memory"},{"location":"sessions/#fluent","text":"Fluent includes support for storing session data in your application's database. This section assumes you have configured Fluent and can connect to a database. The first step is to enable the Fluent sessions driver. import Fluent app . sessions . use (. fluent ) This will configure sessions to use the application's default database. To specify a specific database, pass the database's identifier. app . sessions . use (. fluent (. sqlite )) Finally, add SessionRecord 's migration to your database's migrations. This will prepare your database for storing session data in the _fluent_sessions schema. app . migrations . add ( SessionRecord . migration ) Make sure to run your application's migrations after adding the new migration. Sessions will now be stored in your application's database allowing them to persist between restarts and be shared between multiple instances of your app.","title":"Fluent"},{"location":"sessions/#session-data","text":"Now that sessions are configured, you are ready to persist data between requests. New sessions are initialized automatically when data is added to req.session . The example route handler below accepts a dynamic route parameter and adds the value to req.session.data . app . get ( \"set\" , \":value\" ) { req -> HTTPStatus in req . session . data [ \"name\" ] = req . parameters . get ( \"value\" ) return . ok } Use the following request to initialize a session with the name Vapor. GET /set/vapor HTTP / 1.1 content-length : 0 You should receive a response similar to the following: HTTP / 1.1 200 OK content-length : 0 set-cookie : vapor-session=123; Expires=Fri, 10 Apr 2020 21:08:09 GMT; Path=/ Notice the set-cookie header has been added automatically to the response after adding data to req.session . Including this cookie in subsequent requests will allow access to the session data. Add the following route handler for accessing the name value from the session. app . get ( \"get\" ) { req -> String in req . session . data [ \"name\" ] ?? \"n/a\" } Use the following request to access this route while making sure to pass the cookie value from the previous response. GET /get HTTP / 1.1 cookie : vapor-session=123 You should see the name Vapor returned in the response. You can add or remove data from the session as you see fit. Session data will be synchronized with the session driver automatically before returning the HTTP response. To end a session, use req.session.destroy . This will delete the data from the session driver and invalidate the session cookie. app . get ( \"del\" ) { req -> HTTPStatus in req . session . destroy () return . ok }","title":"Session Data"},{"location":"spm/","text":"Swift Package Manager \u00b6 Swift Package Manager (SPM) \u7528\u4e8e\u6784\u5efa\u9879\u76ee\u7684\u6e90\u4ee3\u7801\u548c\u4f9d\u8d56\u9879\u3002\u7531\u4e8eVapor\u4e25\u91cd\u4f9d\u8d56SPM\uff0c\u56e0\u6b64\u6700\u597d\u4e86\u89e3\u5176\u5de5\u4f5c\u539f\u7406\u3002 SPM \u4e0e Cocoapods\uff0cRuby gems \u548c NPM \u76f8\u4f3c\u3002\u60a8\u53ef\u4ee5\u5728\u547d\u4ee4\u884c\u4e2d\u5c06SPM \u4e0e swift build \u3001 swift test \u7b49\u547d\u4ee4\u6216\u517c\u5bb9\u7684IDE\u7ed3\u5408\u4f7f\u7528\u3002\u4f46\u662f\uff0c\u4e0e\u5176\u4ed6\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u4e0d\u540c\uff0cSPM \u8f6f\u4ef6\u5305\u6ca1\u6709\u4e2d\u592e\u8f6f\u4ef6\u5305\u7d22\u5f15\u3002SPM \u4f7f\u7528 Git\u6807\u7b7e \u5c06 URL \u7528\u4e8e Git\u5b58\u50a8\u5e93\u548c\u7248\u672c\u4f9d\u8d56\u9879\u3002 Package Manifest \u00b6 SPM \u5728\u9879\u76ee\u4e2d\u67e5\u627e\u7684\u7b2c\u4e00\u4f4d\u662f package manifest\u3002\u5b83\u5e94\u59cb\u7ec8\u4f4d\u4e8e\u9879\u76ee\u7684\u6839\u76ee\u5f55\u4e2d\uff0c\u5e76\u547d\u540d\u4e3a\"Package.swift\"\u3002 \u770b\u4e00\u4e0b\u8fd9\u4e2a\u793a\u4f8b. // swift-tools-version:5.2 import PackageDescription let package = Package ( name : \"app\" , platforms : [ . macOS (. v10_15 ) ], products : [ . executable ( name : \"Run\" , targets : [ \"Run\" ]), . library ( name : \"App\" , targets : [ \"App\" ]), ], dependencies : [ . package ( url : \"https://github.com/vapor/vapor.git\" , from : \"4.0.0\" ), ], targets : [ . target ( name : \"App\" , dependencies : [ \"Fluent\" ]), . target ( name : \"Run\" , dependencies : [ \"App\" ]), . testTarget ( name : \"AppTests\" , dependencies : [ \"App\" ]) ] ) \u4ee5\u4e0b\u5404\u8282\u5c06\u8bf4\u660e\u6e05\u5355\u7684\u6bcf\u4e2a\u90e8\u5206\u3002 Tools Version \u00b6 \u7b2c\u4e00\u884c\u8868\u793a\u9700\u8981\u4f7f\u7528\u7684 Swift tools \u7248\u672c\u53f7\uff0c\u5b83\u6307\u660e\u4e86 Swift \u7684\u6700\u4f4e\u53ef\u7528\u7248\u672c\u3002 Package Name \u00b6 Package \u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u4ee3\u8868\u5f53\u524d package \u7684\u540d\u5b57\u3002\u5982\u679c\u8f6f\u4ef6\u5305\u662f\u516c\u5171\u7684\uff0c\u5219\u5e94\u4f7f\u7528Git\u5b58\u50a8\u5e93URL\u7684\u6700\u540e\u4e00\u6bb5\u4f5c\u4e3a\u540d\u79f0 Platforms \u00b6 platforms \u6570\u7ec4\u6307\u5b9a\u6b64\u7a0b\u5e8f\u5305\u652f\u6301\u7684\u5e73\u53f0\u3002\u901a\u8fc7\u6307\u5b9a .macOS\uff08.v10_14\uff09 \uff0c\u8bf4\u660e\u6b64\u8f6f\u4ef6\u5305\u9700\u8981 macOS Mojave \u6216\u66f4\u9ad8\u7248\u672c\u3002 Xcode\u52a0\u8f7d\u8be5\u9879\u76ee\u65f6\uff0c\u5b83\u5c06\u81ea\u52a8\u5c06\u6700\u4f4e\u90e8\u7f72\u7248\u672c\u8bbe\u7f6e\u4e3a10.14\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u4f7f\u7528\u6240\u6709\u53ef\u7528\u7684 API Products \u00b6 products \u5b57\u6bb5\u4ee3\u8868 package \u6784\u5efa\u7684\u65f6\u5019\u8981\u751f\u6210\u7684 targets\u3002\u793a\u4f8b\u4e2d\uff0c\u6709\u4e24\u4e2a target\uff0c\u4e00\u4e2a\u662f library\uff0c\u53e6\u4e00\u4e2a\u662f executable Dependencies \u00b6 dependencies \u5b57\u6bb5\u4ee3\u8868\u9700\u8981\u4f9d\u8d56\u7684 SPM package\u3002\u6240\u6709 Vapor \u5e94\u7528\u90fd\u4f9d\u8d56\u4e8e Vapor package \uff0c\u4f46\u662f\u4f60\u4e5f\u53ef\u4ee5\u6dfb\u52a0\u5176\u5b83\u60f3\u8981\u7684 dependency\u3002 \u4e0a\u9762\u8fd9\u4e2a\u793a\u4f8b\u53ef\u89c1\uff0c vapor/vapor 4.0 \u6216\u4ee5\u4e0a\u7248\u672c\u662f\u8fd9\u4e2a package \u7684 dependency \u3002\u5f53\u5728 package \u4e2d\u6dfb\u52a0\u4e86 dependency \u540e\uff0c\u63a5\u4e0b\u6765\u4f60\u5fc5\u987b\u8bbe\u7f6e targets\u3002 Targets \u00b6 Targets \u5305\u542b\u4e86\u6240\u6709\u7684 modules\u3001executables \u4ee5\u53ca tests\u3002 \u867d\u7136\u53ef\u4ee5\u6dfb\u52a0\u4efb\u610f\u591a\u7684 targets \u6765\u7ec4\u7ec7\u4ee3\u7801\uff0c\u4f46\u5927\u90e8\u5206 Vapor \u5e94\u7528\u6709 3 \u4e2a target \u5c31\u8db3\u591f\u4e86\u3002\u6bcf\u4e2a target \u58f0\u660e\u4e86\u5b83\u4f9d\u8d56\u7684 module \u3002\u4e3a\u4e86\u5728\u4ee3\u7801\u4e2d\u53ef\u4ee5 import \u8fd9\u4e9b modules \uff0c\u4f60\u5fc5\u987b\u6dfb\u52a0 module \u540d\u5b57\u3002\u4e00\u4e2a target \u53ef\u4ee5\u4f9d\u8d56\u4e8e\u5de5\u7a0b\u4e2d\u5176\u5b83\u7684 target \u6216\u8005\u66b4\u9732\u51fa\u6765\u7684 modules\u3002 Tip Executable targets (\u5305\u542b main.swift \u6587\u4ef6\u7684 target) \u4e0d\u80fd\u88ab\u5176\u5b83 modules \u5bfc\u5165\u3002\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48 Vapor \u4f1a\u6709 App \u548c Run \u4e24\u79cd target\u3002\u4efb\u4f55\u5305\u542b\u5728 App \u4e2d\u7684\u4ee3\u7801\u90fd\u53ef\u4ee5\u5728 AppTests \u4e2d\u88ab\u6d4b\u8bd5\u9a8c\u8bc1\u3002 Folder Structure \u00b6 \u4ee5\u4e0b\u662f\u5178\u578b\u7684 SPM package \u76ee\u5f55\u7ed3\u6784\u3002 . \u251c\u2500\u2500 Sources \u2502 \u251c\u2500\u2500 App \u2502 \u2502 \u2514\u2500\u2500 (Source code) \u2502 \u2514\u2500\u2500 Run \u2502 \u2514\u2500\u2500 main.swift \u251c\u2500\u2500 Tests \u2502 \u2514\u2500\u2500 AppTests \u2514\u2500\u2500 Package.swift \u6bcf\u4e2a .target \u5bf9\u5e94 Sources \u4e2d\u7684\u4e00\u4e2a\u6587\u4ef6\u5939\u3002 \u6bcf\u4e2a .testTarget \u5bf9\u5e94 Tests \u4e2d\u7684\u4e00\u4e2a\u6587\u4ef6\u5939\u3002 Package.resolved \u00b6 \u7b2c\u4e00\u6b21\u6784\u5efa\u6210\u529f\u540e\uff0cSPM \u5c06\u4f1a\u81ea\u52a8\u521b\u5efa\u4e00\u4e2a Package.resolved \u6587\u4ef6\u3002 Package.resolved \u4fdd\u5b58\u4e86\u5f53\u524d\u9879\u76ee\u6240\u6709\u7528\u5230\u7684 dependency \u7248\u672c\u3002 \u66f4\u65b0\u4f9d\u8d56, \u8fd0\u884c swift package update . Xcode \u00b6 \u5982\u679c\u4f7f\u7528 Xcode 11 \u6216\u66f4\u9ad8\u7248\u672c\uff0c\u5219\u5728\u4fee\u6539 Package.swift \u6587\u4ef6\u65f6\uff0c\u5c06\u81ea\u52a8\u66f4\u6539 dependencies\u3001targets\u3001products \u7b49\u3002 \u5982\u679c\u8981\u66f4\u65b0\u5230\u6700\u65b0\u7684\u4f9d\u8d56\u9879\u3002\u8bf7\u4f7f\u7528 File \u2192 Swift Packages \u2192 \u66f4\u65b0\u5230\u6700\u65b0\u7684Swift\u8f6f\u4ef6\u5305\u7248\u672c \u60a8\u53ef\u80fd\u8fd8\u60f3\u5c06 .swiftpm \u6587\u4ef6\u6dfb\u52a0\u5230\u60a8\u7684 .gitignore \u6587\u4ef6\u4e2d\uff08Xcode \u5728\u6b64\u5904\u5b58\u50a8 Xcode \u9879\u76ee\u914d\u7f6e\uff09","title":"SPM"},{"location":"spm/#swift-package-manager","text":"Swift Package Manager (SPM) \u7528\u4e8e\u6784\u5efa\u9879\u76ee\u7684\u6e90\u4ee3\u7801\u548c\u4f9d\u8d56\u9879\u3002\u7531\u4e8eVapor\u4e25\u91cd\u4f9d\u8d56SPM\uff0c\u56e0\u6b64\u6700\u597d\u4e86\u89e3\u5176\u5de5\u4f5c\u539f\u7406\u3002 SPM \u4e0e Cocoapods\uff0cRuby gems \u548c NPM \u76f8\u4f3c\u3002\u60a8\u53ef\u4ee5\u5728\u547d\u4ee4\u884c\u4e2d\u5c06SPM \u4e0e swift build \u3001 swift test \u7b49\u547d\u4ee4\u6216\u517c\u5bb9\u7684IDE\u7ed3\u5408\u4f7f\u7528\u3002\u4f46\u662f\uff0c\u4e0e\u5176\u4ed6\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u4e0d\u540c\uff0cSPM \u8f6f\u4ef6\u5305\u6ca1\u6709\u4e2d\u592e\u8f6f\u4ef6\u5305\u7d22\u5f15\u3002SPM \u4f7f\u7528 Git\u6807\u7b7e \u5c06 URL \u7528\u4e8e Git\u5b58\u50a8\u5e93\u548c\u7248\u672c\u4f9d\u8d56\u9879\u3002","title":"Swift Package Manager"},{"location":"spm/#package-manifest","text":"SPM \u5728\u9879\u76ee\u4e2d\u67e5\u627e\u7684\u7b2c\u4e00\u4f4d\u662f package manifest\u3002\u5b83\u5e94\u59cb\u7ec8\u4f4d\u4e8e\u9879\u76ee\u7684\u6839\u76ee\u5f55\u4e2d\uff0c\u5e76\u547d\u540d\u4e3a\"Package.swift\"\u3002 \u770b\u4e00\u4e0b\u8fd9\u4e2a\u793a\u4f8b. // swift-tools-version:5.2 import PackageDescription let package = Package ( name : \"app\" , platforms : [ . macOS (. v10_15 ) ], products : [ . executable ( name : \"Run\" , targets : [ \"Run\" ]), . library ( name : \"App\" , targets : [ \"App\" ]), ], dependencies : [ . package ( url : \"https://github.com/vapor/vapor.git\" , from : \"4.0.0\" ), ], targets : [ . target ( name : \"App\" , dependencies : [ \"Fluent\" ]), . target ( name : \"Run\" , dependencies : [ \"App\" ]), . testTarget ( name : \"AppTests\" , dependencies : [ \"App\" ]) ] ) \u4ee5\u4e0b\u5404\u8282\u5c06\u8bf4\u660e\u6e05\u5355\u7684\u6bcf\u4e2a\u90e8\u5206\u3002","title":"Package Manifest"},{"location":"spm/#tools-version","text":"\u7b2c\u4e00\u884c\u8868\u793a\u9700\u8981\u4f7f\u7528\u7684 Swift tools \u7248\u672c\u53f7\uff0c\u5b83\u6307\u660e\u4e86 Swift \u7684\u6700\u4f4e\u53ef\u7528\u7248\u672c\u3002","title":"Tools Version"},{"location":"spm/#package-name","text":"Package \u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u4ee3\u8868\u5f53\u524d package \u7684\u540d\u5b57\u3002\u5982\u679c\u8f6f\u4ef6\u5305\u662f\u516c\u5171\u7684\uff0c\u5219\u5e94\u4f7f\u7528Git\u5b58\u50a8\u5e93URL\u7684\u6700\u540e\u4e00\u6bb5\u4f5c\u4e3a\u540d\u79f0","title":"Package Name"},{"location":"spm/#platforms","text":"platforms \u6570\u7ec4\u6307\u5b9a\u6b64\u7a0b\u5e8f\u5305\u652f\u6301\u7684\u5e73\u53f0\u3002\u901a\u8fc7\u6307\u5b9a .macOS\uff08.v10_14\uff09 \uff0c\u8bf4\u660e\u6b64\u8f6f\u4ef6\u5305\u9700\u8981 macOS Mojave \u6216\u66f4\u9ad8\u7248\u672c\u3002 Xcode\u52a0\u8f7d\u8be5\u9879\u76ee\u65f6\uff0c\u5b83\u5c06\u81ea\u52a8\u5c06\u6700\u4f4e\u90e8\u7f72\u7248\u672c\u8bbe\u7f6e\u4e3a10.14\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u4f7f\u7528\u6240\u6709\u53ef\u7528\u7684 API","title":"Platforms"},{"location":"spm/#products","text":"products \u5b57\u6bb5\u4ee3\u8868 package \u6784\u5efa\u7684\u65f6\u5019\u8981\u751f\u6210\u7684 targets\u3002\u793a\u4f8b\u4e2d\uff0c\u6709\u4e24\u4e2a target\uff0c\u4e00\u4e2a\u662f library\uff0c\u53e6\u4e00\u4e2a\u662f executable","title":"Products"},{"location":"spm/#dependencies","text":"dependencies \u5b57\u6bb5\u4ee3\u8868\u9700\u8981\u4f9d\u8d56\u7684 SPM package\u3002\u6240\u6709 Vapor \u5e94\u7528\u90fd\u4f9d\u8d56\u4e8e Vapor package \uff0c\u4f46\u662f\u4f60\u4e5f\u53ef\u4ee5\u6dfb\u52a0\u5176\u5b83\u60f3\u8981\u7684 dependency\u3002 \u4e0a\u9762\u8fd9\u4e2a\u793a\u4f8b\u53ef\u89c1\uff0c vapor/vapor 4.0 \u6216\u4ee5\u4e0a\u7248\u672c\u662f\u8fd9\u4e2a package \u7684 dependency \u3002\u5f53\u5728 package \u4e2d\u6dfb\u52a0\u4e86 dependency \u540e\uff0c\u63a5\u4e0b\u6765\u4f60\u5fc5\u987b\u8bbe\u7f6e targets\u3002","title":"Dependencies"},{"location":"spm/#targets","text":"Targets \u5305\u542b\u4e86\u6240\u6709\u7684 modules\u3001executables \u4ee5\u53ca tests\u3002 \u867d\u7136\u53ef\u4ee5\u6dfb\u52a0\u4efb\u610f\u591a\u7684 targets \u6765\u7ec4\u7ec7\u4ee3\u7801\uff0c\u4f46\u5927\u90e8\u5206 Vapor \u5e94\u7528\u6709 3 \u4e2a target \u5c31\u8db3\u591f\u4e86\u3002\u6bcf\u4e2a target \u58f0\u660e\u4e86\u5b83\u4f9d\u8d56\u7684 module \u3002\u4e3a\u4e86\u5728\u4ee3\u7801\u4e2d\u53ef\u4ee5 import \u8fd9\u4e9b modules \uff0c\u4f60\u5fc5\u987b\u6dfb\u52a0 module \u540d\u5b57\u3002\u4e00\u4e2a target \u53ef\u4ee5\u4f9d\u8d56\u4e8e\u5de5\u7a0b\u4e2d\u5176\u5b83\u7684 target \u6216\u8005\u66b4\u9732\u51fa\u6765\u7684 modules\u3002 Tip Executable targets (\u5305\u542b main.swift \u6587\u4ef6\u7684 target) \u4e0d\u80fd\u88ab\u5176\u5b83 modules \u5bfc\u5165\u3002\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48 Vapor \u4f1a\u6709 App \u548c Run \u4e24\u79cd target\u3002\u4efb\u4f55\u5305\u542b\u5728 App \u4e2d\u7684\u4ee3\u7801\u90fd\u53ef\u4ee5\u5728 AppTests \u4e2d\u88ab\u6d4b\u8bd5\u9a8c\u8bc1\u3002","title":"Targets"},{"location":"spm/#folder-structure","text":"\u4ee5\u4e0b\u662f\u5178\u578b\u7684 SPM package \u76ee\u5f55\u7ed3\u6784\u3002 . \u251c\u2500\u2500 Sources \u2502 \u251c\u2500\u2500 App \u2502 \u2502 \u2514\u2500\u2500 (Source code) \u2502 \u2514\u2500\u2500 Run \u2502 \u2514\u2500\u2500 main.swift \u251c\u2500\u2500 Tests \u2502 \u2514\u2500\u2500 AppTests \u2514\u2500\u2500 Package.swift \u6bcf\u4e2a .target \u5bf9\u5e94 Sources \u4e2d\u7684\u4e00\u4e2a\u6587\u4ef6\u5939\u3002 \u6bcf\u4e2a .testTarget \u5bf9\u5e94 Tests \u4e2d\u7684\u4e00\u4e2a\u6587\u4ef6\u5939\u3002","title":"Folder Structure"},{"location":"spm/#packageresolved","text":"\u7b2c\u4e00\u6b21\u6784\u5efa\u6210\u529f\u540e\uff0cSPM \u5c06\u4f1a\u81ea\u52a8\u521b\u5efa\u4e00\u4e2a Package.resolved \u6587\u4ef6\u3002 Package.resolved \u4fdd\u5b58\u4e86\u5f53\u524d\u9879\u76ee\u6240\u6709\u7528\u5230\u7684 dependency \u7248\u672c\u3002 \u66f4\u65b0\u4f9d\u8d56, \u8fd0\u884c swift package update .","title":"Package.resolved"},{"location":"spm/#xcode","text":"\u5982\u679c\u4f7f\u7528 Xcode 11 \u6216\u66f4\u9ad8\u7248\u672c\uff0c\u5219\u5728\u4fee\u6539 Package.swift \u6587\u4ef6\u65f6\uff0c\u5c06\u81ea\u52a8\u66f4\u6539 dependencies\u3001targets\u3001products \u7b49\u3002 \u5982\u679c\u8981\u66f4\u65b0\u5230\u6700\u65b0\u7684\u4f9d\u8d56\u9879\u3002\u8bf7\u4f7f\u7528 File \u2192 Swift Packages \u2192 \u66f4\u65b0\u5230\u6700\u65b0\u7684Swift\u8f6f\u4ef6\u5305\u7248\u672c \u60a8\u53ef\u80fd\u8fd8\u60f3\u5c06 .swiftpm \u6587\u4ef6\u6dfb\u52a0\u5230\u60a8\u7684 .gitignore \u6587\u4ef6\u4e2d\uff08Xcode \u5728\u6b64\u5904\u5b58\u50a8 Xcode \u9879\u76ee\u914d\u7f6e\uff09","title":"Xcode"},{"location":"testing/","text":"Testing \u00b6 Vapor includes a module named XCTVapor that provides test helpers built on XCTest . These testing helpers allow you to send test requests to your Vapor application programmatically or running over an HTTP server. Getting Started \u00b6 To use the XCTVapor module, ensure it has been added to your package's test target. let package = Package ( ... dependencies : [ . package ( url : \"https://github.com/vapor/vapor.git\" , from : \"4.0.0\" ) ], targets : [ ... . testTarget ( name : \"AppTests\" , dependencies : [ . target ( name : \"App\" ), . product ( name : \"XCTVapor\" , package : \"vapor\" ), ]) ] ) Then, add import XCTVapor at the top of your test files. Create classes extending XCTestCase to write test cases. import XCTVapor final class MyTests : XCTestCase { func testStub () throws { // Test here. } } Each function beginning with test will run automatically when your app is tested. Running Tests \u00b6 Use cmd+u with the -Package scheme selected to run tests in Xcode. Use swift test --enable-test-discovery to test via the CLI. Testable Application \u00b6 Initialize an instance of Application using the .testing environment. You must call app.shutdown() before this application deinitializes. let app = Application (. testing ) defer { app . shutdown () } try configure ( app ) Pass the Application to your package's configure(_:) method to apply your configuration. Any test-only configurations can be applied after. Send Request \u00b6 To send a test request to your application, use the test method. try app . test (. GET , \"hello\" ) { res in XCTAssertEqual ( res . status , . ok ) XCTAssertEqual ( res . body . string , \"Hello, world!\" ) } The first two parameters are the HTTP method and URL to request. The trailing closure accepts the HTTP response which you can verify using XCTAssert methods. For more complex requests, you can supply a beforeRequest closure to modify headers or encode content. Vapor's Content API is available on both the test request and response. try app . test (. POST , \"todos\" , beforeRequest : { req in try req . content . encode ([ \"title\" : \"Test\" ]) }, afterResponse : { res in XCTAssertEqual ( res . status , . created ) let todo = try res . content . decode ( Todo . self ) XCTAssertEqual ( todo . title , \"Test\" ) }) Testable Method \u00b6 Vapor's testing API supports sending test requests programmatically and via a live HTTP server. You can specify which method you would like to use by using the testable method. // Use programmatic testing. app . testable ( method : . inMemory ). test (...) // Run tests through a live HTTP server. app . testable ( method : . running ). test (...) The inMemory option is used by default. The running option supports passing a specific port to use. By default 8080 is used. . running ( port : 8123 )","title":"Testing"},{"location":"testing/#testing","text":"Vapor includes a module named XCTVapor that provides test helpers built on XCTest . These testing helpers allow you to send test requests to your Vapor application programmatically or running over an HTTP server.","title":"Testing"},{"location":"testing/#getting-started","text":"To use the XCTVapor module, ensure it has been added to your package's test target. let package = Package ( ... dependencies : [ . package ( url : \"https://github.com/vapor/vapor.git\" , from : \"4.0.0\" ) ], targets : [ ... . testTarget ( name : \"AppTests\" , dependencies : [ . target ( name : \"App\" ), . product ( name : \"XCTVapor\" , package : \"vapor\" ), ]) ] ) Then, add import XCTVapor at the top of your test files. Create classes extending XCTestCase to write test cases. import XCTVapor final class MyTests : XCTestCase { func testStub () throws { // Test here. } } Each function beginning with test will run automatically when your app is tested.","title":"Getting Started"},{"location":"testing/#running-tests","text":"Use cmd+u with the -Package scheme selected to run tests in Xcode. Use swift test --enable-test-discovery to test via the CLI.","title":"Running Tests"},{"location":"testing/#testable-application","text":"Initialize an instance of Application using the .testing environment. You must call app.shutdown() before this application deinitializes. let app = Application (. testing ) defer { app . shutdown () } try configure ( app ) Pass the Application to your package's configure(_:) method to apply your configuration. Any test-only configurations can be applied after.","title":"Testable Application"},{"location":"testing/#send-request","text":"To send a test request to your application, use the test method. try app . test (. GET , \"hello\" ) { res in XCTAssertEqual ( res . status , . ok ) XCTAssertEqual ( res . body . string , \"Hello, world!\" ) } The first two parameters are the HTTP method and URL to request. The trailing closure accepts the HTTP response which you can verify using XCTAssert methods. For more complex requests, you can supply a beforeRequest closure to modify headers or encode content. Vapor's Content API is available on both the test request and response. try app . test (. POST , \"todos\" , beforeRequest : { req in try req . content . encode ([ \"title\" : \"Test\" ]) }, afterResponse : { res in XCTAssertEqual ( res . status , . created ) let todo = try res . content . decode ( Todo . self ) XCTAssertEqual ( todo . title , \"Test\" ) })","title":"Send Request"},{"location":"testing/#testable-method","text":"Vapor's testing API supports sending test requests programmatically and via a live HTTP server. You can specify which method you would like to use by using the testable method. // Use programmatic testing. app . testable ( method : . inMemory ). test (...) // Run tests through a live HTTP server. app . testable ( method : . running ). test (...) The inMemory option is used by default. The running option supports passing a specific port to use. By default 8080 is used. . running ( port : 8123 )","title":"Testable Method"},{"location":"upgrading/","text":"Upgrading to 4.0 \u00b6 This guide shows you how to upgrade an existing Vapor 3.x project to 4.0. This guide attempts to cover all of Vapor's official packages as well as some commonly used providers. If you notice anything missing, Vapor's team chat is a great place to ask for help. Issues and pull requests are also appreciated. Dependencies \u00b6 To use Vapor 4, you will need Xcode 11.4 and macOS 10.15 or greater. The Install section of the docs goes over installing dependencies. Package.swift \u00b6 The first step to upgrading to Vapor 4 is to update your package's dependencies. Below is an example of an upgraded Package.swift file. You can also check out the updated template Package.swift . -// swift-tools-version:4.0 +// swift-tools-version:5.2 import PackageDescription let package = Package( name: \"api\", + platforms: [ + .macOS(.v10_15), + ], dependencies: [ - .package(url: \"https://github.com/vapor/fluent-postgresql.git\", from: \"1.0.0\"), + .package(url: \"https://github.com/vapor/fluent.git\", from: \"4.0.0-rc\"), + .package(url: \"https://github.com/vapor/fluent-postgres-driver.git\", from: \"2.0.0-rc\"), - .package(url: \"https://github.com/vapor/jwt.git\", from: \"3.0.0\"), + .package(url: \"https://github.com/vapor/jwt.git\", from: \"4.0.0-rc\"), - .package(url: \"https://github.com/vapor/vapor.git\", from: \"3.0.0\"), + .package(url: \"https://github.com/vapor/vapor.git\", from: \"4.0.0-rc\"), ], targets: [ .target(name: \"App\", dependencies: [ - \"FluentPostgreSQL\", + .product(name: \"Fluent\", package: \"fluent\"), + .product(name: \"FluentPostgresDriver\", package: \"fluent-postgres-driver\"), - \"Vapor\", + .product(name: \"Vapor\", package: \"vapor\"), - \"JWT\", + .product(name: \"JWT\", package: \"jwt\"), ]), - .target(name: \"Run\", dependencies: [\"App\"]), - .testTarget(name: \"AppTests\", dependencies: [\"App\"]) + .target(name: \"Run\", dependencies: [ + .target(name: \"App\"), + ]), + .testTarget(name: \"AppTests\", dependencies: [ + .target(name: \"App\"), + ]) ] ) All packages that have been upgraded for Vapor 4 will have their major version number incremented by one. Warning The -rc pre-release identifier is used since Vapor 4 has not been officially released yet. Old Packages \u00b6 Some packages may not be upgraded yet. If you encounter any, file an issue to let the author know. Some Vapor 3 packages have been deprecated, such as: vapor/auth : Now included in Vapor. vapor/core : Absorbed into several modules. vapor/crypto : Replaced by SwiftCrypto. vapor/multipart : Now included in Vapor. vapor/url-encoded-form : Now included in Vapor. vapor-community/vapor-ext : Now included in Vapor. vapor-community/pagination : Now part of Fluent. IBM-Swift/LoggerAPI : Replaced by SwiftLogging. Fluent \u00b6 vapor/fluent must now be added as a separate dependency to your dependencies list and targets. All database-specific packages have been suffixed with -driver to make the requirement on vapor/fluent clear. - .package(url: \"https://github.com/vapor/fluent-postgresql.git\", from: \"1.0.0\"), + .package(url: \"https://github.com/vapor/fluent.git\", from: \"4.0.0-rc\"), + .package(url: \"https://github.com/vapor/fluent-postgres-driver.git\", from: \"2.0.0-rc\"), Platforms \u00b6 Vapor's package manifests now explicitly support macOS 10.15 and greater. This means your package will also need to specify platform support. + platforms: [ + .macOS(.v10_15), + ], Vapor may add additional supported platforms in the future. Your package may support any subset of these platforms as long as the version number is equal or greater to Vapor's minimum version requirements. Xcode \u00b6 Vapor 4 utilizies Xcode 11's native SPM support. This means you will no longer need to generate .xcodeproj files. Opening your project's folder in Xcode will automatically recognize SPM and pull in dependencies. You can open your project natively in Xcode using vapor-beta xcode or open Package.swift . Once you've updated Package.swift, you may need to close Xcode and clear the following folders from the root directory: Package.resolved .build .swiftpm *.xcodeproj Once your updated packages have resolved successfully you should see compiler errors--probably quite a few. Don't worry! We'll show you how to fix them. Run \u00b6 The first order of business is to update your Run module's main.swift file to the new format. import App import Vapor var env = try Environment . detect () try LoggingSystem . bootstrap ( from : & env ) let app = Application ( env ) defer { app . shutdown () } try configure ( app ) try app . run () The main.swift file's contents replace the App module's app.swift , so you can delete that file. App \u00b6 Let's take a look at how to update the basic App module structure. configure.swift \u00b6 The configure method should be changed to accept an instance of Application . - public func configure(_ config: inout Config, _ env: inout Environment, _ services: inout Services) throws + public func configure(_ app: Application) throws Below is an example of an updated configure method. import Fluent import FluentSQLiteDriver import Vapor // Called before your application initializes. public func configure ( _ app : Application ) throws { // Serves files from `Public/` directory // app.middleware.use(FileMiddleware(publicDirectory: app.directory.publicDirectory)) // Configure SQLite database app . databases . use (. sqlite (. file ( \"db.sqlite\" )), as : . sqlite ) // Configure migrations app . migrations . add ( CreateTodo ()) try routes ( app ) } Syntax changes for configuring things like routing, middleware, fluent, and more are mentioned below. boot.swift \u00b6 boot 's contents can be placed in the configure method since it now accepts the application instance. routes.swift \u00b6 The routes method should be changed to accept an instance of Application . - public func routes(_ router: Router, _ container: Container) throws + public func routes(_ app: Application) throws More information on changes to routing syntax are mentioned below. Services \u00b6 Vapor 4's services APIs have been simplified to make it easier for you to discover and use services. Services are now exposed as methods and properties on Application and Request which allows the compiler to help you use them. To understand this better, let's take a look at a few examples. // Change the server's default port to 8281 - services.register { container -> NIOServerConfig in - return .default(port: 8281) - } + app.server.configuration.port = 8281 Instead of registering a NIOServerConfig to services, server configuration is now exposed as simple properties on Application that can be overridden. // Register cors middleware let corsConfiguration = CORSMiddleware.Configuration( allowedOrigin: .all, allowedMethods: [.POST, .GET, .PATCH, .PUT, .DELETE, .OPTIONS] ) let corsMiddleware = CORSMiddleware(configuration: corsConfiguration) - var middlewares = MiddlewareConfig() // Create _empty_ middleware config - middlewares.use(corsMiddleware) - services.register(middlewares) + app.middleware.use(corsMiddleware) Instead of creating and registering a MiddlewareConfig to services, middleware are now exposed as a property on Application that can be added to. // Make a request in a route handler. - try req.make(Client.self).get(\"https://vapor.codes\") + req.client.get(\"https://vapor.codes\") Like Application, Request also exposes services as simple properties and methods. Request-specific services should always be used when inside a route closure. This new service pattern replaces the Container , Service , and Config types from Vapor 3. Providers \u00b6 Providers are no longer required to configure third party packages. Each package instead extends Application and Request with new properties and methods for configuration. Take a look at how Leaf is configured in Vapor 4. // Use Leaf for view rendering. - try services.register(LeafProvider()) - config.prefer(LeafRenderer.self, for: ViewRenderer.self) + app.views.use(.leaf) To configure Leaf, use the app.leaf property. // Disable Leaf view caching. - services.register { container -> LeafConfig in - return LeafConfig(tags: ..., viewsDir: ..., shouldCache: false) - } + app.leaf.cache.isEnabled = false Environment \u00b6 The current environment (production, development, etc) can be accessed via app.environment . Custom Services \u00b6 Custom services conforming to the Service protocol and registered to the container in Vapor 3 can be now be expressed as extensions to either Application or Request. struct MyAPI { let client: Client func foo() { ... } } - extension MyAPI: Service { } - services.register { container -> MyAPI in - return try MyAPI(client: container.make()) - } + extension Request { + var myAPI: MyAPI { + .init(client: self.client) + } + } This service can then be accessed using the extension instead of make . - try req.make(MyAPI.self).foo() + req.myAPI.foo() Custom Providers \u00b6 Most custom services can be implemented using extensions as shown in the previous section. However, some advanced providers may need to hook into the application lifecycle or use stored properties. Application's new Lifecycle helper can be used to register lifecycle handlers. struct PrintHello : LifecycleHandler { func willBoot ( _ app : Application ) throws { print ( \"Hello!\" ) } } app . lifecycle . use ( PrintHello ()) To store values on Application, you case use the new Storage helper. struct MyNumber : StorageKey { typealias Value = Int } app . storage [ MyNumber . self ] = 5 print ( app . storage [ MyNumber . self ]) // 5 Accessing app.storage can be wrapped in a settable computed property to create a concise API. extension Application { var myNumber : Int ? { get { self . storage [ MyNumber . self ] } set { self . storage [ MyNumber . self ] = newValue } } } app . myNumber = 42 print ( app . myNumber ) // 42 Both Application and Request also have userInfo dictionaries for storing any data you may need. NIO \u00b6 Vapor 4 now exposes SwiftNIO's async APIs directly and does not attempt to overload methods like map and flatMap or alias types like EventLoopFuture . Vapor 3 provided overloads and aliases for backward compatibility with early beta versions that were released before SwiftNIO existed. These have been removed to reduce confusion with other SwiftNIO compatible packages and better follow SwiftNIO's best practice recommendations. Async naming changes \u00b6 The most obvious change is that the Future typealias for EventLoopFuture has been removed. This can be fixed fairly easily with a find and replace. Furthermore, NIO does not support the to: labels that Vapor 3 added. Given Swift 5.2's improved type inference, to: is less necessary now anyway. - futureA.map(to: String.self) { ... } + futureA.map { ... } Methods prefixed with new , like newPromise have been changed to make to better suit Swift style. - let promise = eventLoop.newPromise(String.self) + let promise = eventLoop.makePromise(of: String.self) catchMap is no longer available, but NIO's methods like mapError and flatMapErrorThrowing will work instead. Vapor 3's global flatMap method for combining multiple futures is no longer available. This can be replaced by using NIO's and method to combine many futures together. - flatMap(futureA, futureB) { a, b in + futureA.and(futureB).flatMap { (a, b) in // Do something with a and b. } ByteBuffer \u00b6 Many methods and properties that previously used Data now use NIO's ByteBuffer . This type is a more powerful and performant byte storage type. You can read more about its API in SwiftNIO's ByteBuffer docs . To convert a ByteBuffer back to Data , use: Data ( buffer . readableBytesView ) Throwing map / flatMap \u00b6 The most difficult change is that map and flatMap can no longer throw. map has a throwing version named (somewhat confusingly) flatMapThrowing . flatMap however has no throwing counterpart. This may require you to restructure some asynchronous code. Maps that do not throw should continue to work fine. // Non-throwing map. futureA . map { a in return b } Maps that do throw must be renamed to flatMapThrowing . - futureA.map { a in + futureA.flatMapThrowing { a in if ... { throw SomeError() } else { return futureB } } Flat-maps that do not throw should continue to work fine. // Non-throwing flatMap. futureA . flatMap { a in return futureB } Flat-maps that do throw must return a future error. // Returning a future error. futureA . flatMap { a in if ... { return eventLoop . makeFailedFuture ( SomeError ()) } else { return futureB } } When calling methods that throw, the error can be caught in a do / catch and returned as a future. // Returning a caught error as a future. futureA . flatMap { a in do { try doSomething () return futureB } catch { return eventLoop . makeFailedFuture ( error ) } } Throwing method calls can also be refactored into a flatMapThrowing and chained using tuples. // Refactored throwing method into flatMapThrowing with tuple-chaining. futureA . flatMapThrowing { a in try ( a , doSomeThing ()) }. flatMap { ( a , result ) in // result is the value of doSomething. return futureB } Routing \u00b6 Routes are now registered directly to Application. app . get ( \"hello\" ) { req in return \"Hello, world\" } This means you no longer need to register a router to services. Simply pass the application to your routes method and start adding routes. All of the methods available on RoutesBuilder are available on Application . Synchronous Content \u00b6 Decoding request content is now synchronous. let payload = try req . content . decode ( MyPayload . self ) print ( payload ) // MyPayload This behavior can be overridden by register routes using the .stream body collection strategy. app . on (. POST , \"streaming\" , body : . stream ) { req in // Request body is now asynchronous. req . body . collect (). map { buffer in HTTPStatus . ok } } Comma-separated paths \u00b6 Paths must now be comma separated and not contain / for consistency. - router.get(\"v1/users/\", \"posts\", \"/comments\") { req in + app.get(\"v1\", \"users\", \"posts\", \"comments\") { req in // Handle request. } Route parameters \u00b6 The Parameter protocol has been removed in favor of explicitly named parameters. This prevents issues with duplicate parameters and un-ordered fetching of parameters in middleware and route handlers. - router.get(\"planets\", String.parameter) { req in - let id = req.parameters.next(String.self) + app.get(\"planets\", \":id\") { req in + let id = req.parameters.get(\"id\") return \"Planet id: \\(id)\" } Route parameter usage with models is mentioned in the Fluent section. Middleware \u00b6 MiddlewareConfig has been renamed to MiddlewareConfiguration and is now a property on Application. You can add middleware to your app using app.middleware . let corsMiddleware = CORSMiddleware(configuration: ...) - var middleware = MiddlewareConfig() - middleware.use(corsMiddleware) + app.middleware.use(corsMiddleware) - services.register(middlewares) Middleware can no longer be registered by type name. Initialize the middleware first before registering. - middleware.use(ErrorMiddleware.self) + app.middleware.use(ErrorMiddleware.default(environment: app.environment)) To remove all default middleware, set app.middleware to an empty config using: app . middleware = . init () HTTP \u00b6 Coming soon. WebSocket \u00b6 Coming soon. Fluent \u00b6 Coming soon. Crypto \u00b6 Coming soon. Queues \u00b6 Coming soon. Validation \u00b6 Coming soon. Auth \u00b6 Coming soon. Stripe \u00b6 Coming soon. Mailgun \u00b6 Coming soon. Leaf \u00b6 Coming soon.","title":"Upgrading"},{"location":"upgrading/#upgrading-to-40","text":"This guide shows you how to upgrade an existing Vapor 3.x project to 4.0. This guide attempts to cover all of Vapor's official packages as well as some commonly used providers. If you notice anything missing, Vapor's team chat is a great place to ask for help. Issues and pull requests are also appreciated.","title":"Upgrading to 4.0"},{"location":"upgrading/#dependencies","text":"To use Vapor 4, you will need Xcode 11.4 and macOS 10.15 or greater. The Install section of the docs goes over installing dependencies.","title":"Dependencies"},{"location":"upgrading/#packageswift","text":"The first step to upgrading to Vapor 4 is to update your package's dependencies. Below is an example of an upgraded Package.swift file. You can also check out the updated template Package.swift . -// swift-tools-version:4.0 +// swift-tools-version:5.2 import PackageDescription let package = Package( name: \"api\", + platforms: [ + .macOS(.v10_15), + ], dependencies: [ - .package(url: \"https://github.com/vapor/fluent-postgresql.git\", from: \"1.0.0\"), + .package(url: \"https://github.com/vapor/fluent.git\", from: \"4.0.0-rc\"), + .package(url: \"https://github.com/vapor/fluent-postgres-driver.git\", from: \"2.0.0-rc\"), - .package(url: \"https://github.com/vapor/jwt.git\", from: \"3.0.0\"), + .package(url: \"https://github.com/vapor/jwt.git\", from: \"4.0.0-rc\"), - .package(url: \"https://github.com/vapor/vapor.git\", from: \"3.0.0\"), + .package(url: \"https://github.com/vapor/vapor.git\", from: \"4.0.0-rc\"), ], targets: [ .target(name: \"App\", dependencies: [ - \"FluentPostgreSQL\", + .product(name: \"Fluent\", package: \"fluent\"), + .product(name: \"FluentPostgresDriver\", package: \"fluent-postgres-driver\"), - \"Vapor\", + .product(name: \"Vapor\", package: \"vapor\"), - \"JWT\", + .product(name: \"JWT\", package: \"jwt\"), ]), - .target(name: \"Run\", dependencies: [\"App\"]), - .testTarget(name: \"AppTests\", dependencies: [\"App\"]) + .target(name: \"Run\", dependencies: [ + .target(name: \"App\"), + ]), + .testTarget(name: \"AppTests\", dependencies: [ + .target(name: \"App\"), + ]) ] ) All packages that have been upgraded for Vapor 4 will have their major version number incremented by one. Warning The -rc pre-release identifier is used since Vapor 4 has not been officially released yet.","title":"Package.swift"},{"location":"upgrading/#old-packages","text":"Some packages may not be upgraded yet. If you encounter any, file an issue to let the author know. Some Vapor 3 packages have been deprecated, such as: vapor/auth : Now included in Vapor. vapor/core : Absorbed into several modules. vapor/crypto : Replaced by SwiftCrypto. vapor/multipart : Now included in Vapor. vapor/url-encoded-form : Now included in Vapor. vapor-community/vapor-ext : Now included in Vapor. vapor-community/pagination : Now part of Fluent. IBM-Swift/LoggerAPI : Replaced by SwiftLogging.","title":"Old Packages"},{"location":"upgrading/#fluent","text":"vapor/fluent must now be added as a separate dependency to your dependencies list and targets. All database-specific packages have been suffixed with -driver to make the requirement on vapor/fluent clear. - .package(url: \"https://github.com/vapor/fluent-postgresql.git\", from: \"1.0.0\"), + .package(url: \"https://github.com/vapor/fluent.git\", from: \"4.0.0-rc\"), + .package(url: \"https://github.com/vapor/fluent-postgres-driver.git\", from: \"2.0.0-rc\"),","title":"Fluent"},{"location":"upgrading/#platforms","text":"Vapor's package manifests now explicitly support macOS 10.15 and greater. This means your package will also need to specify platform support. + platforms: [ + .macOS(.v10_15), + ], Vapor may add additional supported platforms in the future. Your package may support any subset of these platforms as long as the version number is equal or greater to Vapor's minimum version requirements.","title":"Platforms"},{"location":"upgrading/#xcode","text":"Vapor 4 utilizies Xcode 11's native SPM support. This means you will no longer need to generate .xcodeproj files. Opening your project's folder in Xcode will automatically recognize SPM and pull in dependencies. You can open your project natively in Xcode using vapor-beta xcode or open Package.swift . Once you've updated Package.swift, you may need to close Xcode and clear the following folders from the root directory: Package.resolved .build .swiftpm *.xcodeproj Once your updated packages have resolved successfully you should see compiler errors--probably quite a few. Don't worry! We'll show you how to fix them.","title":"Xcode"},{"location":"upgrading/#run","text":"The first order of business is to update your Run module's main.swift file to the new format. import App import Vapor var env = try Environment . detect () try LoggingSystem . bootstrap ( from : & env ) let app = Application ( env ) defer { app . shutdown () } try configure ( app ) try app . run () The main.swift file's contents replace the App module's app.swift , so you can delete that file.","title":"Run"},{"location":"upgrading/#app","text":"Let's take a look at how to update the basic App module structure.","title":"App"},{"location":"upgrading/#configureswift","text":"The configure method should be changed to accept an instance of Application . - public func configure(_ config: inout Config, _ env: inout Environment, _ services: inout Services) throws + public func configure(_ app: Application) throws Below is an example of an updated configure method. import Fluent import FluentSQLiteDriver import Vapor // Called before your application initializes. public func configure ( _ app : Application ) throws { // Serves files from `Public/` directory // app.middleware.use(FileMiddleware(publicDirectory: app.directory.publicDirectory)) // Configure SQLite database app . databases . use (. sqlite (. file ( \"db.sqlite\" )), as : . sqlite ) // Configure migrations app . migrations . add ( CreateTodo ()) try routes ( app ) } Syntax changes for configuring things like routing, middleware, fluent, and more are mentioned below.","title":"configure.swift"},{"location":"upgrading/#bootswift","text":"boot 's contents can be placed in the configure method since it now accepts the application instance.","title":"boot.swift"},{"location":"upgrading/#routesswift","text":"The routes method should be changed to accept an instance of Application . - public func routes(_ router: Router, _ container: Container) throws + public func routes(_ app: Application) throws More information on changes to routing syntax are mentioned below.","title":"routes.swift"},{"location":"upgrading/#services","text":"Vapor 4's services APIs have been simplified to make it easier for you to discover and use services. Services are now exposed as methods and properties on Application and Request which allows the compiler to help you use them. To understand this better, let's take a look at a few examples. // Change the server's default port to 8281 - services.register { container -> NIOServerConfig in - return .default(port: 8281) - } + app.server.configuration.port = 8281 Instead of registering a NIOServerConfig to services, server configuration is now exposed as simple properties on Application that can be overridden. // Register cors middleware let corsConfiguration = CORSMiddleware.Configuration( allowedOrigin: .all, allowedMethods: [.POST, .GET, .PATCH, .PUT, .DELETE, .OPTIONS] ) let corsMiddleware = CORSMiddleware(configuration: corsConfiguration) - var middlewares = MiddlewareConfig() // Create _empty_ middleware config - middlewares.use(corsMiddleware) - services.register(middlewares) + app.middleware.use(corsMiddleware) Instead of creating and registering a MiddlewareConfig to services, middleware are now exposed as a property on Application that can be added to. // Make a request in a route handler. - try req.make(Client.self).get(\"https://vapor.codes\") + req.client.get(\"https://vapor.codes\") Like Application, Request also exposes services as simple properties and methods. Request-specific services should always be used when inside a route closure. This new service pattern replaces the Container , Service , and Config types from Vapor 3.","title":"Services"},{"location":"upgrading/#providers","text":"Providers are no longer required to configure third party packages. Each package instead extends Application and Request with new properties and methods for configuration. Take a look at how Leaf is configured in Vapor 4. // Use Leaf for view rendering. - try services.register(LeafProvider()) - config.prefer(LeafRenderer.self, for: ViewRenderer.self) + app.views.use(.leaf) To configure Leaf, use the app.leaf property. // Disable Leaf view caching. - services.register { container -> LeafConfig in - return LeafConfig(tags: ..., viewsDir: ..., shouldCache: false) - } + app.leaf.cache.isEnabled = false","title":"Providers"},{"location":"upgrading/#environment","text":"The current environment (production, development, etc) can be accessed via app.environment .","title":"Environment"},{"location":"upgrading/#custom-services","text":"Custom services conforming to the Service protocol and registered to the container in Vapor 3 can be now be expressed as extensions to either Application or Request. struct MyAPI { let client: Client func foo() { ... } } - extension MyAPI: Service { } - services.register { container -> MyAPI in - return try MyAPI(client: container.make()) - } + extension Request { + var myAPI: MyAPI { + .init(client: self.client) + } + } This service can then be accessed using the extension instead of make . - try req.make(MyAPI.self).foo() + req.myAPI.foo()","title":"Custom Services"},{"location":"upgrading/#custom-providers","text":"Most custom services can be implemented using extensions as shown in the previous section. However, some advanced providers may need to hook into the application lifecycle or use stored properties. Application's new Lifecycle helper can be used to register lifecycle handlers. struct PrintHello : LifecycleHandler { func willBoot ( _ app : Application ) throws { print ( \"Hello!\" ) } } app . lifecycle . use ( PrintHello ()) To store values on Application, you case use the new Storage helper. struct MyNumber : StorageKey { typealias Value = Int } app . storage [ MyNumber . self ] = 5 print ( app . storage [ MyNumber . self ]) // 5 Accessing app.storage can be wrapped in a settable computed property to create a concise API. extension Application { var myNumber : Int ? { get { self . storage [ MyNumber . self ] } set { self . storage [ MyNumber . self ] = newValue } } } app . myNumber = 42 print ( app . myNumber ) // 42 Both Application and Request also have userInfo dictionaries for storing any data you may need.","title":"Custom Providers"},{"location":"upgrading/#nio","text":"Vapor 4 now exposes SwiftNIO's async APIs directly and does not attempt to overload methods like map and flatMap or alias types like EventLoopFuture . Vapor 3 provided overloads and aliases for backward compatibility with early beta versions that were released before SwiftNIO existed. These have been removed to reduce confusion with other SwiftNIO compatible packages and better follow SwiftNIO's best practice recommendations.","title":"NIO"},{"location":"upgrading/#async-naming-changes","text":"The most obvious change is that the Future typealias for EventLoopFuture has been removed. This can be fixed fairly easily with a find and replace. Furthermore, NIO does not support the to: labels that Vapor 3 added. Given Swift 5.2's improved type inference, to: is less necessary now anyway. - futureA.map(to: String.self) { ... } + futureA.map { ... } Methods prefixed with new , like newPromise have been changed to make to better suit Swift style. - let promise = eventLoop.newPromise(String.self) + let promise = eventLoop.makePromise(of: String.self) catchMap is no longer available, but NIO's methods like mapError and flatMapErrorThrowing will work instead. Vapor 3's global flatMap method for combining multiple futures is no longer available. This can be replaced by using NIO's and method to combine many futures together. - flatMap(futureA, futureB) { a, b in + futureA.and(futureB).flatMap { (a, b) in // Do something with a and b. }","title":"Async naming changes"},{"location":"upgrading/#bytebuffer","text":"Many methods and properties that previously used Data now use NIO's ByteBuffer . This type is a more powerful and performant byte storage type. You can read more about its API in SwiftNIO's ByteBuffer docs . To convert a ByteBuffer back to Data , use: Data ( buffer . readableBytesView )","title":"ByteBuffer"},{"location":"upgrading/#throwing-map-flatmap","text":"The most difficult change is that map and flatMap can no longer throw. map has a throwing version named (somewhat confusingly) flatMapThrowing . flatMap however has no throwing counterpart. This may require you to restructure some asynchronous code. Maps that do not throw should continue to work fine. // Non-throwing map. futureA . map { a in return b } Maps that do throw must be renamed to flatMapThrowing . - futureA.map { a in + futureA.flatMapThrowing { a in if ... { throw SomeError() } else { return futureB } } Flat-maps that do not throw should continue to work fine. // Non-throwing flatMap. futureA . flatMap { a in return futureB } Flat-maps that do throw must return a future error. // Returning a future error. futureA . flatMap { a in if ... { return eventLoop . makeFailedFuture ( SomeError ()) } else { return futureB } } When calling methods that throw, the error can be caught in a do / catch and returned as a future. // Returning a caught error as a future. futureA . flatMap { a in do { try doSomething () return futureB } catch { return eventLoop . makeFailedFuture ( error ) } } Throwing method calls can also be refactored into a flatMapThrowing and chained using tuples. // Refactored throwing method into flatMapThrowing with tuple-chaining. futureA . flatMapThrowing { a in try ( a , doSomeThing ()) }. flatMap { ( a , result ) in // result is the value of doSomething. return futureB }","title":"Throwing map / flatMap"},{"location":"upgrading/#routing","text":"Routes are now registered directly to Application. app . get ( \"hello\" ) { req in return \"Hello, world\" } This means you no longer need to register a router to services. Simply pass the application to your routes method and start adding routes. All of the methods available on RoutesBuilder are available on Application .","title":"Routing"},{"location":"upgrading/#synchronous-content","text":"Decoding request content is now synchronous. let payload = try req . content . decode ( MyPayload . self ) print ( payload ) // MyPayload This behavior can be overridden by register routes using the .stream body collection strategy. app . on (. POST , \"streaming\" , body : . stream ) { req in // Request body is now asynchronous. req . body . collect (). map { buffer in HTTPStatus . ok } }","title":"Synchronous Content"},{"location":"upgrading/#comma-separated-paths","text":"Paths must now be comma separated and not contain / for consistency. - router.get(\"v1/users/\", \"posts\", \"/comments\") { req in + app.get(\"v1\", \"users\", \"posts\", \"comments\") { req in // Handle request. }","title":"Comma-separated paths"},{"location":"upgrading/#route-parameters","text":"The Parameter protocol has been removed in favor of explicitly named parameters. This prevents issues with duplicate parameters and un-ordered fetching of parameters in middleware and route handlers. - router.get(\"planets\", String.parameter) { req in - let id = req.parameters.next(String.self) + app.get(\"planets\", \":id\") { req in + let id = req.parameters.get(\"id\") return \"Planet id: \\(id)\" } Route parameter usage with models is mentioned in the Fluent section.","title":"Route parameters"},{"location":"upgrading/#middleware","text":"MiddlewareConfig has been renamed to MiddlewareConfiguration and is now a property on Application. You can add middleware to your app using app.middleware . let corsMiddleware = CORSMiddleware(configuration: ...) - var middleware = MiddlewareConfig() - middleware.use(corsMiddleware) + app.middleware.use(corsMiddleware) - services.register(middlewares) Middleware can no longer be registered by type name. Initialize the middleware first before registering. - middleware.use(ErrorMiddleware.self) + app.middleware.use(ErrorMiddleware.default(environment: app.environment)) To remove all default middleware, set app.middleware to an empty config using: app . middleware = . init ()","title":"Middleware"},{"location":"upgrading/#http","text":"Coming soon.","title":"HTTP"},{"location":"upgrading/#websocket","text":"Coming soon.","title":"WebSocket"},{"location":"upgrading/#fluent_1","text":"Coming soon.","title":"Fluent"},{"location":"upgrading/#crypto","text":"Coming soon.","title":"Crypto"},{"location":"upgrading/#queues","text":"Coming soon.","title":"Queues"},{"location":"upgrading/#validation","text":"Coming soon.","title":"Validation"},{"location":"upgrading/#auth","text":"Coming soon.","title":"Auth"},{"location":"upgrading/#stripe","text":"Coming soon.","title":"Stripe"},{"location":"upgrading/#mailgun","text":"Coming soon.","title":"Mailgun"},{"location":"upgrading/#leaf","text":"Coming soon.","title":"Leaf"},{"location":"validation/","text":"Validation \u00b6 Vapor's Validation API helps you validate incoming request before using the Content API to decode data. Introduction \u00b6 Vapor's deep integration of Swift's type-safe Codable protocol means you don't need to worry about data validation as much compared to dynamically typed languages. However, there are still a few reasons why you might want to opt-in to explicit validation using the Validation API. Human-Readable Errors \u00b6 Decoding structs using the Content API will yield errors if any of the data is not valid. However, these error messages can sometimes lack human-readability. For example, take the following string-backed enum: enum Color : String , Codable { case red , blue , green } If a user tries to pass the string \"purple\" to a property of type Color , they will get an error similar to the following: Cannot initialize Color from invalid String value purple for key favoriteColor While this error is technically correct and successfully protected the endpoint from an invalid value, it could do better informing the user about the mistake and which options are available. By using the Validation API, you can generate errors like the following: favoriteColor is not red, blue, or green Furthermore, Codable will stop attempting to decode a type as soon as the first error is hit. This means that even if there are many invalid properties in the request, the user will only see the first error. The Validation API will report all validation failures in a single request. Specific Validation \u00b6 Codable handles type validation well, but sometimes you want more than that. For example, validating the contents of a string or validating the size of an integer. The Validation API has validators for helping to validate data like emails, character sets, integer ranges, and more. Validatable \u00b6 To validate a request, you will need to generate a Validations collection. This is most commonly done by conforming an existing type to Validatable . Let's take a look at how you could add validation to this simple POST /users endpoint. This guide assumes you are already familiar with the Content API. enum Color : String , Codable { case red , blue , green } struct CreateUser : Content { var name : String var username : String var age : Int var email : String var favoriteColor : Color ? } app . post ( \"users\" ) { req -> CreateUser in let user = try req . content . decode ( CreateUser . self ) // Do something with user. return user } Adding Validations \u00b6 The first step is to conform the type you are decoding, in this case CreateUser , to Validatable . This can be done in an extension. extension CreateUser : Validatable { static func validations ( _ validations : inout Validations ) { // Validations go here. } } The static method validations(_:) will be called when CreateUser is validated. Any validations you want to perform should be added to the supplied Validations collection. Let's take a look at adding a simple validation to require that the user's email is valid. validations . add ( \"email\" , as : String . self , is : . email ) The first parameter is the value's expected key, in this case \"email\" . This should match the property name on the type being validated. The second parameter, as , is the expected type, in this case String . The type usually matches the property's type, but not always. Finally, one or more validators can be added after the third parameter, is . In this case, we are adding a single validator that checks if the value is an email address. Validating Request \u00b6 Once you've conformed your type to Validatable , the static validate(_:) function can be used to validate requests. Add the following line before req.content.decode(CreateUser.self) in the route handler. try CreateUser . validate ( req ) Now, try sending the following request containing an invalid email: POST /users HTTP / 1.1 Content-Length : 67 Content-Type : application/json { \"age\" : 4 , \"email\" : \"foo\" , \"favoriteColor\" : \"green\" , \"name\" : \"Foo\" , \"username\" : \"foo\" } You should see the following error returned: email is not a valid email address Integer Validation \u00b6 Great, now let's try adding a validation for age . validations . add ( \"age\" , as : Int . self , is : . range ( 13. ..)) The age validation requires that the age is greater than or equal to 13 . If you try the same request from above, you should see a new error now: age is less than minimum of 13, email is not a valid email address String Validation \u00b6 Next, let's add validations for name and username . validations . add ( \"name\" , as : String . self , is : ! . empty ) validations . add ( \"username\" , as : String . self , is : . count ( 3. ..) && . alphanumeric ) The name validation uses the ! operator to invert the .empty validation. This will require that the string is not empty. The username validation combines two validators using && . This will require that the string is at least 3 characters long and contains only alphanumeric characters. Enum Validation \u00b6 Finally, let's take a look at a slightly more advanced validation to check that the supplied favoriteColor is valid. validations . add ( \"favoriteColor\" , as : String . self , is : . in ( \"red\" , \"blue\" , \"green\" ), required : false ) Since it's not possible to decode a Color from an invalid value, this validation uses String as the base type. It uses the .in validator to verify that the value is a valid option: red, blue, or green. Since this value is optional, required is set to false to signal that validation should not fail if this key is missing from the request data. Note that while the favorite color validation will pass if the key is missing, it will not pass if null is supplied. If you want to support null , change the validation type to String? and use the .nil || (read as: \"is nil or ...\") convenience. validations . add ( \"favoriteColor\" , as : String ?. self , is : . nil || . in ( \"red\" , \"blue\" , \"green\" ), required : false ) Validators \u00b6 Below is a list of the currently supported validators and a brief explanation of what they do. Validation Description .ascii Contains only ASCII characters. .alphanumeric Contains only alphanumeric characters. .characterSet(_:) Contains only characters from supplied CharacterSet . .count(_:) Collection's count is within supplied bounds. .email Contains a valid email. .empty Collection is empty. .in(_:) Value is in supplied Collection . .nil Value is null . .range(_:) Value is within supplied Range . .url Contains a valid URL. Validators can also be combined to build complex validations using operators. Operator Position Description ! prefix Inverts a validator, requiring the opposite. && infix Combines two validators, requires both. || infix Combines two validators, requires one.","title":"Validation"},{"location":"validation/#validation","text":"Vapor's Validation API helps you validate incoming request before using the Content API to decode data.","title":"Validation"},{"location":"validation/#introduction","text":"Vapor's deep integration of Swift's type-safe Codable protocol means you don't need to worry about data validation as much compared to dynamically typed languages. However, there are still a few reasons why you might want to opt-in to explicit validation using the Validation API.","title":"Introduction"},{"location":"validation/#human-readable-errors","text":"Decoding structs using the Content API will yield errors if any of the data is not valid. However, these error messages can sometimes lack human-readability. For example, take the following string-backed enum: enum Color : String , Codable { case red , blue , green } If a user tries to pass the string \"purple\" to a property of type Color , they will get an error similar to the following: Cannot initialize Color from invalid String value purple for key favoriteColor While this error is technically correct and successfully protected the endpoint from an invalid value, it could do better informing the user about the mistake and which options are available. By using the Validation API, you can generate errors like the following: favoriteColor is not red, blue, or green Furthermore, Codable will stop attempting to decode a type as soon as the first error is hit. This means that even if there are many invalid properties in the request, the user will only see the first error. The Validation API will report all validation failures in a single request.","title":"Human-Readable Errors"},{"location":"validation/#specific-validation","text":"Codable handles type validation well, but sometimes you want more than that. For example, validating the contents of a string or validating the size of an integer. The Validation API has validators for helping to validate data like emails, character sets, integer ranges, and more.","title":"Specific Validation"},{"location":"validation/#validatable","text":"To validate a request, you will need to generate a Validations collection. This is most commonly done by conforming an existing type to Validatable . Let's take a look at how you could add validation to this simple POST /users endpoint. This guide assumes you are already familiar with the Content API. enum Color : String , Codable { case red , blue , green } struct CreateUser : Content { var name : String var username : String var age : Int var email : String var favoriteColor : Color ? } app . post ( \"users\" ) { req -> CreateUser in let user = try req . content . decode ( CreateUser . self ) // Do something with user. return user }","title":"Validatable"},{"location":"validation/#adding-validations","text":"The first step is to conform the type you are decoding, in this case CreateUser , to Validatable . This can be done in an extension. extension CreateUser : Validatable { static func validations ( _ validations : inout Validations ) { // Validations go here. } } The static method validations(_:) will be called when CreateUser is validated. Any validations you want to perform should be added to the supplied Validations collection. Let's take a look at adding a simple validation to require that the user's email is valid. validations . add ( \"email\" , as : String . self , is : . email ) The first parameter is the value's expected key, in this case \"email\" . This should match the property name on the type being validated. The second parameter, as , is the expected type, in this case String . The type usually matches the property's type, but not always. Finally, one or more validators can be added after the third parameter, is . In this case, we are adding a single validator that checks if the value is an email address.","title":"Adding Validations"},{"location":"validation/#validating-request","text":"Once you've conformed your type to Validatable , the static validate(_:) function can be used to validate requests. Add the following line before req.content.decode(CreateUser.self) in the route handler. try CreateUser . validate ( req ) Now, try sending the following request containing an invalid email: POST /users HTTP / 1.1 Content-Length : 67 Content-Type : application/json { \"age\" : 4 , \"email\" : \"foo\" , \"favoriteColor\" : \"green\" , \"name\" : \"Foo\" , \"username\" : \"foo\" } You should see the following error returned: email is not a valid email address","title":"Validating Request"},{"location":"validation/#integer-validation","text":"Great, now let's try adding a validation for age . validations . add ( \"age\" , as : Int . self , is : . range ( 13. ..)) The age validation requires that the age is greater than or equal to 13 . If you try the same request from above, you should see a new error now: age is less than minimum of 13, email is not a valid email address","title":"Integer Validation"},{"location":"validation/#string-validation","text":"Next, let's add validations for name and username . validations . add ( \"name\" , as : String . self , is : ! . empty ) validations . add ( \"username\" , as : String . self , is : . count ( 3. ..) && . alphanumeric ) The name validation uses the ! operator to invert the .empty validation. This will require that the string is not empty. The username validation combines two validators using && . This will require that the string is at least 3 characters long and contains only alphanumeric characters.","title":"String Validation"},{"location":"validation/#enum-validation","text":"Finally, let's take a look at a slightly more advanced validation to check that the supplied favoriteColor is valid. validations . add ( \"favoriteColor\" , as : String . self , is : . in ( \"red\" , \"blue\" , \"green\" ), required : false ) Since it's not possible to decode a Color from an invalid value, this validation uses String as the base type. It uses the .in validator to verify that the value is a valid option: red, blue, or green. Since this value is optional, required is set to false to signal that validation should not fail if this key is missing from the request data. Note that while the favorite color validation will pass if the key is missing, it will not pass if null is supplied. If you want to support null , change the validation type to String? and use the .nil || (read as: \"is nil or ...\") convenience. validations . add ( \"favoriteColor\" , as : String ?. self , is : . nil || . in ( \"red\" , \"blue\" , \"green\" ), required : false )","title":"Enum Validation"},{"location":"validation/#validators","text":"Below is a list of the currently supported validators and a brief explanation of what they do. Validation Description .ascii Contains only ASCII characters. .alphanumeric Contains only alphanumeric characters. .characterSet(_:) Contains only characters from supplied CharacterSet . .count(_:) Collection's count is within supplied bounds. .email Contains a valid email. .empty Collection is empty. .in(_:) Value is in supplied Collection . .nil Value is null . .range(_:) Value is within supplied Range . .url Contains a valid URL. Validators can also be combined to build complex validations using operators. Operator Position Description ! prefix Inverts a validator, requiring the opposite. && infix Combines two validators, requires both. || infix Combines two validators, requires one.","title":"Validators"},{"location":"websockets/","text":"WebSockets \u00b6 WebSockets allow for two-way communication between a client and server. Unlike HTTP, which has a request and response pattern, WebSocket peers can send an arbitrary number of messages in either direction. Vapor's WebSocket API allows you to create both clients and servers that handle messages asynchronously. Server \u00b6 WebSocket endpoints can be added to your existing Vapor application using the Routing API. Use the webSocket method like you would use get or post . app . webSocket ( \"echo\" ) { req , ws in // Connected WebSocket. print ( ws ) } WebSocket routes can be grouped and protected by middleware like normal routes. In addition to accepting the incoming HTTP request, WebSocket handlers accept the newly established WebSocket connection. See below for more information on using this WebSocket to send and read messages. Client \u00b6 To connect to a remote WebSocket endpoint, use WebSocket.connect . WebSocket . connect ( to : \"ws://echo.websocket.org\" , on : eventLoop ) { ws in // Connected WebSocket. print ( ws ) } The connect method returns a future that completes when the connection is established. Once connected, the supplied closure will be called with the newly connected WebSocket. See below for more information on using this WebSocket to send and read messages. Messages \u00b6 The WebSocket class has methods for sending and receiving messages as well as listening for events like closure. WebSockets can transmit data via two protocols: text and binary. Text messages are interpreted as UTF-8 strings while binary data is interpreted as an array of bytes. Sending \u00b6 Messages can be sent using the WebSocket's send method. ws . send ( \"Hello, world\" ) Passing a String to this method results in a text message being sent. Binary messages can be sent by passing a [UInt8] . ws . send ([ 1 , 2 , 3 ]) Message sending is asynchronous. You can supply an EventLoopPromise to the send method to be notified when the message has finished sending or failed to send. let promise = eventLoop . makePromise ( of : Void . self ) ws . send (..., promise : promise ) promise . futureResult . whenComplete { result in // Succeeded or failed to send. } Receiving \u00b6 Incoming messages are handled via the onText and onBinary callbacks. ws . onText { ws , text in // String received by this WebSocket. print ( text ) } ws . onBinary { ws , binary in // [UInt8] received by this WebSocket. print ( binary ) } The WebSocket itself is supplied as the first parameter to these callbacks to prevent reference cycles. Use this reference to take action on the WebSocket after receiving data. For example, to send a reply: // Echoes received messages. ws . onText { ws , text in ws . send ( text ) } Closing \u00b6 To close a WebSocket, call the close method. ws . close () This method returns a future that will be completed when the WebSocket has closed. Like send , you may also pass a promise to this method. ws . close ( promise : nil ) To be notified when the peer closes the connection, use onClose . This future will be completed when either the client or server closes the WebSocket. ws . onClose . whenComplete { result in // Succeeded or failed to close. } The closeCode property is set when the WebSocket closes. This can be used to determine why the peer closed the connection. Ping / Pong \u00b6 Ping and pong messages are sent automatically by the client and server to keep WebSocket connections alive. Your application can listen for these events using the onPing and onPong callbacks. ws . onPing { ws in // Ping was received. } ws . onPong { ws in // Pong was received. }","title":"WebSockets"},{"location":"websockets/#websockets","text":"WebSockets allow for two-way communication between a client and server. Unlike HTTP, which has a request and response pattern, WebSocket peers can send an arbitrary number of messages in either direction. Vapor's WebSocket API allows you to create both clients and servers that handle messages asynchronously.","title":"WebSockets"},{"location":"websockets/#server","text":"WebSocket endpoints can be added to your existing Vapor application using the Routing API. Use the webSocket method like you would use get or post . app . webSocket ( \"echo\" ) { req , ws in // Connected WebSocket. print ( ws ) } WebSocket routes can be grouped and protected by middleware like normal routes. In addition to accepting the incoming HTTP request, WebSocket handlers accept the newly established WebSocket connection. See below for more information on using this WebSocket to send and read messages.","title":"Server"},{"location":"websockets/#client","text":"To connect to a remote WebSocket endpoint, use WebSocket.connect . WebSocket . connect ( to : \"ws://echo.websocket.org\" , on : eventLoop ) { ws in // Connected WebSocket. print ( ws ) } The connect method returns a future that completes when the connection is established. Once connected, the supplied closure will be called with the newly connected WebSocket. See below for more information on using this WebSocket to send and read messages.","title":"Client"},{"location":"websockets/#messages","text":"The WebSocket class has methods for sending and receiving messages as well as listening for events like closure. WebSockets can transmit data via two protocols: text and binary. Text messages are interpreted as UTF-8 strings while binary data is interpreted as an array of bytes.","title":"Messages"},{"location":"websockets/#sending","text":"Messages can be sent using the WebSocket's send method. ws . send ( \"Hello, world\" ) Passing a String to this method results in a text message being sent. Binary messages can be sent by passing a [UInt8] . ws . send ([ 1 , 2 , 3 ]) Message sending is asynchronous. You can supply an EventLoopPromise to the send method to be notified when the message has finished sending or failed to send. let promise = eventLoop . makePromise ( of : Void . self ) ws . send (..., promise : promise ) promise . futureResult . whenComplete { result in // Succeeded or failed to send. }","title":"Sending"},{"location":"websockets/#receiving","text":"Incoming messages are handled via the onText and onBinary callbacks. ws . onText { ws , text in // String received by this WebSocket. print ( text ) } ws . onBinary { ws , binary in // [UInt8] received by this WebSocket. print ( binary ) } The WebSocket itself is supplied as the first parameter to these callbacks to prevent reference cycles. Use this reference to take action on the WebSocket after receiving data. For example, to send a reply: // Echoes received messages. ws . onText { ws , text in ws . send ( text ) }","title":"Receiving"},{"location":"websockets/#closing","text":"To close a WebSocket, call the close method. ws . close () This method returns a future that will be completed when the WebSocket has closed. Like send , you may also pass a promise to this method. ws . close ( promise : nil ) To be notified when the peer closes the connection, use onClose . This future will be completed when either the client or server closes the WebSocket. ws . onClose . whenComplete { result in // Succeeded or failed to close. } The closeCode property is set when the WebSocket closes. This can be used to determine why the peer closed the connection.","title":"Closing"},{"location":"websockets/#ping-pong","text":"Ping and pong messages are sent automatically by the client and server to keep WebSocket connections alive. Your application can listen for these events using the onPing and onPong callbacks. ws . onPing { ws in // Ping was received. } ws . onPong { ws in // Pong was received. }","title":"Ping / Pong"},{"location":"deploy/digital-ocean/","text":"Deploying to DigitalOcean \u00b6 This guide will walk you through deploying a simple Hello, world Vapor application to a Droplet . To follow this guide, you will need to have a DigitalOcean account with billing configured. Create Server \u00b6 Let's start by installing Swift on an Ubuntu server. Use the create menu to create a new Droplet. Under distributions, select Ubuntu 18.04 LTS. Note You may select any version of Ubuntu that Swift supports. At the time of writing, Swift 5.2 supports 16.04 and 18.04. You can check which operating systems are officially supported on the Swift Releases page. After selecting the distribution, choose any plan and datacenter region you prefer. Then setup an SSH key to access the server after it is created. Finally, click create Droplet and wait for the new server to spin up. Once the new server is ready, hover over the Droplet's IP address and click copy. Initial Setup \u00b6 Open your terminal and connect to the server as root using SSH. ssh root@your_server_ip DigitalOcean has an in-depth guide for initial server setup on Ubuntu 18.04 . This guide will quickly cover the basics. Configure Firewall \u00b6 Allow OpenSSH through the firewall and enable it. ufw allow OpenSSH ufw enable Add User \u00b6 Create a new user besides root . This guide calls the new user vapor . adduser vapor Allow the newly created user to use sudo . usermod -aG sudo vapor Copy the root user's authorized SSH keys to the newly created user. This will allow you to SSH in as the new user. rsync --archive --chown = vapor:vapor ~/.ssh /home/vapor Finally, exit the current SSH session and login as the newly created user. exit ssh vapor@your_server_ip Install Swift \u00b6 Now that you've created a new Ubuntu server and logged in as a non-root user you can install Swift. Swift Dependencies \u00b6 Install Swift's required dependencies. sudo apt-get update sudo apt-get install clang libicu-dev libatomic1 build-essential pkg-config Download Toolchain \u00b6 This guide will install Swift 5.2.0. Visit the Swift Downloads page for a link to latest release. Copy the download link for Ubuntu 18.04. Download and decompress the Swift toolchain. wget https://swift.org/builds/swift-5.2-release/ubuntu1804/swift-5.2-RELEASE/swift-5.2-RELEASE-ubuntu18.04.tar.gz tar xzf swift-5.2-RELEASE-ubuntu18.04.tar.gz Note Swift's Using Downloads guide includes information on how to verify downloads using PGP signatures. Install Toolchain \u00b6 Move Swift somewhere easy to acess. This guide will use /swift with each compiler version in a subfolder. sudo mkdir /swift sudo mv swift-5.2-RELEASE-ubuntu18.04 /swift/5.2.0 Add Swift to /usr/bin so it can be executed by vapor and root . sudo ln -s /swift/5.2.0/usr/bin/swift /usr/bin/swift Verify that Swift was installed correctly. swift --version Setup Project \u00b6 Now that Swift is installed, let's clone and compile your project. For this example, we'll be using Vapor's API template . First let's install Vapor's system dependencies. sudo apt-get install openssl libssl-dev zlib1g-dev libsqlite3-dev Allow HTTP through the firewall. sudo ufw allow http Clone & Build \u00b6 Now clone the project and build it. git clone https://github.com/vapor/api-template.git cd api-template swift build Tip If you are building this project for production, use swift build -c release Run \u00b6 Once the project has finished compiling, run it on your server's IP at port 80. sudo .build/debug/Run serve -b 157 .245.244.228:80 If you used swift build -c release , then you need to run: sudo .build/release/Run serve -b 157 .245.244.228:80 Visit your server's IP via browser or local terminal and you should see \"It works!\". $ curl http://157.245.244.228 It works! Back on your server, you should see logs for the test request. [ NOTICE ] Server starting on http://157.245.244.228:80 [ INFO ] GET / Use CTRL+C to quit the server. It may take a second to shutdown. Congratulations on getting your Vapor app running on a DigitalOcean Droplet! Next Steps \u00b6 The rest of this guide points to additional resources to improve your deployment. Supervisor \u00b6 Supervisor is a process control system that can run and monitor your Vapor executable. With supervisor setup, your app can automatically start when the server boots and be restarted in case it crashes. Learn more about Supervisor . Nginx \u00b6 Nginx is an extremely fast, battle tested, and easy-to-configure HTTP server and proxy. While Vapor supports directly serving HTTP requests, proxying behind Nginx can provide increased performance, security, and ease-of-use. Learn more about Nginx .","title":"DigitalOcean"},{"location":"deploy/digital-ocean/#deploying-to-digitalocean","text":"This guide will walk you through deploying a simple Hello, world Vapor application to a Droplet . To follow this guide, you will need to have a DigitalOcean account with billing configured.","title":"Deploying to DigitalOcean"},{"location":"deploy/digital-ocean/#create-server","text":"Let's start by installing Swift on an Ubuntu server. Use the create menu to create a new Droplet. Under distributions, select Ubuntu 18.04 LTS. Note You may select any version of Ubuntu that Swift supports. At the time of writing, Swift 5.2 supports 16.04 and 18.04. You can check which operating systems are officially supported on the Swift Releases page. After selecting the distribution, choose any plan and datacenter region you prefer. Then setup an SSH key to access the server after it is created. Finally, click create Droplet and wait for the new server to spin up. Once the new server is ready, hover over the Droplet's IP address and click copy.","title":"Create Server"},{"location":"deploy/digital-ocean/#initial-setup","text":"Open your terminal and connect to the server as root using SSH. ssh root@your_server_ip DigitalOcean has an in-depth guide for initial server setup on Ubuntu 18.04 . This guide will quickly cover the basics.","title":"Initial Setup"},{"location":"deploy/digital-ocean/#configure-firewall","text":"Allow OpenSSH through the firewall and enable it. ufw allow OpenSSH ufw enable","title":"Configure Firewall"},{"location":"deploy/digital-ocean/#add-user","text":"Create a new user besides root . This guide calls the new user vapor . adduser vapor Allow the newly created user to use sudo . usermod -aG sudo vapor Copy the root user's authorized SSH keys to the newly created user. This will allow you to SSH in as the new user. rsync --archive --chown = vapor:vapor ~/.ssh /home/vapor Finally, exit the current SSH session and login as the newly created user. exit ssh vapor@your_server_ip","title":"Add User"},{"location":"deploy/digital-ocean/#install-swift","text":"Now that you've created a new Ubuntu server and logged in as a non-root user you can install Swift.","title":"Install Swift"},{"location":"deploy/digital-ocean/#swift-dependencies","text":"Install Swift's required dependencies. sudo apt-get update sudo apt-get install clang libicu-dev libatomic1 build-essential pkg-config","title":"Swift Dependencies"},{"location":"deploy/digital-ocean/#download-toolchain","text":"This guide will install Swift 5.2.0. Visit the Swift Downloads page for a link to latest release. Copy the download link for Ubuntu 18.04. Download and decompress the Swift toolchain. wget https://swift.org/builds/swift-5.2-release/ubuntu1804/swift-5.2-RELEASE/swift-5.2-RELEASE-ubuntu18.04.tar.gz tar xzf swift-5.2-RELEASE-ubuntu18.04.tar.gz Note Swift's Using Downloads guide includes information on how to verify downloads using PGP signatures.","title":"Download Toolchain"},{"location":"deploy/digital-ocean/#install-toolchain","text":"Move Swift somewhere easy to acess. This guide will use /swift with each compiler version in a subfolder. sudo mkdir /swift sudo mv swift-5.2-RELEASE-ubuntu18.04 /swift/5.2.0 Add Swift to /usr/bin so it can be executed by vapor and root . sudo ln -s /swift/5.2.0/usr/bin/swift /usr/bin/swift Verify that Swift was installed correctly. swift --version","title":"Install Toolchain"},{"location":"deploy/digital-ocean/#setup-project","text":"Now that Swift is installed, let's clone and compile your project. For this example, we'll be using Vapor's API template . First let's install Vapor's system dependencies. sudo apt-get install openssl libssl-dev zlib1g-dev libsqlite3-dev Allow HTTP through the firewall. sudo ufw allow http","title":"Setup Project"},{"location":"deploy/digital-ocean/#clone-build","text":"Now clone the project and build it. git clone https://github.com/vapor/api-template.git cd api-template swift build Tip If you are building this project for production, use swift build -c release","title":"Clone &amp; Build"},{"location":"deploy/digital-ocean/#run","text":"Once the project has finished compiling, run it on your server's IP at port 80. sudo .build/debug/Run serve -b 157 .245.244.228:80 If you used swift build -c release , then you need to run: sudo .build/release/Run serve -b 157 .245.244.228:80 Visit your server's IP via browser or local terminal and you should see \"It works!\". $ curl http://157.245.244.228 It works! Back on your server, you should see logs for the test request. [ NOTICE ] Server starting on http://157.245.244.228:80 [ INFO ] GET / Use CTRL+C to quit the server. It may take a second to shutdown. Congratulations on getting your Vapor app running on a DigitalOcean Droplet!","title":"Run"},{"location":"deploy/digital-ocean/#next-steps","text":"The rest of this guide points to additional resources to improve your deployment.","title":"Next Steps"},{"location":"deploy/digital-ocean/#supervisor","text":"Supervisor is a process control system that can run and monitor your Vapor executable. With supervisor setup, your app can automatically start when the server boots and be restarted in case it crashes. Learn more about Supervisor .","title":"Supervisor"},{"location":"deploy/digital-ocean/#nginx","text":"Nginx is an extremely fast, battle tested, and easy-to-configure HTTP server and proxy. While Vapor supports directly serving HTTP requests, proxying behind Nginx can provide increased performance, security, and ease-of-use. Learn more about Nginx .","title":"Nginx"},{"location":"deploy/nginx/","text":"Deploying with Nginx \u00b6 Nginx is an extremely fast, battle tested, and easy-to-configure HTTP server and proxy. While Vapor supports directly serving HTTP requests with or without TLS, proxying behind Nginx can provide increased performance, security, and ease-of-use. Note We recommend proxying Vapor HTTP servers behind Nginx. Overview \u00b6 What does it mean to proxy an HTTP server? In short, a proxy acts as a middleman between the public internet and your HTTP server. Requests come to the proxy and then it sends them to Vapor. An important feature of this middleman proxy is that it can alter or even redirect the requests. For instance, the proxy can require that the client use TLS (https), rate limit requests, or even serve public files without talking to your Vapor application. More Detail \u00b6 The default port for receiving HTTP requests is port 80 (and 443 for HTTPS). When you bind a Vapor server to port 80 , it will directly receive and respond to the HTTP requests that come to your server. When adding a proxy like Nginx, you bind Vapor to an internal port, like port 8080 . Note Ports greater than 1024 do not require sudo to bind. When Vapor is bound to a port besides 80 or 443 , it will not be accessible to the outside internet. You then bind Nginx to port 80 and configure it to route requests to your Vapor server bound at port 8080 (or whichever port you've chosen). And that's it. If Nginx is properly configured, you will see your Vapor app responding to requests on port 80 . Nginx proxies the requests and responses invisibly. Install Nginx \u00b6 The first step is installing Nginx. One of the great parts of Nginx is the tremendous amount of community resources and documentation surrounding it. Because of this, we will not go into great detail here about installing Nginx as there is almost definitely a tutorial for your specific platform, OS, and provider. Tutorials: How To Install Nginx on Ubuntu 14.04 LTS How To Install Nginx on Ubuntu 16.04 How to Deploy Nginx on Heroku How To Run Nginx in a Docker Container on Ubuntu 14.04 APT \u00b6 Nginx can be installed through APT. sudo apt-get update sudo apt-get install nginx Check whether Nginx was installed correctly by visiting your server's IP address in a browser http://server_domain_name_or_IP Service \u00b6 The service can be started or stopped. sudo service nginx stop sudo service nginx start sudo service nginx restart Booting Vapor \u00b6 Nginx can be started an stopped with the sudo service nginx ... commands. You will need something similar to start and stop your Vapor server. There are many ways to do this, and they depend on which platform you are deploying to. Check out the Supervisor instructions to add commands for starting and stopping your Vapor app. Configure Proxy \u00b6 The configuration files for enabled sites can be found in /etc/nginx/sites-enabled/ . Create a new file or copy the example template from /etc/nginx/sites-available/ to get started. Here is an example configuration file for a Vapor project called Hello in the home directory. server { server_name hello.com ; listen 80 ; root /home/vapor/Hello/Public/ ; location @proxy { proxy_pass http://127.0.0.1:8080 ; proxy_pass_header Server ; proxy_set_header Host $host ; proxy_set_header X-Real-IP $remote_addr ; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for ; proxy_pass_header Server ; proxy_connect_timeout 3s ; proxy_read_timeout 10s ; } } This configuration file assumes the Hello project binds to port 8080 when started in production mode. Serving Files \u00b6 Nginx can also serve public files without asking your Vapor app. This can improve performance by freeing up the Vapor process for other tasks under heavy load. server { ... # Serve all public/static files via nginx and then fallback to Vapor for the rest try_files $uri @proxy ; location @proxy { ... } } TLS \u00b6 Adding TLS is relatively straightforward as long as the certificates have been properly generated. To generate TLS certificates for free, check out Let's Encrypt . server { ... listen 443 ssl ; ssl_certificate /etc/letsencrypt/live/hello.com/fullchain.pem ; ssl_certificate_key /etc/letsencrypt/live/hello.com/privkey.pem ; ssl_protocols TLSv1 TLSv1.1 TLSv1.2 ; ssl_prefer_server_ciphers on ; ssl_dhparam /etc/ssl/certs/dhparam.pem ; ssl_ciphers 'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA' ; ssl_session_timeout 1d ; ssl_session_cache shared:SSL:50m ; ssl_stapling on ; ssl_stapling_verify on ; add_header Strict-Transport-Security max-age = 15768000 ; ... location @proxy { ... } } The configuration above are the relatively strict settings for TLS with Nginx. Some of the settings here are not required, but enhance security.","title":"Nginx"},{"location":"deploy/nginx/#deploying-with-nginx","text":"Nginx is an extremely fast, battle tested, and easy-to-configure HTTP server and proxy. While Vapor supports directly serving HTTP requests with or without TLS, proxying behind Nginx can provide increased performance, security, and ease-of-use. Note We recommend proxying Vapor HTTP servers behind Nginx.","title":"Deploying with Nginx"},{"location":"deploy/nginx/#overview","text":"What does it mean to proxy an HTTP server? In short, a proxy acts as a middleman between the public internet and your HTTP server. Requests come to the proxy and then it sends them to Vapor. An important feature of this middleman proxy is that it can alter or even redirect the requests. For instance, the proxy can require that the client use TLS (https), rate limit requests, or even serve public files without talking to your Vapor application.","title":"Overview"},{"location":"deploy/nginx/#more-detail","text":"The default port for receiving HTTP requests is port 80 (and 443 for HTTPS). When you bind a Vapor server to port 80 , it will directly receive and respond to the HTTP requests that come to your server. When adding a proxy like Nginx, you bind Vapor to an internal port, like port 8080 . Note Ports greater than 1024 do not require sudo to bind. When Vapor is bound to a port besides 80 or 443 , it will not be accessible to the outside internet. You then bind Nginx to port 80 and configure it to route requests to your Vapor server bound at port 8080 (or whichever port you've chosen). And that's it. If Nginx is properly configured, you will see your Vapor app responding to requests on port 80 . Nginx proxies the requests and responses invisibly.","title":"More Detail"},{"location":"deploy/nginx/#install-nginx","text":"The first step is installing Nginx. One of the great parts of Nginx is the tremendous amount of community resources and documentation surrounding it. Because of this, we will not go into great detail here about installing Nginx as there is almost definitely a tutorial for your specific platform, OS, and provider. Tutorials: How To Install Nginx on Ubuntu 14.04 LTS How To Install Nginx on Ubuntu 16.04 How to Deploy Nginx on Heroku How To Run Nginx in a Docker Container on Ubuntu 14.04","title":"Install Nginx"},{"location":"deploy/nginx/#apt","text":"Nginx can be installed through APT. sudo apt-get update sudo apt-get install nginx Check whether Nginx was installed correctly by visiting your server's IP address in a browser http://server_domain_name_or_IP","title":"APT"},{"location":"deploy/nginx/#service","text":"The service can be started or stopped. sudo service nginx stop sudo service nginx start sudo service nginx restart","title":"Service"},{"location":"deploy/nginx/#booting-vapor","text":"Nginx can be started an stopped with the sudo service nginx ... commands. You will need something similar to start and stop your Vapor server. There are many ways to do this, and they depend on which platform you are deploying to. Check out the Supervisor instructions to add commands for starting and stopping your Vapor app.","title":"Booting Vapor"},{"location":"deploy/nginx/#configure-proxy","text":"The configuration files for enabled sites can be found in /etc/nginx/sites-enabled/ . Create a new file or copy the example template from /etc/nginx/sites-available/ to get started. Here is an example configuration file for a Vapor project called Hello in the home directory. server { server_name hello.com ; listen 80 ; root /home/vapor/Hello/Public/ ; location @proxy { proxy_pass http://127.0.0.1:8080 ; proxy_pass_header Server ; proxy_set_header Host $host ; proxy_set_header X-Real-IP $remote_addr ; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for ; proxy_pass_header Server ; proxy_connect_timeout 3s ; proxy_read_timeout 10s ; } } This configuration file assumes the Hello project binds to port 8080 when started in production mode.","title":"Configure Proxy"},{"location":"deploy/nginx/#serving-files","text":"Nginx can also serve public files without asking your Vapor app. This can improve performance by freeing up the Vapor process for other tasks under heavy load. server { ... # Serve all public/static files via nginx and then fallback to Vapor for the rest try_files $uri @proxy ; location @proxy { ... } }","title":"Serving Files"},{"location":"deploy/nginx/#tls","text":"Adding TLS is relatively straightforward as long as the certificates have been properly generated. To generate TLS certificates for free, check out Let's Encrypt . server { ... listen 443 ssl ; ssl_certificate /etc/letsencrypt/live/hello.com/fullchain.pem ; ssl_certificate_key /etc/letsencrypt/live/hello.com/privkey.pem ; ssl_protocols TLSv1 TLSv1.1 TLSv1.2 ; ssl_prefer_server_ciphers on ; ssl_dhparam /etc/ssl/certs/dhparam.pem ; ssl_ciphers 'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA' ; ssl_session_timeout 1d ; ssl_session_cache shared:SSL:50m ; ssl_stapling on ; ssl_stapling_verify on ; add_header Strict-Transport-Security max-age = 15768000 ; ... location @proxy { ... } } The configuration above are the relatively strict settings for TLS with Nginx. Some of the settings here are not required, but enhance security.","title":"TLS"},{"location":"deploy/supervisor/","text":"Supervisor \u00b6 Supervisor is a process control system that makes it easy to start, stop, and restart your Vapor app. Install \u00b6 sudo apt-get update sudo apt-get install supervisor Configure \u00b6 Each Vapor app on your server should have its own configuration file. For an example Hello project, the configuration file would be located at /etc/supervisor/conf.d/hello.conf [ program:hello ] command = /home/vapor/hello/.build/release/Run serve --env production directory = /home/vapor/hello/ user = vapor stdout_logfile = /var/log/supervisor/% ( program_name ) -stdout.log stderr_logfile = /var/log/supervisor/% ( program_name ) -stderr.log As specified in our configuration file the Hello project is located in the home folder for the user vapor . Make sure directory points to the root directory of your project where the Package.swift file is. The --env production flag will disable verbose logging. Environment \u00b6 You can export variables to your Vapor app with supervisor. environment = PORT = 8123 Exported variables can be used in Vapor using Environment.get let port = Environment . get ( \"PORT\" ) Start \u00b6 You can now load and start your app. supervisorctl reread supervisorctl add hello supervisorctl start hello Note The add command may have already started your app.","title":"Supervisor"},{"location":"deploy/supervisor/#supervisor","text":"Supervisor is a process control system that makes it easy to start, stop, and restart your Vapor app.","title":"Supervisor"},{"location":"deploy/supervisor/#install","text":"sudo apt-get update sudo apt-get install supervisor","title":"Install"},{"location":"deploy/supervisor/#configure","text":"Each Vapor app on your server should have its own configuration file. For an example Hello project, the configuration file would be located at /etc/supervisor/conf.d/hello.conf [ program:hello ] command = /home/vapor/hello/.build/release/Run serve --env production directory = /home/vapor/hello/ user = vapor stdout_logfile = /var/log/supervisor/% ( program_name ) -stdout.log stderr_logfile = /var/log/supervisor/% ( program_name ) -stderr.log As specified in our configuration file the Hello project is located in the home folder for the user vapor . Make sure directory points to the root directory of your project where the Package.swift file is. The --env production flag will disable verbose logging.","title":"Configure"},{"location":"deploy/supervisor/#environment","text":"You can export variables to your Vapor app with supervisor. environment = PORT = 8123 Exported variables can be used in Vapor using Environment.get let port = Environment . get ( \"PORT\" )","title":"Environment"},{"location":"deploy/supervisor/#start","text":"You can now load and start your app. supervisorctl reread supervisorctl add hello supervisorctl start hello Note The add command may have already started your app.","title":"Start"},{"location":"fluent/migrations/","text":"Migrations \u00b6 Coming soon.","title":"Migrations"},{"location":"fluent/migrations/#migrations","text":"Coming soon.","title":"Migrations"},{"location":"fluent/models/","text":"Models \u00b6 Coming soon.","title":"Models"},{"location":"fluent/models/#models","text":"Coming soon.","title":"Models"},{"location":"fluent/overview/","text":"Fluent \u00b6 Fluent \u662f\u4e00\u4e2aswift\u8bed\u8a00\u7684 ORM \u6846\u67b6. \u5b83\u5229\u7528swift\u5f3a\u7c7b\u578b\u7cfb\u7edf\u4e3a\u4f60\u7684\u6570\u636e\u5e93\u63d0\u4f9b\u6613\u7528\u7684\u63a5\u53e3. \u4f7f\u7528Fluent\u7684\u6838\u5fc3\u662f\u521b\u5efa\u7528\u6765\u8868\u793a\u6570\u636e\u5e93\u7684\u6570\u636e\u7ed3\u6784\u7684\u6a21\u578b\u7c7b\u578b(Model). \u7136\u540e\u4f7f\u7528\u8fd9\u4e9b\u6a21\u578b\u6267\u884c\u521b\u5efa\u3001\u8bfb\u53d6\u3001\u66f4\u65b0\u3001\u5220\u9664\u64cd\u4f5c\uff0c\u800c\u4e0d\u662f\u7f16\u5199\u539f\u59cbSQL\u8bed\u53e5\u3002 \u914d\u7f6e\uff08Configuration\uff09 \u00b6 \u5f53\u4f7f\u7528\u547d\u4ee4 vapor new \u521b\u5efa\u4e00\u4e2a\u5de5\u7a0b\u65f6, \u952e\u5165 \"yes\" \u6765\u5305\u542bFluent\u5e76\u9009\u62e9\u4f60\u5e0c\u671b\u4f7f\u7528\u7684\u6570\u636e\u5e93\u9a71\u52a8\u3002\u8fd9\u5c06\u81ea\u52a8\u5c06\u4f9d\u8d56\u9879\u4ee5\u53ca\u793a\u4f8b\u914d\u7f6e\u4ee3\u7801\u6dfb\u52a0\u5230\u4f60\u7684\u5de5\u7a0b. \u73b0\u6709\u9879\u76ee \u00b6 \u5982\u679c\u4f60\u6709\u4e00\u4e2a\u73b0\u6709\u9879\u76ee\u60f3\u4f7f\u7528Fluent\uff0c\u5219\u9700\u8981\u5c06\u4e24\u4e2a\u4f9d\u8d56\u9879\u6dfb\u52a0\u5230\u4f60\u7684 package : vapor/fluent @4.0.0 \u4e00\u4e2a\u6216\u591a\u4e2aFluent\u9a71\u52a8 . package ( url : \"https://github.com/vapor/fluent.git\" , from : \"4.0.0-beta\" ), . package ( url : \"https://github.com/vapor/fluent-<db>-driver.git\" , from : < version >), . target ( name : \"App\" , dependencies : [ . product ( name : \"Fluent\" , package : \"fluent\" ), . product ( name : \"Fluent<db>Driver\" , package : \"fluent-<db>-driver\" ), . product ( name : \"Vapor\" , package : \"vapor\" ), ]), \u4e00\u65e6\u8fd9\u4e9b\u5305\u88ab\u6dfb\u52a0\u4e3a\u4f9d\u8d56\u9879\uff0c\u4f60\u5c31\u53ef\u4ee5\u5728 configure.swift \u6587\u4ef6\u4e2d\uff0c\u4f7f\u7528 app.databases \u6765\u914d\u7f6e\u4f60\u7684\u6570\u636e\u5e93\u3002 import Fluent import Fluent < db > Driver app . databases . use (< db config >, as : < identifier >) \u4e0b\u9762\u662f\u6bcf\u4e00Fluent\u9a71\u52a8\u7a0b\u5e8f\u7684\u66f4\u8be6\u7ec6\u7684\u914d\u7f6e\u8bf4\u660e\u3002 \u9a71\u52a8 \u00b6 Fluent \u5f53\u524d\u6709\u4e09\u4e2a\u5b98\u65b9\u652f\u6301\u7684\u9a71\u52a8. \u4f60\u53ef\u4ee5\u5728Github\u4e0a\u641c\u7d22 fluent-driver \u6765\u83b7\u53d6\u5b98\u65b9\u548c\u7b2c\u4e09\u65b9\u7684Fluent\u6570\u636e\u5e93\u7a0b\u5e8f\u7684\u5b8c\u6574\u5217\u8868\u3002 PostgreSQL \u00b6 PostgreSQL \u662f\u4e00\u4e2a\u5f00\u6e90\u7684\u3001\u7b26\u5408\u6807\u51c6\u7684SQL\u6570\u636e\u5e93\u3002\u5b83\u53ef\u4ee5\u5f88\u5bb9\u6613\u7684\u914d\u7f6e\u5728\u5927\u591a\u6570\u4e91\u6258\u7ba1\u63d0\u4f9b\u5546\u4e0a. \u8fd9\u662f Fluent \u63a8\u8350\u7684 \u6570\u636e\u5e93\u9a71\u52a8. \u8981\u4f7f\u7528PostgreSQL, \u9700\u8981\u6dfb\u52a0\u4e0b\u5217\u4f9d\u8d56\u9879\u5230\u4f60\u7684\u5305\u4e2d. . package ( url : \"https://github.com/vapor/fluent-postgres-driver.git\" , from : \"2.0.0-beta\" ) . product ( name : \"FluentPostgresDriver\" , package : \"fluent-postgres-driver\" ) \u4e00\u65e6\u6dfb\u52a0\u4e86\u4f9d\u8d56\u9879\uff0c\u4f60\u5c31\u53ef\u4ee5\u5728 configure.swift \u6587\u4ef6\u4e2d\uff0c\u4f7f\u7528 app.databases.use \u6765\u914d\u7f6e\u6570\u636e\u5e93\u51ed\u8bc1\u3002 import Fluent import FluentPostgresDriver app . databases . use (. postgres ( hostname : \"localhost\" , username : \"vapor\" , password : \"vapor\" , database : \"vapor\" ), as : . psql ) \u4f60\u4e5f\u53ef\u4ee5\u4ece\u6570\u636e\u5e93\u8fde\u63a5\u5b57\u7b26\u4e32\u4e2d\u89e3\u6790\u51ed\u8bc1 try app . databases . use (. postgres ( url : \"<connection string>\" ), as : . psql ) SQLite \u00b6 SQLite\u662f\u4e00\u4e2a\u5f00\u6e90\u7684\u5d4c\u5165\u5f0fSQL\u6570\u636e\u5e93\uff0c\u5176\u7b80\u5355\u7684\u7279\u6027\u4f7f\u5b83\u6210\u4e3a\u539f\u578b\u548c\u6d4b\u8bd5\u7684\u5353\u8d8a\u7684\u5019\u9009\u3002 \u8981\u4f7f\u7528 SQLite, \u9700\u8981\u6dfb\u52a0\u4e0b\u5217\u4f9d\u8d56\u9879\u5230\u4f60\u7684\u5305\u4e2d. . package ( url : \"https://github.com/vapor/fluent-sqlite-driver.git\" , from : \"4.0.0-beta\" ) . product ( name : \"FluentSQLiteDriver\" , package : \"fluent-sqlite-driver\" ) \u4e00\u65e6\u6dfb\u52a0\u4e86\u4f9d\u8d56\u9879\uff0c\u4f60\u5c31\u53ef\u4ee5\u5728 configure.swift \u6587\u4ef6\u4e2d\uff0c\u4f7f\u7528 app.databases.use \u6765\u914d\u7f6e\u6570\u636e\u5e93\u3002 import Fluent import FluentSQLiteDriver app . databases . use (. sqlite (. file ( \"db.sqlite\" )), as : . sqlite ) \u4f60\u4e5f\u53ef\u4ee5\u914d\u7f6eSQLite\u5c06\u6570\u636e\u5e93\u4e34\u65f6\u5b58\u50a8\u5728\u5185\u5b58\u4e2d\u3002 app . databases . use (. sqlite (. memory ), as : . sqlite ) \u5982\u679c\u4f60\u4f7f\u7528\u5185\u5b58\u6570\u636e\u5e93\uff0c\u8bf7\u786e\u4fdd\u5c06Fluent\u8bbe\u7f6e\u4e3a\u81ea\u52a8\u8fc1\u79fb(migration)\uff0c\u5728\u6dfb\u52a0\u8fc1\u79fb\u540e\uff0c\u53ef\u4ee5\u5728\u547d\u4ee4\u884c\u4e2d\u4f7f\u7528\u53c2\u6570 --auto-migrate \u6216\u8005\u4ee3\u7801\u4e2d\u8fd0\u884c app.autoMigrate() \u3002 app . migrations . add ( CreateTodo ()) try app . autoMigrate (). wait () MySQL \u00b6 MySQL\u662f\u4e00\u4e2a\u6d41\u884c\u7684\u5f00\u6e90\u6570\u636e\u5e93\u3002\u5b83\u53ef\u4ee5\u5728\u5927\u591a\u6570\u4e91\u6258\u7ba1\u63d0\u4f9b\u5546\u4e0a\u83b7\u5f97.\u8fd9\u4e2a\u9a71\u52a8\u4e5f\u652f\u6301MariaDB. \u8981\u4f7f\u7528 MySQL, \u9700\u8981\u6dfb\u52a0\u4e0b\u5217\u4f9d\u8d56\u9879\u5230\u4f60\u7684\u5305\u4e2d. . package ( url : \"https://github.com/vapor/fluent-mysql-driver.git\" , from : \"4.0.0-beta\" ) . product ( name : \"FluentMySQLDriver\" , package : \"fluent-mysql-driver\" ) \u4e00\u65e6\u6dfb\u52a0\u4e86\u4f9d\u8d56\u9879\uff0c\u4f60\u5c31\u53ef\u4ee5\u5728 configure.swift \u6587\u4ef6\u4e2d\uff0c\u4f7f\u7528 app.databases.use \u6765\u914d\u7f6e\u6570\u636e\u5e93\u51ed\u8bc1\u3002 import Fluent import FluentMySQLDriver app . databases . use (. mysql ( hostname : \"localhost\" , username : \"vapor\" , password : \"vapor\" , database : \"vapor\" ), as : . mysql ) \u4f60\u4e5f\u53ef\u4ee5\u4ece\u6570\u636e\u5e93\u8fde\u63a5\u5b57\u7b26\u4e32\u4e2d\u89e3\u6790\u51ed\u8bc1. try app . databases . use (. mysql ( url : \"<connection string>\" ), as : . mysql ) Models \u00b6 \u6a21\u578b\u8868\u793a\u6570\u636e\u5e93\u4e2d\u56fa\u5b9a\u7684\u6570\u636e\u7ed3\u6784\uff0c\u5982\u8868\u6216\u96c6\u5408\u3002 \u6a21\u578b\u6709\u4e00\u4e2a\u6216\u591a\u4e2a\u5b58\u50a8\u53ef\u7f16\u7801\u503c\u7684\u5b57\u6bb5\u3002 \u6240\u6709\u7684\u6a21\u578b\u90fd\u6709\u552f\u4e00\u7684\u6807\u8bc6\u7b26\u3002 \u901a\u8fc7\u4f7f\u7528\u5c5e\u6027\u5305\u88c5\u5668\u6765\u8868\u793a\u6807\u8bc6\u7b26\u548c\u5b57\u6bb5\u4ee5\u53ca\u540e\u9762\u63d0\u5230\u7684\u66f4\u590d\u6742\u7684\u6620\u5c04\u3002 \u770b\u770b\u4e0b\u9762\u7684\u6a21\u578b\uff0c\u5b83\u4ee3\u8868\u4e86\u4e00\u4e2a\u661f\u7cfb\u3002 final class Galaxy : Model { // \u8868\u6216\u96c6\u5408\u7684\u540d\u79f0. static let schema = \"galaxies\" // \u552f\u4e00\u6807\u8bc6\u7b26. @ ID ( key : . id ) var id : UUID ? // The Galaxy's name. @ Field ( key : \"name\" ) var name : String // \u521b\u5efa\u4e00\u4e2a\u7a7a\u7684\u3001\u65b0\u7684 Galaxy. init () { } // \u901a\u8fc7\u6240\u6709\u5c5e\u6027\u96c6\u5408\u521b\u5efa\u4e00\u4e2a\u65b0\u7684 Galaxy. init ( id : UUID ? = nil , name : String ) { self . id = id self . name = name } } \u8981\u521b\u5efa\u65b0\u7684\u6a21\u578b\uff0c\u8bf7\u521b\u5efa\u4e00\u4e2a\u9075\u5faa Model \u534f\u8bae\u7684\u65b0\u7c7b. Tip \u5efa\u8bae\u6807\u8bb0\u6a21\u578b\u7c7b\u4e3a final \uff0c\u4ee5\u63d0\u9ad8\u6027\u80fd\u548c\u7b80\u5316\u4e00\u81f4\u6027\u8981\u6c42\u3002 Model \u534f\u8bae\u7684\u7b2c\u4e00\u4e2a\u8981\u6c42\u662f\u9759\u6001\u5c5e\u6027 schema . static let schema = \"galaxies\" \u6b64\u5c5e\u6027\u544a\u8bc9Fluent\u8be5\u6a21\u578b\u5bf9\u5e94\u7684\u8868\u6216\u96c6\u5408\u3002\u6b64\u8868\u53ef\u4ee5\u662f\u6570\u636e\u5e93\u4e2d\u5df2\u7ecf\u5b58\u5728\u7684\u8868\uff0c\u4e5f\u53ef\u4ee5\u662f\u4f60\u5c06\u4f7f\u7528 migration \u521b\u5efa\u7684. \u5b83\u4e00\u822c\u4f7f\u7528 snake_case \u547d\u540d\u6cd5\u4e14\u4e3a\u590d\u6570. \u6807\u8bc6\u7b26 \u00b6 \u4e0b\u4e00\u4e2a\u8981\u6c42\u5c31\u662f\u4e00\u4e2a\u540d\u4e3a id \u7684\u6807\u8bc6\u7b26\u5b57\u6bb5\u3002 @ ID ( key : . id ) var id : UUID ? \u8fd9\u4e2a\u5b57\u6bb5\u5fc5\u987b\u4f7f\u7528 @ID \u5c5e\u6027\u5305\u88c5\u5668\u3002Fluent\u63a8\u8350\u4f7f\u7528 UUID \u548c \u4e13\u95e8\u7684 .id \u5b57\u6bb5key\uff0c\u56e0\u4e3a\u5b83\u517c\u5bb9\u6240\u6709\u7684Fluent\u9a71\u52a8. If you want to use a custom ID key or type, use the @ID(custom:) overload. \u5982\u679c\u8981\u4f7f\u7528\u81ea\u5b9a\u4e49\u7684ID key\u6216\u7c7b\u578b\uff0c\u8bf7\u4f7f\u7528 @ID(custom:) \u91cd\u8f7d\u3002 \u5b57\u6bb5 \u00b6 \u5728\u6dfb\u52a0\u4e86\u6807\u8bc6\u7b26\u4e4b\u540e\uff0c\u4f60\u53ef\u4ee5\u6dfb\u52a0\u8bb8\u591a\u4f60\u60f3\u5b58\u50a8\u7684\u4fe1\u606f\u7684\u5b57\u6bb5\u3002\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u6dfb\u52a0\u4e86\u4e00\u4e2a\u5b57\u6bb5\u4f5c\u4e3a\u661f\u7cfb\u7684\u540d\u79f0 @ Field ( key : \"name\" ) var name : String \u5bf9\u4e8e\u5355\u4e2a\u5b57\u6bb5\uff0c\u4f7f\u7528 @Field \u5c5e\u6027\u5305\u88c5\u5668\u3002\u7c7b\u4f3c\u4e8e @ID \uff0c key \u53c2\u6570\u6307\u5b9a\u6570\u636e\u5e93\u4e2d\u5b57\u6bb5\u7684\u540d\u79f0\u3002\u5bf9\u4e8e\u6570\u636e\u5e93\u5b57\u6bb5\u547d\u540d\u7684\u7ea6\u5b9a\u4e0eswift\u4e2d\u4e0d\u540c\u7684\u60c5\u51b5\uff0c\u8fd9\u4e00\u70b9\u7279\u522b\u6709\u7528\u3002\u6bd4\u5982\u4f7f\u7528 snake_case \u800c\u4e0d\u662f camelCase \u3002 \u4e0b\u4e00\u6b65\uff0c\u6240\u6709\u7684\u6a21\u578b\u90fd\u8981\u6c42\u4e00\u4e2a\u7a7a\u7684\u521d\u59cb\u5316\u5668\uff0c\u8fd9\u5141\u8bb8Fluent\u6765\u521b\u5efa\u8be5\u6a21\u578b\u7684\u65b0\u5b9e\u4f8b\u3002 init () { } \u6700\u540e\uff0c\u4f60\u53ef\u4ee5\u4e3a\u4f60\u7684\u6a21\u578b\u6dfb\u52a0\u4e00\u4e2a\u4fbf\u5229\u6784\u9020\u5668\uff0c\u4ee5\u8bbe\u7f6e\u5b83\u6240\u6709\u7684\u5c5e\u6027\u3002 init ( id : UUID ? = nil , name : String ) { self . id = id self . name = name } \u4f7f\u7528\u4fbf\u5229\u6784\u9020\u5668\u662f\u975e\u5e38\u6709\u7528\u7684\uff0c\u5f53\u4f60\u6dfb\u52a0\u65b0\u7684\u5b57\u6bb5\u5230\u4f60\u7684\u6a21\u578b\u4e2d\uff0c\u5982\u679c\u521d\u59cb\u5316\u65b9\u6cd5\u53d1\u751f\u53d8\u5316\uff0c\u4f60\u53ef\u4ee5\u83b7\u5f97\u7f16\u8bd1\u65f6\u9519\u8bef\u3002\u8fc1\u79fb\u5bf9\u4e8e\u53d1\u9001 \u8fc1\u79fb \u00b6 \u5982\u679c\u6570\u636e\u5e93\u4f7f\u7528\u9884\u5b9a\u4e49schemas(\u5982SQL \u6570\u636e\u5e93),\u4f60\u9700\u8981\u4e00\u4e2a\u8fc1\u79fb(migration)\u6765\u4e3a\u6a21\u578b\u51c6\u5907\u6570\u636e\u5e93\u3002\u8fc1\u79fb\u5bf9\u4e8e\u6570\u636e\u5e93\u6570\u636e\u586b\u5145(seeding)\u4e5f\u975e\u5e38\u6709\u7528\u3002\u8981\u521b\u5efa\u4e00\u4e2a\u8fc1\u79fb\uff0c\u9700\u8981\u5b9a\u4e49\u4e00\u4e2a\u65b0\u7684\u7c7b\u578b\uff0c\u9075\u5faa Migration \u534f\u8bae\u3002\u770b\u770b\u4e0b\u9762\u4e3a\u5148\u524d\u5b9a\u4e49\u7684 Galaxy \u6a21\u578b\u7684\u8fc1\u79fb\u3002 struct CreateGalaxy : Migration { // \u51c6\u5907\u7528\u4e8e\u5b58\u50a8Galaxy\u6a21\u578b\u7684\u6570\u636e\u5e93\u3002 func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"galaxies\" ) . id () . field ( \"name\" , . string ) . create () } // \u53ef\u9009\u7684\u6062\u590d\u5728\u51c6\u5907\u65b9\u6cd5\u4e2d\u6240\u4f5c\u7684\u4fee\u6539\u3002 func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"galaxies\" ). delete () } } prepare \u65b9\u6cd5\u7528\u4e8e\u51c6\u5907\u5b58\u50a8 Galaxy \u7684\u6570\u636e\u5e93\u3002 Schema \u00b6 \u5728\u8fd9\u4e2a\u65b9\u6cd5\u91cc, database.schema(_:) \u7528\u6765\u521b\u5efa\u4e00\u4e2a\u65b0\u7684 SchemaBuilder \u3002 \u4e00\u4e2a\u6216\u591a\u4e2a field \u5c06\u88ab\u6dfb\u52a0\u5230\u8fd9\u4e2abuilder\uff0c\u5728\u8c03\u7528 create() \u521b\u5efa schema\u4e4b\u524d. \u6dfb\u52a0\u5230builder\u4e2d\u7684\u6bcf\u4e00\u4e2a\u5b57\u6bb5\u90fd\u6709\u4e00\u4e2a\u540d\u79f0\uff0c\u7c7b\u578b\uff0c\u548c\u53ef\u9009\u7684\u7ea6\u675f\u3002 field (< name >, < type >, < optional constraints >) \u8fd9\u91cc\u6709\u4e2a\u4fbf\u5229\u7684 id() \u65b9\u6cd5\uff0c\u4f7f\u7528Fluent\u63a8\u8350\u7684\u9ed8\u8ba4\u503c\uff0c\u6765\u6dfb\u52a0 @ID \u5c5e\u6027\uff0c \u8fd8\u539f\u8fc1\u79fb\u53ef\u4ee5\u64a4\u9500\u5728prepare\u65b9\u6cd5\u4e2d\u6240\u4f5c\u7684\u4efb\u4f55\u66f4\u6539\uff0c\u5728\u672c\u4f8b\u4e2d\uff0c\u53ea\u662f\u5220\u9664Galaxy\u6a21\u578b\u7684schema\u3002 \u4e00\u65e6\u5b9a\u4e49\u4e86\u8fc1\u79fb\uff0c\u4f60\u9700\u8981\u5728 configure.swift \u6587\u4ef6\u4e2d\uff0c\u5c06\u5b83\u6dfb\u52a0\u8fdb app.migrations \uff0c\u6765\u544a\u8bc9Fluent\u3002 app . migrations . add ( CreateGalaxy ()) Migrate \u00b6 \u8981\u6267\u884c\u8fc1\u79fb\uff0c\u5728\u547d\u4ee4\u884c\u4e2d\u8c03\u7528 vapor run migrate \u6216\u8005\u6dfb\u52a0 migrate \u4f5c\u4e3aXcode\u8fd0\u884c\u65b9\u6848\u7684\u4e00\u4e2a\u53c2\u6570\u3002 $ vapor run migrate Migrate Command: Prepare The following migration(s) will be prepared: + CreateGalaxy on default Would you like to continue? y/n> y Migration successful \u67e5\u8be2 \u00b6 \u73b0\u5728\u4f60\u5df2\u7ecf\u6210\u529f\u7684\u521b\u5efa\u4e86\u4e00\u4e2a\u6a21\u578b\uff0c\u5e76\u4e14\u8fc1\u79fb\u5230\u4e86\u6570\u636e\u5e93\uff0c\u4f60\u53ef\u4ee5\u8fdb\u884c\u7b2c\u4e00\u6b21\u67e5\u8be2\u4e86\u3002 All \u00b6 \u4e0b\u9762\u7684\u8def\u7531\uff0c\u5b83\u5c06\u4f1a\u8fd4\u56de\u6570\u636e\u5e93\u4e2d\u5305\u542b\u6240\u6709\u661f\u7cfb\u7684\u4e00\u4e2a\u6570\u7ec4\u3002 app . get ( \"galaxies\" ) { req in Galaxy . query ( on : req . db ). all () } \u4e3a\u4e86\u76f4\u63a5\u5728\u8def\u7531\u7684\u95ed\u5305\u4e2d\u76f4\u63a5\u8fd4\u56deGalaxy,\u9700\u8981\u5b83\u9075\u5faa Content \u534f\u8bae\u3002 final class Galaxy : Model , Content { ... } Galaxy.query \u4e3a\u6a21\u578b\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u67e5\u8be2\u6784\u5efa\u5668. req.db \u662f\u5bf9\u5e94\u7528\u7a0b\u5e8f\u9ed8\u8ba4\u6570\u636e\u5e93\u7684\u5f15\u7528. \u6700\u7ec8, all() \u8fd4\u56de\u5b58\u50a8\u5728\u6570\u636e\u5e93\u4e2d\u7684\u6240\u6709\u6a21\u578b\u3002 \u7f16\u8bd1\u5e76\u8fd0\u884c\u9879\u76ee\uff0c\u5e76\u4e14\u8bf7\u6c42 GET /galaxies \uff0c\u4f60\u5e94\u8be5\u770b\u5230\u8fd4\u56de\u4e86\u4e00\u4e2a\u7a7a\u6570\u7ec4\u3002\u8ba9\u6211\u4eec\u6dfb\u52a0\u4e00\u6761\u521b\u5efa\u661f\u7cfb\u7684\u8def\u7531\u3002 Create \u00b6 \u6839\u636eRESTful\u98ce\u683c, \u4f7f\u7528 POST /galaxies \u521b\u5efa\u4e00\u4e2a\u661f\u7cfb. \u56e0\u4e3a\u6a21\u578b\u662f\u53ef\u7f16\u7801\u7684\uff0c\u6240\u4ee5\u4f60\u53ef\u4ee5\u76f4\u63a5\u4ece\u8bf7\u6c42\u4f53\u4e2d\u89e3\u7801\u661f\u7cfb\u3002 app . post ( \"galaxies\" ) { req -> EventLoopFuture < Galaxy > in let galaxy = try req . content . decode ( Galaxy . self ) return galaxy . create ( on : req . db ) . map { galaxy } } Seealso \u6709\u5173\u8bf7\u6c42\u4f53\u89e3\u7801\u7684\u66f4\u591a\u4fe1\u606f\u8bf7\u53c2\u9605 Content \u2192 Overview . \u4e00\u65e6\u4f60\u6709\u4e86model\u7684\u5b9e\u4f8b\uff0c\u8c03\u7528 create(on:) \u5c06\u6a21\u578b\u4fdd\u5b58\u5230\u6570\u636e\u5e93\u3002\u8fd9\u8fd4\u56de\u4e00\u4e2a EventLoopFuture<Void> \uff0c\u5b83\u6307\u793a\u4fdd\u5b58\u5df2\u7ecf\u5b8c\u6210\u3002\u4fdd\u5b58\u5b8c\u6210\u540e\uff0c\u4f7f\u7528 map \u8fd4\u56de\u65b0\u521b\u5efa\u7684\u6a21\u578b \u7f16\u8bd1\u5e76\u8fd0\u884c\u9879\u76ee\uff0c\u5e76\u4e14\u53d1\u9001\u4e0b\u9762\u7684\u8bf7\u6c42\u3002 POST /galaxies HTTP / 1.1 content-length : 21 content-type : application/json { \"name\" : \"Milky Way\" } \u4f60\u5e94\u8be5\u83b7\u5f97\u4e0b\u9762\u7684\u54cd\u5e94\uff0c\u5e26\u6709id\u6807\u8bc6\u7b26\u7684\u65b0\u5efa\u6a21\u578b\u3002 { \"id\" : ... , \"name\" : \"Milky Way\" } \u73b0\u5728\uff0c\u5982\u679c\u4f60\u518d\u6b21\u67e5\u8be2 GET /galaxies \uff0c\u4f60\u5e94\u8be5\u770b\u5230\u65b0\u5efa\u7684\u661f\u7cfb\u5728\u6570\u7ec4\u4e2d\u3002 \u5173\u7cfb \u00b6 \u6ca1\u6709\u661f\u661f\u7684\u661f\u7cfb\uff01\u8ba9\u6211\u4eec\u901a\u8fc7\u5728 Galaxy \u548c\u4e00\u4e2a\u65b0\u7684 Star \u6a21\u578b\u4e4b\u95f4\u6dfb\u52a0\u4e00\u5bf9\u591a\u5173\u7cfb\uff0c\u6765\u5feb\u901f\u67e5\u770bFluent\u5f3a\u5927\u7684\u5173\u7cfb\u7279\u6027\u3002 final class Star : Model , Content { // \u8868\u6216\u96c6\u5408\u7684\u540d\u79f0 static let schema = \"stars\" // Star\u7684\u552f\u4e00\u6807\u8bc6\u7b26. @ ID ( key : . id ) var id : UUID ? // Star\u7684\u540d\u79f0. @ Field ( key : \"name\" ) var name : String // \u5efa\u7acb\u5173\u7cfb\uff0c\u661f\u661f\u5728\u661f\u7cfb\u4e2d @ Parent ( key : \"galaxy_id\" ) var galaxy : Galaxy // Creates a new, empty Star. init () { } // Creates a new Star with all properties set. init ( id : UUID ? = nil , name : String , galaxyID : UUID ) { self . id = id self . name = name self . $ galaxy . id = galaxyID } } Parent \u00b6 \u65b0\u7684 Star \u6a21\u578b\u4e0e Galaxy \u975e\u5e38\u76f8\u4f3c\uff0c\u9664\u4e86\u4e00\u4e2a\u65b0\u7684\u5b57\u6bb5\u7c7b\u578b\uff1a @Parent \u3002 @ Parent ( key : \"galaxy_id\" ) var galaxy : Galaxy perent\u5c5e\u6027\u662f\u4e00\u4e2a\u5b58\u50a8\u53e6\u5916\u4e00\u4e2a\u6a21\u578b\u6807\u8bc6\u7b26\u7684\u5b57\u6bb5\u3002\u4fdd\u5b58\u5173\u7cfb\u7684\u6a21\u578b\u6210\u4e3a\"\u5b50\"\uff0c\u5f15\u7528\u7684\u6a21\u578b\u79f0\u4e3a\u201c\u7236\u201d\u3002\u8fd9\u79cd\u7c7b\u578b\u7684\u5173\u7cfb\u4e5f\u88ab\u79f0\u4e3a\u201c\u4e00\u5bf9\u591a\u201d\u3002 key \u5c5e\u6027\u6307\u5b9a\u5e94\u7528\u4e8e\u6570\u636e\u5e93\u4e2d\u5b58\u50a8\u7236\u952e\u7684\u5b57\u6bb5\u540d\u3002 \u5728\u521d\u59cb\u5316\u65b9\u6cd5\u4e2d\uff0c\u7236\u6807\u8bc6\u7b26\u901a\u8fc7 $galaxy \u8bbe\u7f6e\u3002 self . $ galaxy . id = galaxyID \u901a\u8fc7\u5728\u7236\u5c5e\u6027\u7684\u540d\u79f0\u4f7f\u7528 $ \u524d\u7f00\uff0c\u4f60\u53ef\u4ee5\u8bbf\u95ee\u5e95\u5c42\u7684\u5c5e\u6027\u5305\u88c5\u5668\u3002\u8fd9\u662f\u9700\u8981\u8bbf\u95ee\u5185\u90e8\u7684 @Field \uff0c\u6765\u5b58\u50a8\u5b9e\u9645\u7684\u6807\u8bc6\u7b26\u503c\u3002 Seealso \u67e5\u770b\u6709\u5173\u5c5e\u6027\u5305\u88c5\u5668\u7684swift\u6f14\u8fdb\u5efa\u8bae\u4ee5\u83b7\u53d6\u66f4\u591a\u4fe1\u606f: [SE-0258] Property Wrappers \u63a5\u4e0b\u6765\uff0c\u521b\u5efa\u4e00\u4e2a\u8fc1\u79fb\u6765\u51c6\u5907\u6570\u636e\u5e93\u5904\u7406 Star \u3002 struct CreateStar : Migration { // Prepares the database for storing Star models. func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"stars\" ) . id () . field ( \"name\" , . string ) . field ( \"galaxy_id\" , . uuid , . references ( \"galaxies\" , \"id\" )) . create () } // Optionally reverts the changes made in the prepare method. func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"stars\" ). delete () } } \u8fd9\u5927\u90e8\u5206\u662f\u4e0eGalaxy\u7684\u8fc1\u79fb\u4e00\u6837\u7684\uff0c\u9664\u4e86\u589e\u52a0\u4e86\u4e2a\u5b57\u6bb5\u6765\u5b58\u50a8\u7236\u661f\u7cfb\u7684\u6807\u8bc6\u7b26\u3002 field ( \"galaxy_id\" , . uuid , . references ( \"galaxies\" , \"id\" )) \u8fd9\u4e2a\u5b57\u6bb5\u6307\u5b9a\u4e86\u4e00\u4e2a\u53ef\u9009\u7684\u7ea6\u675f\uff0c\u544a\u77e5\u6570\u636e\u5e93\u8fd9\u4e2a\u5b57\u6bb5\u7684\u503c\uff0c\u5f15\u7528\u201cgalaxies\u201dschema\u4e2d\u7684\u201cid\u201d\u5b57\u6bb5\u3002\u8fd9\u4e5f\u53ef\u4ee5\u79f0\u4e3a\u5916\u952e\uff0c\u6709\u52a9\u4e8e\u786e\u4fdd\u6570\u636e\u7684\u5b8c\u6574\u6027\u3002 \u4e00\u65e6\u521b\u5efa\u4e86\u8fc1\u79fb\uff0c\u628a\u5b83\u6dfb\u52a0\u5230 app.migrations \uff0c\u5e76\u5728 CreateGalaxy \u8fc1\u79fb\u7684\u540e\u9762\u3002 app . migrations . add ( CreateGalaxy ()) app . migrations . add ( CreateStar ()) \u7531\u4e8e\u8fc1\u79fb\u662f\u6709\u5e8f\u8fd0\u884c\u7684\uff0c CreateStar \u5f15\u7528\u4e86galaxies schema\uff0c\u6240\u4ee5\u6392\u5e8f\u5f88\u91cd\u8981\u3002\u6700\u7ec8\uff0c Since migrations run in order, and CreateStar references the galaxies schema, ordering is important. Finally, \u8fd0\u884c\u8fc1\u79fb \u6765\u51c6\u5907\u6570\u636e\u5e93. \u6dfb\u52a0\u4e00\u4e2a\u8def\u7531\u6765\u521b\u5efa\u65b0\u7684\u661f\u661f\u3002 app . post ( \"stars\" ) { req -> EventLoopFuture < Star > in let star = try req . content . decode ( Star . self ) return star . create ( on : req . db ) . map { star } } \u4f7f\u7528\u4ee5\u4e0bHTTP\u8bf7\u6c42\u521b\u5efa\u5f15\u7528\u5148\u524d\u521b\u5efa\u7684\u661f\u7cfb\u7684\u65b0\u661f\u661f\u3002 POST /stars HTTP / 1.1 content-length : 36 content-type : application/json { \"name\" : \"Sun\" , \"galaxy\" : { \"id\" : ... } } \u4f60\u5e94\u8be5\u770b\u5230\u8fd4\u56de\u4e86\u4e00\u4e2a\u5e26\u6709\u552f\u4e00\u6807\u8bc6\u7b26\u7684\u65b0\u661f\u661f\u3002 { \"id\" : ... , \"name\" : \"Sun\" , \"galaxy\" : { \"id\" : ... } } Children \u00b6 \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u6765\u770b\u770b\u5982\u4f55\u5229\u7528Fluent\u7684\u8d2a\u5a6a\u52a0\u8f7d\uff08eager-loading\uff09\u7279\u6027\uff0c\u5728 GET /galaxies \u8def\u7531\u4e2d\u81ea\u52a8\u8fd4\u56de\u661f\u7cfb\u4e2d\u7684\u661f\u661f\u3002 \u6dfb\u52a0\u4e0b\u9762\u5c5e\u6027\u5230 Galaxy \u6a21\u578b\u3002 // Galaxy\u6240\u6709\u7684Star. @ Children ( for : \\ . $ galaxy ) var stars : [ Star ] @Children \u5c5e\u6027\u5305\u88c5\u5668\u548c @Parent \u76f8\u53cd\u3002\u5b83\u9700\u8981\u4e00\u4e2a\u952e\u8def\u5f84\u5230\u5b50\u6a21\u578b\u7684 @Parent \u5b57\u6bb5\u4f5c\u4e3a for \u53c2\u6570\u3002\u5b83\u7684\u503c\u662f\u4e00\u4e2a\u5b50\u6a21\u578b\u7684\u6570\u7ec4\uff0c\u56e0\u4e3a\u53ef\u80fd\u5b58\u57280\u4e2a\u6216\u591a\u4e2a\u5b50\u6a21\u578b\u3002Galaxy\u7684\u8fc1\u79fb\u4e0d\u9700\u8981\u505a\u4efb\u4f55\u4fee\u6539\uff0c\u56e0\u4e3a\u8fd9\u79cd\u5173\u7cfb\u6240\u9700\u7684\u6240\u6709\u4fe1\u606f\u90fd\u5b58\u50a8\u5728\u5b50\u6a21\u578b Star \u4e0a\u3002 \u8d2a\u5a6a\u52a0\u8f7d(Eager Load) \u00b6 \u73b0\u5728\u5173\u7cfb\u5df2\u7ecf\u5b8c\u6210\u4e86\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528 with \u65b9\u6cd5\u6765\u81ea\u52a8\u83b7\u53d6\u548c\u5e8f\u5217\u5316\u661f\u7cfb-\u661f\u7684\u5173\u7cfb\u3002 app . get ( \"galaxies\" ) { req in Galaxy . query ( on : req . db ). with ( \\ . $ stars ). all () } @Children \u5173\u7cfb\u7684\u952e\u8def\u5f84\u88ab\u4f20\u9012\u7ed9 with \uff0c\u544a\u8bc9Fluent\u5728\u6240\u6709\u751f\u6210\u7684\u6a21\u578b\u4e2d\u81ea\u52a8\u52a0\u8f7d\u6b64\u5173\u7cfb\u3002\u8fd0\u884c\u9879\u76ee\uff0c\u5e76\u53d1\u8d77\u8bf7\u6c42 GET /galaxies \u3002\u4f60\u4f1a\u770b\u5230\u6240\u6709\u7684\u661f\u5df2\u7ecf\u81ea\u52a8\u5305\u542b\u5728\u54cd\u5e94\u4e2d\u3002 [ { \"id\" : ... , \"name\" : \"Milky Way\" , \"stars\" : [ { \"id\" : ... , \"name\" : \"Sun\" , \"galaxy\" : { \"id\" : ... } } ] } ] Siblings \u00b6 \u6700\u540e\u4e00\u79cd\u5173\u7cfb\u662f\u591a\u5bf9\u591a\uff0c\u6216\u79f0\u4e3a\u5144\u5f1f\u5173\u7cfb\u3002\u521b\u5efa\u4e00\u4e2a Tag \u6a21\u578b\uff0c\u5305\u542b id \u548c name \u5b57\u6bb5\uff0c\u6211\u4eec\u5c06\u7528\u5b83\u6765\u6807\u8bb0\u5177\u6709\u67d0\u4e9b\u7279\u5f81\u7684\u661f\u3002 final class Tag : Model , Content { // Name of the table or collection. static let schema : String = \"tags\" // Unique identifier for this Tag. @ ID ( key : . id ) var id : UUID ? // The Tag's name. @ Field ( key : \"name\" ) var name : String // Creates a new, empty Tag. init () {} // Creates a new Tag with all properties set. init ( id : UUID ? = nil , name : String ) { self . id = id self . name = name } } \u4e00\u4e2a\u6807\u7b7e\u53ef\u4ee5\u6709\u5f88\u591a\u661f\uff0c\u4e00\u4e2a\u661f\u53ef\u4ee5\u6709\u5f88\u591a\u6807\u7b7e\uff0c\u5b83\u4eec\u662f\u5144\u5f1f\u5173\u7cfb\u3002\u4e24\u4e2a\u6a21\u578b\u4e4b\u95f4\u7684\u5144\u5f1f\u5173\u7cfb\u9700\u8981\u7b2c\u4e09\u4e2a\u6a21\u578b\uff08\u79f0\u4e4b\u4e3apivot\uff09\u6765\u4fdd\u5b58\u5173\u7cfb\u6570\u636e\u3002\u6bcf\u4e00\u4e2a StarTag \u6a21\u578b\u5bf9\u8c61\u8868\u793a\u5355\u4e2a\u7684\u661f\u5bf9\u6807\u7b7e\u7684\u5173\u7cfb\uff0c\u6301\u6709\u4e00\u4e2a Star \u548c Tag \u7684id\u3002 final class StarTag : Model { // Name of the table or collection. static let schema : String = \"star_tag\" // Unique identifier for this pivot. @ ID ( key : . id ) var id : UUID ? // Reference to the Tag this pivot relates. @ Parent ( key : \"tag_id\" ) var tag : Tag // Reference to the Star this pivot relates. @ Parent ( key : \"star_id\" ) var star : Star // Creates a new, empty pivot. init () {} // Creates a new pivot with all properties set. init ( tagID : UUID , starID : UUID ) { self . $ tag . id = tagID self . $ star . id = starID } } \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u66f4\u65b0\u65b0\u7684 Tag \u6a21\u578b\uff0c\u5728\u5176\u4e2d\u6dfb\u52a0\u4e00\u4e2a stars \u5c5e\u6027\uff0c\u8868\u793a\u8fd9\u4e2a\u6807\u7b7e\u4e0b\u7684\u6240\u6709\u661f\u661f\u3002 @ Siblings ( through : StarTag . self , from : \\ . $ tag , to : \\ . $ star ) var stars : [ Star ] @Siblings \u5c5e\u6027\u5305\u88c5\u5668\u9700\u8981\u4e09\u4e2a\u53c2\u6570\u3002\u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u5148\u524d\u521b\u5efa\u7684pivot\u6a21\u578b StarTag \u3002\u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u662fpivot\u6a21\u578b\u7236\u5173\u7cfb\u7684\u952e\u8def\u5f84\u3002 from \u952e\u8def\u5f84\u662fpivot\u6a21\u578b\u4e0e\u5f53\u524d\u6a21\u578b\u7684\u7236\u5173\u7cfb\uff0c\u5728\u8fd9\u91cc\u662f Tag \u3002 to \u952e\u8def\u5f84\u662fpivot\u6a21\u578b\u4e0e\u53e6\u4e00\u4e2a\u76f8\u5173\u6a21\u578b\u7684\u7236\u5173\u7cfb\uff0c\u5728\u8fd9\u91cc\u662f Star \u3002 \u8fd9\u4e09\u4e2a\u53c2\u6570\u7ed3\u5408\u5728\u4e00\u8d77\uff0c\u5f62\u6210\u4e00\u4e2a\u5173\u7cfb\uff1a\u4ece\u5f53\u524d\u7684\u6a21\u578b Tag \uff0c\u7a7f\u8fc7pivot\u6a21\u578b StarTag \uff0c\u5230\u6240\u671f\u671b\u7684\u6a21\u578b Star \u3002 \u73b0\u5728\u8ba9\u6211\u4eec\u66f4\u65b0 Star \u6a21\u578b\uff0c\u6765\u521b\u5efa\u4e00\u6761\u548c\u4e0a\u9762\u76f8\u53cd\u7684\u8def\u7ebf\u7684\u5173\u7cfb: @ Siblings ( through : StarTag . self , from : \\ . $ star , to : \\ . $ tag ) var tags : [ Tag ] \u8fd9\u4e9b\u5144\u5f1f\u5173\u7cfb\u5c5e\u6027\u4f9d\u8d56\u4e8e StarTag \u5b58\u50a8\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u9700\u8981\u66f4\u65b0 Star \u8fc1\u79fb\uff0c\u4f46\u662f\u6211\u4eec\u9700\u8981\u4e3a Tag \u548c StarTag \u521b\u5efa\u8fc1\u79fb: struct CreateTag : Migration { func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"tags\" ) . id () . field ( \"name\" , . string ) . create () } func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"tags\" ). delete () } } struct CreateStarTag : Migration { func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"star_tag\" ) . id () . field ( \"star_id\" , . uuid , . required , . references ( \"star\" , \"id\" )) . field ( \"tag_id\" , . uuid , . required , . references ( \"star\" , \"id\" )) . create () } func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"star_tag\" ). delete () } } \u7136\u540e\u5728configure.swift\u4e2d\u6dfb\u52a0\u8fc1\u79fb: app . migrations . add ( CreateTag ()) app . migrations . add ( CreateStarTag ()) \u73b0\u5728\u6211\u4eec\u60f3\u7ed9\u661f\u52a0\u6807\u7b7e\uff0c\u521b\u5efa\u4e00\u4e2a\u8def\u7531\u7528\u6765\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u6807\u7b7e\uff0c\u4e4b\u540e\u6211\u4eec\u9700\u8981\u521b\u5efa\u5c06\u6807\u7b7e\u6dfb\u52a0\u5230\u661f\u7684\u8def\u7531\u3002 app . post ( \"star\" , \":starID\" , \"tag\" , \":tagID\" ) { req -> EventLoopFuture < HTTPStatus > in let star = Star . find ( req . parameters . get ( \"starID\" ), on : req . db ) . unwrap ( or : Abort (. notFound )) let tag = Tag . find ( req . parameters . get ( \"tagID\" ), on : req . db ) . unwrap ( or : Abort (. notFound )) return star . and ( tag ). flatMap { ( star , tag ) in star . $ tags . attach ( tag , on : req . db ) }. transform ( to : . ok ) } \u8fd9\u4e2a\u8def\u7531\u5305\u542b\u4e86\u661f\u548c\u6807\u7b7e\u7684id\u53c2\u6570\u7ec4\u4ef6\uff0c\u6211\u4eec\u5e0c\u671b\u5f7c\u6b64\u5173\u8054\u3002 \u5982\u679c\u6211\u4eec\u60f3\u8981\u5728id\u4e3a1\u7684\u661f\u548cid\u4e3a2\u7684\u6807\u7b7e\u4e4b\u95f4\u5efa\u7acb\u5173\u7cfb\uff0c\u6211\u4eec\u9700\u8981\u53d1\u9001 POST \u8bf7\u6c42\u5230 /star/1/tag/2 \uff0c\u4e14\u6211\u4eec\u4f1a\u6536\u5230\u4e00\u4e2aHttp\u54cd\u5e94\u7801\u3002 \u9996\u5148\uff0c\u6211\u4eec\u9700\u8981\u5728\u6570\u636e\u5e93\u4e2d\u67e5\u627e\u661f\u548c\u6807\u7b7e\uff0c\u4ee5\u786e\u4fdd\u8fd9\u4e9bid\u662f\u6709\u6548\u7684\u3002 \u7136\u540e\uff0c\u6211\u4eec\u901a\u8fc7\u628a\u8fd9\u4e2aid\u4e3a2\u7684\u6807\u7b7e\uff0c\u9644\u52a0\u5230id\u4e3a1\u7684\u661f\u7684\u6240\u6709\u6807\u7b7e\u91cc\u6765\u521b\u5efa\u8fd9\u4e2a\u5173\u7cfb\u3002 \u7531\u4e8e\u661f\u7684\u5c5e\u6027\u662f\u4e00\u4e2a\u4e0e\u53e6\u5916\u6a21\u578b\u7684\u5173\u7cfb\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4f7f\u7528 $ \u64cd\u4f5c\u7b26\uff0c\u6765\u8bbf\u95ee\u5b83\u7684\u5c5e\u6027\u5305\u88c5\u5668 @Siblings \u3002 \u5728\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u4e0d\u83b7\u53d6\u5144\u5f1f\u5173\u7cfb\uff0c\u5982\u679c\u6211\u4eec\u5e0c\u671b\u5305\u542b\u5b83\u4eec\uff0c\u5728\u67e5\u8be2\u7684\u65f6\u5019\u9700\u8981\u63d2\u5165 with \u65b9\u6cd5\u3002\u6240\u4ee5\u6211\u4eec\u9700\u8981\u66f4\u65b0\u83b7\u53d6\u6240\u6709\u661f\u7684\u8def\u7531: app . get ( \"stars\" ) { req in Star . query ( on : req . db ). with ( \\ . $ tags ). all () } \u751f\u547d\u5468\u671f \u00b6 \u8981\u521b\u5efa\u54cd\u5e94 Model \u4e0a\u7684\u4e8b\u4ef6\u94a9\u5b50\uff0c\u4f60\u53ef\u4ee5\u4e3a\u4f60\u7684\u6a21\u578b\u521b\u5efa\u4e2d\u95f4\u4ef6\uff0c\u4f60\u7684\u4e2d\u95f4\u4ef6\u5fc5\u987b\u9075\u5faa ModelMiddleware \u534f\u8bae. \u8fd9\u91cc\u4e00\u4e2a\u7b80\u5355\u7684\u4e2d\u95f4\u4ef6\u793a\u4f8b: struct GalaxyMiddleware : ModelMiddleware { // \u5f53\u6a21\u578b\u88ab\u521b\u5efa\u65f6\u6267\u884c\u3002 func create ( model : Galaxy , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { return next . create ( model , on : db ) } // \u5f53\u6a21\u578b\u66f4\u65b0\u65f6\u6267\u884c func update ( model : Galaxy , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { return next . update ( model , on : db ) } // \u5f53\u6a21\u578b\u8f6f\u5220\u9664\u65f6\u6267\u884c func softDelete ( model : Galaxy , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { return next . softDelete ( model , on : db ) } // \u5f53\u8fd8\u539f\u8f6f\u5220\u9664\u6a21\u578b\u7684\u65f6\u6267\u884c func restore ( model : Galaxy , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { return next . restore ( model , on : db ) } // \u5f53\u6a21\u578b\u5220\u9664\u65f6\u5019\u6267\u884c\u3002 // \u5982\u679c\"force\" \u53c2\u6570\u4e3atrue, \u6a21\u578b\u5c06\u88ab\u6c38\u4e45\u5220\u9664\u3002 // \u5373\u4f7f\u4f7f\u7528\u8f6f\u5220\u9664\u65f6\u95f4\u6233. func delete ( model : Galaxy , force : Bool , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { return next . delete ( model , force : force , on : db ) } } \u8fd9\u4e9b\u65b9\u6cd5\u4e2d\u7684\u6bcf\u4e00\u4e2a\u90fd\u6709\u4e00\u4e2a\u9ed8\u8ba4\u7684\u5b9e\u73b0\uff0c\u6240\u4ee5\u60a8\u53ea\u9700\u8981\u5305\u542b\u60a8\u9700\u8981\u7684\u65b9\u6cd5\u3002 \u4f60\u5e94\u8be5\u8fd4\u56de\u4e0b\u4e00\u4e2a AnyModelResponder \u76f8\u5e94\u7684\u65b9\u6cd5\uff0cFluent\u7ee7\u7eed\u5904\u7406\u4e8b\u4ef6\u3002 Important \u6b64\u4e2d\u95f4\u4ef6\u53ea\u54cd\u5e94\u8fd9\u4e9b\u51fd\u6570\u4e2d\u63d0\u4f9b\u7684 Model \u7c7b\u578b\u7684\u751f\u547d\u5468\u671f\u4e8b\u4ef6\u3002\u5728\u4e0a\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c GalaxyMiddleware \u5728Galaxy\u6a21\u578b\u4e0a\u54cd\u5e94\u4e8b\u4ef6\u3002 \u4f7f\u7528\u8fd9\u4e9b\u65b9\u6cd5\uff0c\u4f60\u53ef\u4ee5\u5728\u4e8b\u4ef6\u5b8c\u6210\u4e4b\u524d\u548c\u4e4b\u540e\u6267\u884c\u64cd\u4f5c\u3002\u5728\u4e8b\u4ef6\u5b8c\u6210\u540e\u6267\u884c\u64cd\u4f5c\uff0c\u53ef\u4ee5\u4f7f\u7528.flatMap() \u5728\u4ece\u4e0b\u4e00\u4e2a\u54cd\u5e94\u4e2d\u8fd4\u56de\u7684future\u4e2d\u6267\u884c.\u4f8b\u5982\uff1a struct GalaxyMiddleware : ModelMiddleware { func create ( model : Galaxy , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { // \u5728\u521b\u5efa\u6a21\u578b\u4e4b\u524d\uff0c\u53ef\u4ee5\u5728\u8fd9\u91cc\u4fee\u6539\u6a21\u578b\u3002 model . name = \"<New Galaxy Name>\" return next . create ( model , on : db ). flatMap { // \u4e00\u65e6\u521b\u5efa\u5b8c\u6210, \u8fd9\u91cc\u7684\u4ee3\u7801\u4f1a\u88ab\u6267\u884c print ( \"Galaxy \\( model . name ) was created\" ) } } } \u4e00\u65e6\u4f60\u521b\u5efa\u4e86\u4e2d\u95f4\u4ef6\uff0c\u4f60\u5fc5\u987b\u5c06\u5b83\u6ce8\u518c\u5728 Application \u7684\u6570\u636e\u5e93\u4e2d\u95f4\u4ef6\u914d\u7f6e\u4e2d\uff0c\u5728 configure.swift \u6587\u4ef6\u4e2d\u6dfb\u52a0: app . databases . middleware . use ( GalaxyMiddleware (), on : . psql ) Timestamps \u00b6 Fluent\u901a\u8fc7\u5728\u6a21\u578b\u4e2d\u6307\u5b9a Timestamp \u5b57\u6bb5\u6765\u8ddf\u8e2a\u6a21\u578b\u4e0a\u7684\u521b\u5efa\u548c\u66f4\u65b0\u65f6\u95f4\u3002 \u5f53\u9700\u8981\u65f6\uff0cFluent\u81ea\u52a8\u8bbe\u7f6e\u5b57\u6bb5\u3002\u4f60\u53ef\u4ee5\u8fd9\u6837\u6dfb\u52a0\uff1a @ Timestamp ( key : \"created_at\" , on : . create ) var createdAt : Date ? @ Timestamp ( key : \"updated_at\" , on : . update ) var updatedAt : Date ? Info \u60a8\u53ef\u4ee5\u4e3a\u8fd9\u4e9b\u5b57\u6bb5\u4f7f\u7528\u4efb\u4f55\u540d\u79f0/\u952e. created_at / updated_at , \u53ea\u662f\u4e3a\u4e86\u8bf4\u660e\u76ee\u7684\u3002 \u5728\u8fc1\u79fb\u4e2d\u6dfb\u52a0\u65f6\u95f4\u6233\u5b57\u6bb5\u4f7f\u7528 .datetime \u7c7b\u578b\u3002 database . schema (...) ... . field ( \"created_at\" , . datetime ) . field ( \"updated_at\" , . datetime ) . create () Soft Delete \u00b6 \u8f6f\u5220\u9664\u5728\u6570\u636e\u5e93\u5c06\u9879\u76ee\u6807\u8bb0\u4e3a\u5df2\u5220\u9664\uff0c\u4f46\u5b9e\u9645\u4e0a\u5e76\u6ca1\u6709\u5220\u9664\u5b83\u3002 \u5f53\u4f60\u6709\u6570\u636e\u4fdd\u7559\u9700\u6c42\u65f6\uff0c\u8fd9\u53ef\u80fd\u662f\u6709\u7528\u7684\u3002 \u5728Fluent\u4e2d\uff0c\u5b83\u901a\u8fc7\u8bbe\u7f6e\u4e00\u4e2a\u5220\u9664\u65f6\u95f4\u6233\u6765\u5de5\u4f5c\u3002 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u8f6f\u5220\u9664\u9879\u4e0d\u4f1a\u51fa\u73b0\u5728\u67e5\u8be2\u4e2d\uff0c\u5e76\u4e14\u53ef\u4ee5\u968f\u65f6\u6062\u590d\u3002 Soft deletion marks an item as deleted in the database but doesn't actually remove it. This can be useful when you have data retention requirements, for example. In Fluent, it works by setting a deletion timestamp. By default, soft deleted items won't appear in queries and can be restored at any time. \u7c7b\u4f3c\u4e8e\u521b\u5efa\u548c\u66f4\u65b0\u65f6\u95f4\u6233\uff0c\u8981\u5728\u6a21\u578b\u4e2d\u542f\u7528\u8f6f\u5220\u9664\uff0c\u53ea\u9700\u8981\u5c06\u5220\u9664\u65f6\u95f4\u6233\u8bbe\u7f6e\u4e3a .delete : @ Timestamp ( key : \"deleted_at\" , on : . delete ) var deletedAt : Date ? \u8c03\u7528 Model.delete(on:) \u5220\u9664\u5177\u6709\u5220\u9664\u65f6\u95f4\u6233\u5c5e\u6027\u7684\u6a21\u578b\uff0c\u5c06\u81ea\u52a8\u8f6f\u5220\u9664\u5b83\u3002 \u5982\u679c\u4f60\u9700\u8981\u6267\u884c\u4e00\u4e2a\u67e5\u8be2\uff0c\u5305\u542b\u8f6f\u5220\u9664\u7684\u9879\u76ee\uff0c\u4f60\u53ef\u4ee5\u5728\u67e5\u8be2\u4e2d\u4f7f\u7528 withDeleted() // Get all galaxies including soft-deleted ones. Galaxy . query ( on : db ). withDeleted (). all () \u4f60\u53ef\u4ee5\u7528 restore(on:) \u65b9\u6cd5\u8fd8\u539f\u8f6f\u5220\u9664\u7684\u6a21\u578b: // Restore galaxy galaxy . restore ( on : db ) \u82e5\u8981\u6c38\u4e45\u5220\u9664\u5e26\u6709\u5220\u9664\u65f6\u95f4\u6233\u7684\u9879\uff0c\u8bf7\u4f7f\u7528\u201cforce\u201d\u53c2\u6570: // Permanently delete galaxy . delete ( force : true , on : db ) \u4e0b\u4e00\u6b65 \u00b6 \u795d\u8d3a\u60a8\u521b\u5efa\u4e86\u7b2c\u4e00\u4e2a\u6a21\u578b\u548c\u8fc1\u79fb\uff0c\u5e76\u6267\u884c\u57fa\u672c\u7684\u521b\u5efa\u548c\u8bfb\u53d6\u64cd\u4f5c\u3002 \u6709\u5173\u6240\u6709\u8fd9\u4e9b\u7279\u6027\u7684\u66f4\u591a\u6df1\u5165\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605Fluent\u6307\u5357\u4e2d\u5404\u81ea\u7684\u7ae0\u8282\u3002","title":"Overview"},{"location":"fluent/overview/#fluent","text":"Fluent \u662f\u4e00\u4e2aswift\u8bed\u8a00\u7684 ORM \u6846\u67b6. \u5b83\u5229\u7528swift\u5f3a\u7c7b\u578b\u7cfb\u7edf\u4e3a\u4f60\u7684\u6570\u636e\u5e93\u63d0\u4f9b\u6613\u7528\u7684\u63a5\u53e3. \u4f7f\u7528Fluent\u7684\u6838\u5fc3\u662f\u521b\u5efa\u7528\u6765\u8868\u793a\u6570\u636e\u5e93\u7684\u6570\u636e\u7ed3\u6784\u7684\u6a21\u578b\u7c7b\u578b(Model). \u7136\u540e\u4f7f\u7528\u8fd9\u4e9b\u6a21\u578b\u6267\u884c\u521b\u5efa\u3001\u8bfb\u53d6\u3001\u66f4\u65b0\u3001\u5220\u9664\u64cd\u4f5c\uff0c\u800c\u4e0d\u662f\u7f16\u5199\u539f\u59cbSQL\u8bed\u53e5\u3002","title":"Fluent"},{"location":"fluent/overview/#configuration","text":"\u5f53\u4f7f\u7528\u547d\u4ee4 vapor new \u521b\u5efa\u4e00\u4e2a\u5de5\u7a0b\u65f6, \u952e\u5165 \"yes\" \u6765\u5305\u542bFluent\u5e76\u9009\u62e9\u4f60\u5e0c\u671b\u4f7f\u7528\u7684\u6570\u636e\u5e93\u9a71\u52a8\u3002\u8fd9\u5c06\u81ea\u52a8\u5c06\u4f9d\u8d56\u9879\u4ee5\u53ca\u793a\u4f8b\u914d\u7f6e\u4ee3\u7801\u6dfb\u52a0\u5230\u4f60\u7684\u5de5\u7a0b.","title":"\u914d\u7f6e\uff08Configuration\uff09"},{"location":"fluent/overview/#_1","text":"\u5982\u679c\u4f60\u6709\u4e00\u4e2a\u73b0\u6709\u9879\u76ee\u60f3\u4f7f\u7528Fluent\uff0c\u5219\u9700\u8981\u5c06\u4e24\u4e2a\u4f9d\u8d56\u9879\u6dfb\u52a0\u5230\u4f60\u7684 package : vapor/fluent @4.0.0 \u4e00\u4e2a\u6216\u591a\u4e2aFluent\u9a71\u52a8 . package ( url : \"https://github.com/vapor/fluent.git\" , from : \"4.0.0-beta\" ), . package ( url : \"https://github.com/vapor/fluent-<db>-driver.git\" , from : < version >), . target ( name : \"App\" , dependencies : [ . product ( name : \"Fluent\" , package : \"fluent\" ), . product ( name : \"Fluent<db>Driver\" , package : \"fluent-<db>-driver\" ), . product ( name : \"Vapor\" , package : \"vapor\" ), ]), \u4e00\u65e6\u8fd9\u4e9b\u5305\u88ab\u6dfb\u52a0\u4e3a\u4f9d\u8d56\u9879\uff0c\u4f60\u5c31\u53ef\u4ee5\u5728 configure.swift \u6587\u4ef6\u4e2d\uff0c\u4f7f\u7528 app.databases \u6765\u914d\u7f6e\u4f60\u7684\u6570\u636e\u5e93\u3002 import Fluent import Fluent < db > Driver app . databases . use (< db config >, as : < identifier >) \u4e0b\u9762\u662f\u6bcf\u4e00Fluent\u9a71\u52a8\u7a0b\u5e8f\u7684\u66f4\u8be6\u7ec6\u7684\u914d\u7f6e\u8bf4\u660e\u3002","title":"\u73b0\u6709\u9879\u76ee"},{"location":"fluent/overview/#_2","text":"Fluent \u5f53\u524d\u6709\u4e09\u4e2a\u5b98\u65b9\u652f\u6301\u7684\u9a71\u52a8. \u4f60\u53ef\u4ee5\u5728Github\u4e0a\u641c\u7d22 fluent-driver \u6765\u83b7\u53d6\u5b98\u65b9\u548c\u7b2c\u4e09\u65b9\u7684Fluent\u6570\u636e\u5e93\u7a0b\u5e8f\u7684\u5b8c\u6574\u5217\u8868\u3002","title":"\u9a71\u52a8"},{"location":"fluent/overview/#postgresql","text":"PostgreSQL \u662f\u4e00\u4e2a\u5f00\u6e90\u7684\u3001\u7b26\u5408\u6807\u51c6\u7684SQL\u6570\u636e\u5e93\u3002\u5b83\u53ef\u4ee5\u5f88\u5bb9\u6613\u7684\u914d\u7f6e\u5728\u5927\u591a\u6570\u4e91\u6258\u7ba1\u63d0\u4f9b\u5546\u4e0a. \u8fd9\u662f Fluent \u63a8\u8350\u7684 \u6570\u636e\u5e93\u9a71\u52a8. \u8981\u4f7f\u7528PostgreSQL, \u9700\u8981\u6dfb\u52a0\u4e0b\u5217\u4f9d\u8d56\u9879\u5230\u4f60\u7684\u5305\u4e2d. . package ( url : \"https://github.com/vapor/fluent-postgres-driver.git\" , from : \"2.0.0-beta\" ) . product ( name : \"FluentPostgresDriver\" , package : \"fluent-postgres-driver\" ) \u4e00\u65e6\u6dfb\u52a0\u4e86\u4f9d\u8d56\u9879\uff0c\u4f60\u5c31\u53ef\u4ee5\u5728 configure.swift \u6587\u4ef6\u4e2d\uff0c\u4f7f\u7528 app.databases.use \u6765\u914d\u7f6e\u6570\u636e\u5e93\u51ed\u8bc1\u3002 import Fluent import FluentPostgresDriver app . databases . use (. postgres ( hostname : \"localhost\" , username : \"vapor\" , password : \"vapor\" , database : \"vapor\" ), as : . psql ) \u4f60\u4e5f\u53ef\u4ee5\u4ece\u6570\u636e\u5e93\u8fde\u63a5\u5b57\u7b26\u4e32\u4e2d\u89e3\u6790\u51ed\u8bc1 try app . databases . use (. postgres ( url : \"<connection string>\" ), as : . psql )","title":"PostgreSQL"},{"location":"fluent/overview/#sqlite","text":"SQLite\u662f\u4e00\u4e2a\u5f00\u6e90\u7684\u5d4c\u5165\u5f0fSQL\u6570\u636e\u5e93\uff0c\u5176\u7b80\u5355\u7684\u7279\u6027\u4f7f\u5b83\u6210\u4e3a\u539f\u578b\u548c\u6d4b\u8bd5\u7684\u5353\u8d8a\u7684\u5019\u9009\u3002 \u8981\u4f7f\u7528 SQLite, \u9700\u8981\u6dfb\u52a0\u4e0b\u5217\u4f9d\u8d56\u9879\u5230\u4f60\u7684\u5305\u4e2d. . package ( url : \"https://github.com/vapor/fluent-sqlite-driver.git\" , from : \"4.0.0-beta\" ) . product ( name : \"FluentSQLiteDriver\" , package : \"fluent-sqlite-driver\" ) \u4e00\u65e6\u6dfb\u52a0\u4e86\u4f9d\u8d56\u9879\uff0c\u4f60\u5c31\u53ef\u4ee5\u5728 configure.swift \u6587\u4ef6\u4e2d\uff0c\u4f7f\u7528 app.databases.use \u6765\u914d\u7f6e\u6570\u636e\u5e93\u3002 import Fluent import FluentSQLiteDriver app . databases . use (. sqlite (. file ( \"db.sqlite\" )), as : . sqlite ) \u4f60\u4e5f\u53ef\u4ee5\u914d\u7f6eSQLite\u5c06\u6570\u636e\u5e93\u4e34\u65f6\u5b58\u50a8\u5728\u5185\u5b58\u4e2d\u3002 app . databases . use (. sqlite (. memory ), as : . sqlite ) \u5982\u679c\u4f60\u4f7f\u7528\u5185\u5b58\u6570\u636e\u5e93\uff0c\u8bf7\u786e\u4fdd\u5c06Fluent\u8bbe\u7f6e\u4e3a\u81ea\u52a8\u8fc1\u79fb(migration)\uff0c\u5728\u6dfb\u52a0\u8fc1\u79fb\u540e\uff0c\u53ef\u4ee5\u5728\u547d\u4ee4\u884c\u4e2d\u4f7f\u7528\u53c2\u6570 --auto-migrate \u6216\u8005\u4ee3\u7801\u4e2d\u8fd0\u884c app.autoMigrate() \u3002 app . migrations . add ( CreateTodo ()) try app . autoMigrate (). wait ()","title":"SQLite"},{"location":"fluent/overview/#mysql","text":"MySQL\u662f\u4e00\u4e2a\u6d41\u884c\u7684\u5f00\u6e90\u6570\u636e\u5e93\u3002\u5b83\u53ef\u4ee5\u5728\u5927\u591a\u6570\u4e91\u6258\u7ba1\u63d0\u4f9b\u5546\u4e0a\u83b7\u5f97.\u8fd9\u4e2a\u9a71\u52a8\u4e5f\u652f\u6301MariaDB. \u8981\u4f7f\u7528 MySQL, \u9700\u8981\u6dfb\u52a0\u4e0b\u5217\u4f9d\u8d56\u9879\u5230\u4f60\u7684\u5305\u4e2d. . package ( url : \"https://github.com/vapor/fluent-mysql-driver.git\" , from : \"4.0.0-beta\" ) . product ( name : \"FluentMySQLDriver\" , package : \"fluent-mysql-driver\" ) \u4e00\u65e6\u6dfb\u52a0\u4e86\u4f9d\u8d56\u9879\uff0c\u4f60\u5c31\u53ef\u4ee5\u5728 configure.swift \u6587\u4ef6\u4e2d\uff0c\u4f7f\u7528 app.databases.use \u6765\u914d\u7f6e\u6570\u636e\u5e93\u51ed\u8bc1\u3002 import Fluent import FluentMySQLDriver app . databases . use (. mysql ( hostname : \"localhost\" , username : \"vapor\" , password : \"vapor\" , database : \"vapor\" ), as : . mysql ) \u4f60\u4e5f\u53ef\u4ee5\u4ece\u6570\u636e\u5e93\u8fde\u63a5\u5b57\u7b26\u4e32\u4e2d\u89e3\u6790\u51ed\u8bc1. try app . databases . use (. mysql ( url : \"<connection string>\" ), as : . mysql )","title":"MySQL"},{"location":"fluent/overview/#models","text":"\u6a21\u578b\u8868\u793a\u6570\u636e\u5e93\u4e2d\u56fa\u5b9a\u7684\u6570\u636e\u7ed3\u6784\uff0c\u5982\u8868\u6216\u96c6\u5408\u3002 \u6a21\u578b\u6709\u4e00\u4e2a\u6216\u591a\u4e2a\u5b58\u50a8\u53ef\u7f16\u7801\u503c\u7684\u5b57\u6bb5\u3002 \u6240\u6709\u7684\u6a21\u578b\u90fd\u6709\u552f\u4e00\u7684\u6807\u8bc6\u7b26\u3002 \u901a\u8fc7\u4f7f\u7528\u5c5e\u6027\u5305\u88c5\u5668\u6765\u8868\u793a\u6807\u8bc6\u7b26\u548c\u5b57\u6bb5\u4ee5\u53ca\u540e\u9762\u63d0\u5230\u7684\u66f4\u590d\u6742\u7684\u6620\u5c04\u3002 \u770b\u770b\u4e0b\u9762\u7684\u6a21\u578b\uff0c\u5b83\u4ee3\u8868\u4e86\u4e00\u4e2a\u661f\u7cfb\u3002 final class Galaxy : Model { // \u8868\u6216\u96c6\u5408\u7684\u540d\u79f0. static let schema = \"galaxies\" // \u552f\u4e00\u6807\u8bc6\u7b26. @ ID ( key : . id ) var id : UUID ? // The Galaxy's name. @ Field ( key : \"name\" ) var name : String // \u521b\u5efa\u4e00\u4e2a\u7a7a\u7684\u3001\u65b0\u7684 Galaxy. init () { } // \u901a\u8fc7\u6240\u6709\u5c5e\u6027\u96c6\u5408\u521b\u5efa\u4e00\u4e2a\u65b0\u7684 Galaxy. init ( id : UUID ? = nil , name : String ) { self . id = id self . name = name } } \u8981\u521b\u5efa\u65b0\u7684\u6a21\u578b\uff0c\u8bf7\u521b\u5efa\u4e00\u4e2a\u9075\u5faa Model \u534f\u8bae\u7684\u65b0\u7c7b. Tip \u5efa\u8bae\u6807\u8bb0\u6a21\u578b\u7c7b\u4e3a final \uff0c\u4ee5\u63d0\u9ad8\u6027\u80fd\u548c\u7b80\u5316\u4e00\u81f4\u6027\u8981\u6c42\u3002 Model \u534f\u8bae\u7684\u7b2c\u4e00\u4e2a\u8981\u6c42\u662f\u9759\u6001\u5c5e\u6027 schema . static let schema = \"galaxies\" \u6b64\u5c5e\u6027\u544a\u8bc9Fluent\u8be5\u6a21\u578b\u5bf9\u5e94\u7684\u8868\u6216\u96c6\u5408\u3002\u6b64\u8868\u53ef\u4ee5\u662f\u6570\u636e\u5e93\u4e2d\u5df2\u7ecf\u5b58\u5728\u7684\u8868\uff0c\u4e5f\u53ef\u4ee5\u662f\u4f60\u5c06\u4f7f\u7528 migration \u521b\u5efa\u7684. \u5b83\u4e00\u822c\u4f7f\u7528 snake_case \u547d\u540d\u6cd5\u4e14\u4e3a\u590d\u6570.","title":"Models"},{"location":"fluent/overview/#_3","text":"\u4e0b\u4e00\u4e2a\u8981\u6c42\u5c31\u662f\u4e00\u4e2a\u540d\u4e3a id \u7684\u6807\u8bc6\u7b26\u5b57\u6bb5\u3002 @ ID ( key : . id ) var id : UUID ? \u8fd9\u4e2a\u5b57\u6bb5\u5fc5\u987b\u4f7f\u7528 @ID \u5c5e\u6027\u5305\u88c5\u5668\u3002Fluent\u63a8\u8350\u4f7f\u7528 UUID \u548c \u4e13\u95e8\u7684 .id \u5b57\u6bb5key\uff0c\u56e0\u4e3a\u5b83\u517c\u5bb9\u6240\u6709\u7684Fluent\u9a71\u52a8. If you want to use a custom ID key or type, use the @ID(custom:) overload. \u5982\u679c\u8981\u4f7f\u7528\u81ea\u5b9a\u4e49\u7684ID key\u6216\u7c7b\u578b\uff0c\u8bf7\u4f7f\u7528 @ID(custom:) \u91cd\u8f7d\u3002","title":"\u6807\u8bc6\u7b26"},{"location":"fluent/overview/#_4","text":"\u5728\u6dfb\u52a0\u4e86\u6807\u8bc6\u7b26\u4e4b\u540e\uff0c\u4f60\u53ef\u4ee5\u6dfb\u52a0\u8bb8\u591a\u4f60\u60f3\u5b58\u50a8\u7684\u4fe1\u606f\u7684\u5b57\u6bb5\u3002\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u6dfb\u52a0\u4e86\u4e00\u4e2a\u5b57\u6bb5\u4f5c\u4e3a\u661f\u7cfb\u7684\u540d\u79f0 @ Field ( key : \"name\" ) var name : String \u5bf9\u4e8e\u5355\u4e2a\u5b57\u6bb5\uff0c\u4f7f\u7528 @Field \u5c5e\u6027\u5305\u88c5\u5668\u3002\u7c7b\u4f3c\u4e8e @ID \uff0c key \u53c2\u6570\u6307\u5b9a\u6570\u636e\u5e93\u4e2d\u5b57\u6bb5\u7684\u540d\u79f0\u3002\u5bf9\u4e8e\u6570\u636e\u5e93\u5b57\u6bb5\u547d\u540d\u7684\u7ea6\u5b9a\u4e0eswift\u4e2d\u4e0d\u540c\u7684\u60c5\u51b5\uff0c\u8fd9\u4e00\u70b9\u7279\u522b\u6709\u7528\u3002\u6bd4\u5982\u4f7f\u7528 snake_case \u800c\u4e0d\u662f camelCase \u3002 \u4e0b\u4e00\u6b65\uff0c\u6240\u6709\u7684\u6a21\u578b\u90fd\u8981\u6c42\u4e00\u4e2a\u7a7a\u7684\u521d\u59cb\u5316\u5668\uff0c\u8fd9\u5141\u8bb8Fluent\u6765\u521b\u5efa\u8be5\u6a21\u578b\u7684\u65b0\u5b9e\u4f8b\u3002 init () { } \u6700\u540e\uff0c\u4f60\u53ef\u4ee5\u4e3a\u4f60\u7684\u6a21\u578b\u6dfb\u52a0\u4e00\u4e2a\u4fbf\u5229\u6784\u9020\u5668\uff0c\u4ee5\u8bbe\u7f6e\u5b83\u6240\u6709\u7684\u5c5e\u6027\u3002 init ( id : UUID ? = nil , name : String ) { self . id = id self . name = name } \u4f7f\u7528\u4fbf\u5229\u6784\u9020\u5668\u662f\u975e\u5e38\u6709\u7528\u7684\uff0c\u5f53\u4f60\u6dfb\u52a0\u65b0\u7684\u5b57\u6bb5\u5230\u4f60\u7684\u6a21\u578b\u4e2d\uff0c\u5982\u679c\u521d\u59cb\u5316\u65b9\u6cd5\u53d1\u751f\u53d8\u5316\uff0c\u4f60\u53ef\u4ee5\u83b7\u5f97\u7f16\u8bd1\u65f6\u9519\u8bef\u3002\u8fc1\u79fb\u5bf9\u4e8e\u53d1\u9001","title":"\u5b57\u6bb5"},{"location":"fluent/overview/#_5","text":"\u5982\u679c\u6570\u636e\u5e93\u4f7f\u7528\u9884\u5b9a\u4e49schemas(\u5982SQL \u6570\u636e\u5e93),\u4f60\u9700\u8981\u4e00\u4e2a\u8fc1\u79fb(migration)\u6765\u4e3a\u6a21\u578b\u51c6\u5907\u6570\u636e\u5e93\u3002\u8fc1\u79fb\u5bf9\u4e8e\u6570\u636e\u5e93\u6570\u636e\u586b\u5145(seeding)\u4e5f\u975e\u5e38\u6709\u7528\u3002\u8981\u521b\u5efa\u4e00\u4e2a\u8fc1\u79fb\uff0c\u9700\u8981\u5b9a\u4e49\u4e00\u4e2a\u65b0\u7684\u7c7b\u578b\uff0c\u9075\u5faa Migration \u534f\u8bae\u3002\u770b\u770b\u4e0b\u9762\u4e3a\u5148\u524d\u5b9a\u4e49\u7684 Galaxy \u6a21\u578b\u7684\u8fc1\u79fb\u3002 struct CreateGalaxy : Migration { // \u51c6\u5907\u7528\u4e8e\u5b58\u50a8Galaxy\u6a21\u578b\u7684\u6570\u636e\u5e93\u3002 func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"galaxies\" ) . id () . field ( \"name\" , . string ) . create () } // \u53ef\u9009\u7684\u6062\u590d\u5728\u51c6\u5907\u65b9\u6cd5\u4e2d\u6240\u4f5c\u7684\u4fee\u6539\u3002 func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"galaxies\" ). delete () } } prepare \u65b9\u6cd5\u7528\u4e8e\u51c6\u5907\u5b58\u50a8 Galaxy \u7684\u6570\u636e\u5e93\u3002","title":"\u8fc1\u79fb"},{"location":"fluent/overview/#schema","text":"\u5728\u8fd9\u4e2a\u65b9\u6cd5\u91cc, database.schema(_:) \u7528\u6765\u521b\u5efa\u4e00\u4e2a\u65b0\u7684 SchemaBuilder \u3002 \u4e00\u4e2a\u6216\u591a\u4e2a field \u5c06\u88ab\u6dfb\u52a0\u5230\u8fd9\u4e2abuilder\uff0c\u5728\u8c03\u7528 create() \u521b\u5efa schema\u4e4b\u524d. \u6dfb\u52a0\u5230builder\u4e2d\u7684\u6bcf\u4e00\u4e2a\u5b57\u6bb5\u90fd\u6709\u4e00\u4e2a\u540d\u79f0\uff0c\u7c7b\u578b\uff0c\u548c\u53ef\u9009\u7684\u7ea6\u675f\u3002 field (< name >, < type >, < optional constraints >) \u8fd9\u91cc\u6709\u4e2a\u4fbf\u5229\u7684 id() \u65b9\u6cd5\uff0c\u4f7f\u7528Fluent\u63a8\u8350\u7684\u9ed8\u8ba4\u503c\uff0c\u6765\u6dfb\u52a0 @ID \u5c5e\u6027\uff0c \u8fd8\u539f\u8fc1\u79fb\u53ef\u4ee5\u64a4\u9500\u5728prepare\u65b9\u6cd5\u4e2d\u6240\u4f5c\u7684\u4efb\u4f55\u66f4\u6539\uff0c\u5728\u672c\u4f8b\u4e2d\uff0c\u53ea\u662f\u5220\u9664Galaxy\u6a21\u578b\u7684schema\u3002 \u4e00\u65e6\u5b9a\u4e49\u4e86\u8fc1\u79fb\uff0c\u4f60\u9700\u8981\u5728 configure.swift \u6587\u4ef6\u4e2d\uff0c\u5c06\u5b83\u6dfb\u52a0\u8fdb app.migrations \uff0c\u6765\u544a\u8bc9Fluent\u3002 app . migrations . add ( CreateGalaxy ())","title":"Schema"},{"location":"fluent/overview/#migrate","text":"\u8981\u6267\u884c\u8fc1\u79fb\uff0c\u5728\u547d\u4ee4\u884c\u4e2d\u8c03\u7528 vapor run migrate \u6216\u8005\u6dfb\u52a0 migrate \u4f5c\u4e3aXcode\u8fd0\u884c\u65b9\u6848\u7684\u4e00\u4e2a\u53c2\u6570\u3002 $ vapor run migrate Migrate Command: Prepare The following migration(s) will be prepared: + CreateGalaxy on default Would you like to continue? y/n> y Migration successful","title":"Migrate"},{"location":"fluent/overview/#_6","text":"\u73b0\u5728\u4f60\u5df2\u7ecf\u6210\u529f\u7684\u521b\u5efa\u4e86\u4e00\u4e2a\u6a21\u578b\uff0c\u5e76\u4e14\u8fc1\u79fb\u5230\u4e86\u6570\u636e\u5e93\uff0c\u4f60\u53ef\u4ee5\u8fdb\u884c\u7b2c\u4e00\u6b21\u67e5\u8be2\u4e86\u3002","title":"\u67e5\u8be2"},{"location":"fluent/overview/#all","text":"\u4e0b\u9762\u7684\u8def\u7531\uff0c\u5b83\u5c06\u4f1a\u8fd4\u56de\u6570\u636e\u5e93\u4e2d\u5305\u542b\u6240\u6709\u661f\u7cfb\u7684\u4e00\u4e2a\u6570\u7ec4\u3002 app . get ( \"galaxies\" ) { req in Galaxy . query ( on : req . db ). all () } \u4e3a\u4e86\u76f4\u63a5\u5728\u8def\u7531\u7684\u95ed\u5305\u4e2d\u76f4\u63a5\u8fd4\u56deGalaxy,\u9700\u8981\u5b83\u9075\u5faa Content \u534f\u8bae\u3002 final class Galaxy : Model , Content { ... } Galaxy.query \u4e3a\u6a21\u578b\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u67e5\u8be2\u6784\u5efa\u5668. req.db \u662f\u5bf9\u5e94\u7528\u7a0b\u5e8f\u9ed8\u8ba4\u6570\u636e\u5e93\u7684\u5f15\u7528. \u6700\u7ec8, all() \u8fd4\u56de\u5b58\u50a8\u5728\u6570\u636e\u5e93\u4e2d\u7684\u6240\u6709\u6a21\u578b\u3002 \u7f16\u8bd1\u5e76\u8fd0\u884c\u9879\u76ee\uff0c\u5e76\u4e14\u8bf7\u6c42 GET /galaxies \uff0c\u4f60\u5e94\u8be5\u770b\u5230\u8fd4\u56de\u4e86\u4e00\u4e2a\u7a7a\u6570\u7ec4\u3002\u8ba9\u6211\u4eec\u6dfb\u52a0\u4e00\u6761\u521b\u5efa\u661f\u7cfb\u7684\u8def\u7531\u3002","title":"All"},{"location":"fluent/overview/#create","text":"\u6839\u636eRESTful\u98ce\u683c, \u4f7f\u7528 POST /galaxies \u521b\u5efa\u4e00\u4e2a\u661f\u7cfb. \u56e0\u4e3a\u6a21\u578b\u662f\u53ef\u7f16\u7801\u7684\uff0c\u6240\u4ee5\u4f60\u53ef\u4ee5\u76f4\u63a5\u4ece\u8bf7\u6c42\u4f53\u4e2d\u89e3\u7801\u661f\u7cfb\u3002 app . post ( \"galaxies\" ) { req -> EventLoopFuture < Galaxy > in let galaxy = try req . content . decode ( Galaxy . self ) return galaxy . create ( on : req . db ) . map { galaxy } } Seealso \u6709\u5173\u8bf7\u6c42\u4f53\u89e3\u7801\u7684\u66f4\u591a\u4fe1\u606f\u8bf7\u53c2\u9605 Content \u2192 Overview . \u4e00\u65e6\u4f60\u6709\u4e86model\u7684\u5b9e\u4f8b\uff0c\u8c03\u7528 create(on:) \u5c06\u6a21\u578b\u4fdd\u5b58\u5230\u6570\u636e\u5e93\u3002\u8fd9\u8fd4\u56de\u4e00\u4e2a EventLoopFuture<Void> \uff0c\u5b83\u6307\u793a\u4fdd\u5b58\u5df2\u7ecf\u5b8c\u6210\u3002\u4fdd\u5b58\u5b8c\u6210\u540e\uff0c\u4f7f\u7528 map \u8fd4\u56de\u65b0\u521b\u5efa\u7684\u6a21\u578b \u7f16\u8bd1\u5e76\u8fd0\u884c\u9879\u76ee\uff0c\u5e76\u4e14\u53d1\u9001\u4e0b\u9762\u7684\u8bf7\u6c42\u3002 POST /galaxies HTTP / 1.1 content-length : 21 content-type : application/json { \"name\" : \"Milky Way\" } \u4f60\u5e94\u8be5\u83b7\u5f97\u4e0b\u9762\u7684\u54cd\u5e94\uff0c\u5e26\u6709id\u6807\u8bc6\u7b26\u7684\u65b0\u5efa\u6a21\u578b\u3002 { \"id\" : ... , \"name\" : \"Milky Way\" } \u73b0\u5728\uff0c\u5982\u679c\u4f60\u518d\u6b21\u67e5\u8be2 GET /galaxies \uff0c\u4f60\u5e94\u8be5\u770b\u5230\u65b0\u5efa\u7684\u661f\u7cfb\u5728\u6570\u7ec4\u4e2d\u3002","title":"Create"},{"location":"fluent/overview/#_7","text":"\u6ca1\u6709\u661f\u661f\u7684\u661f\u7cfb\uff01\u8ba9\u6211\u4eec\u901a\u8fc7\u5728 Galaxy \u548c\u4e00\u4e2a\u65b0\u7684 Star \u6a21\u578b\u4e4b\u95f4\u6dfb\u52a0\u4e00\u5bf9\u591a\u5173\u7cfb\uff0c\u6765\u5feb\u901f\u67e5\u770bFluent\u5f3a\u5927\u7684\u5173\u7cfb\u7279\u6027\u3002 final class Star : Model , Content { // \u8868\u6216\u96c6\u5408\u7684\u540d\u79f0 static let schema = \"stars\" // Star\u7684\u552f\u4e00\u6807\u8bc6\u7b26. @ ID ( key : . id ) var id : UUID ? // Star\u7684\u540d\u79f0. @ Field ( key : \"name\" ) var name : String // \u5efa\u7acb\u5173\u7cfb\uff0c\u661f\u661f\u5728\u661f\u7cfb\u4e2d @ Parent ( key : \"galaxy_id\" ) var galaxy : Galaxy // Creates a new, empty Star. init () { } // Creates a new Star with all properties set. init ( id : UUID ? = nil , name : String , galaxyID : UUID ) { self . id = id self . name = name self . $ galaxy . id = galaxyID } }","title":"\u5173\u7cfb"},{"location":"fluent/overview/#parent","text":"\u65b0\u7684 Star \u6a21\u578b\u4e0e Galaxy \u975e\u5e38\u76f8\u4f3c\uff0c\u9664\u4e86\u4e00\u4e2a\u65b0\u7684\u5b57\u6bb5\u7c7b\u578b\uff1a @Parent \u3002 @ Parent ( key : \"galaxy_id\" ) var galaxy : Galaxy perent\u5c5e\u6027\u662f\u4e00\u4e2a\u5b58\u50a8\u53e6\u5916\u4e00\u4e2a\u6a21\u578b\u6807\u8bc6\u7b26\u7684\u5b57\u6bb5\u3002\u4fdd\u5b58\u5173\u7cfb\u7684\u6a21\u578b\u6210\u4e3a\"\u5b50\"\uff0c\u5f15\u7528\u7684\u6a21\u578b\u79f0\u4e3a\u201c\u7236\u201d\u3002\u8fd9\u79cd\u7c7b\u578b\u7684\u5173\u7cfb\u4e5f\u88ab\u79f0\u4e3a\u201c\u4e00\u5bf9\u591a\u201d\u3002 key \u5c5e\u6027\u6307\u5b9a\u5e94\u7528\u4e8e\u6570\u636e\u5e93\u4e2d\u5b58\u50a8\u7236\u952e\u7684\u5b57\u6bb5\u540d\u3002 \u5728\u521d\u59cb\u5316\u65b9\u6cd5\u4e2d\uff0c\u7236\u6807\u8bc6\u7b26\u901a\u8fc7 $galaxy \u8bbe\u7f6e\u3002 self . $ galaxy . id = galaxyID \u901a\u8fc7\u5728\u7236\u5c5e\u6027\u7684\u540d\u79f0\u4f7f\u7528 $ \u524d\u7f00\uff0c\u4f60\u53ef\u4ee5\u8bbf\u95ee\u5e95\u5c42\u7684\u5c5e\u6027\u5305\u88c5\u5668\u3002\u8fd9\u662f\u9700\u8981\u8bbf\u95ee\u5185\u90e8\u7684 @Field \uff0c\u6765\u5b58\u50a8\u5b9e\u9645\u7684\u6807\u8bc6\u7b26\u503c\u3002 Seealso \u67e5\u770b\u6709\u5173\u5c5e\u6027\u5305\u88c5\u5668\u7684swift\u6f14\u8fdb\u5efa\u8bae\u4ee5\u83b7\u53d6\u66f4\u591a\u4fe1\u606f: [SE-0258] Property Wrappers \u63a5\u4e0b\u6765\uff0c\u521b\u5efa\u4e00\u4e2a\u8fc1\u79fb\u6765\u51c6\u5907\u6570\u636e\u5e93\u5904\u7406 Star \u3002 struct CreateStar : Migration { // Prepares the database for storing Star models. func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"stars\" ) . id () . field ( \"name\" , . string ) . field ( \"galaxy_id\" , . uuid , . references ( \"galaxies\" , \"id\" )) . create () } // Optionally reverts the changes made in the prepare method. func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"stars\" ). delete () } } \u8fd9\u5927\u90e8\u5206\u662f\u4e0eGalaxy\u7684\u8fc1\u79fb\u4e00\u6837\u7684\uff0c\u9664\u4e86\u589e\u52a0\u4e86\u4e2a\u5b57\u6bb5\u6765\u5b58\u50a8\u7236\u661f\u7cfb\u7684\u6807\u8bc6\u7b26\u3002 field ( \"galaxy_id\" , . uuid , . references ( \"galaxies\" , \"id\" )) \u8fd9\u4e2a\u5b57\u6bb5\u6307\u5b9a\u4e86\u4e00\u4e2a\u53ef\u9009\u7684\u7ea6\u675f\uff0c\u544a\u77e5\u6570\u636e\u5e93\u8fd9\u4e2a\u5b57\u6bb5\u7684\u503c\uff0c\u5f15\u7528\u201cgalaxies\u201dschema\u4e2d\u7684\u201cid\u201d\u5b57\u6bb5\u3002\u8fd9\u4e5f\u53ef\u4ee5\u79f0\u4e3a\u5916\u952e\uff0c\u6709\u52a9\u4e8e\u786e\u4fdd\u6570\u636e\u7684\u5b8c\u6574\u6027\u3002 \u4e00\u65e6\u521b\u5efa\u4e86\u8fc1\u79fb\uff0c\u628a\u5b83\u6dfb\u52a0\u5230 app.migrations \uff0c\u5e76\u5728 CreateGalaxy \u8fc1\u79fb\u7684\u540e\u9762\u3002 app . migrations . add ( CreateGalaxy ()) app . migrations . add ( CreateStar ()) \u7531\u4e8e\u8fc1\u79fb\u662f\u6709\u5e8f\u8fd0\u884c\u7684\uff0c CreateStar \u5f15\u7528\u4e86galaxies schema\uff0c\u6240\u4ee5\u6392\u5e8f\u5f88\u91cd\u8981\u3002\u6700\u7ec8\uff0c Since migrations run in order, and CreateStar references the galaxies schema, ordering is important. Finally, \u8fd0\u884c\u8fc1\u79fb \u6765\u51c6\u5907\u6570\u636e\u5e93. \u6dfb\u52a0\u4e00\u4e2a\u8def\u7531\u6765\u521b\u5efa\u65b0\u7684\u661f\u661f\u3002 app . post ( \"stars\" ) { req -> EventLoopFuture < Star > in let star = try req . content . decode ( Star . self ) return star . create ( on : req . db ) . map { star } } \u4f7f\u7528\u4ee5\u4e0bHTTP\u8bf7\u6c42\u521b\u5efa\u5f15\u7528\u5148\u524d\u521b\u5efa\u7684\u661f\u7cfb\u7684\u65b0\u661f\u661f\u3002 POST /stars HTTP / 1.1 content-length : 36 content-type : application/json { \"name\" : \"Sun\" , \"galaxy\" : { \"id\" : ... } } \u4f60\u5e94\u8be5\u770b\u5230\u8fd4\u56de\u4e86\u4e00\u4e2a\u5e26\u6709\u552f\u4e00\u6807\u8bc6\u7b26\u7684\u65b0\u661f\u661f\u3002 { \"id\" : ... , \"name\" : \"Sun\" , \"galaxy\" : { \"id\" : ... } }","title":"Parent"},{"location":"fluent/overview/#children","text":"\u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u6765\u770b\u770b\u5982\u4f55\u5229\u7528Fluent\u7684\u8d2a\u5a6a\u52a0\u8f7d\uff08eager-loading\uff09\u7279\u6027\uff0c\u5728 GET /galaxies \u8def\u7531\u4e2d\u81ea\u52a8\u8fd4\u56de\u661f\u7cfb\u4e2d\u7684\u661f\u661f\u3002 \u6dfb\u52a0\u4e0b\u9762\u5c5e\u6027\u5230 Galaxy \u6a21\u578b\u3002 // Galaxy\u6240\u6709\u7684Star. @ Children ( for : \\ . $ galaxy ) var stars : [ Star ] @Children \u5c5e\u6027\u5305\u88c5\u5668\u548c @Parent \u76f8\u53cd\u3002\u5b83\u9700\u8981\u4e00\u4e2a\u952e\u8def\u5f84\u5230\u5b50\u6a21\u578b\u7684 @Parent \u5b57\u6bb5\u4f5c\u4e3a for \u53c2\u6570\u3002\u5b83\u7684\u503c\u662f\u4e00\u4e2a\u5b50\u6a21\u578b\u7684\u6570\u7ec4\uff0c\u56e0\u4e3a\u53ef\u80fd\u5b58\u57280\u4e2a\u6216\u591a\u4e2a\u5b50\u6a21\u578b\u3002Galaxy\u7684\u8fc1\u79fb\u4e0d\u9700\u8981\u505a\u4efb\u4f55\u4fee\u6539\uff0c\u56e0\u4e3a\u8fd9\u79cd\u5173\u7cfb\u6240\u9700\u7684\u6240\u6709\u4fe1\u606f\u90fd\u5b58\u50a8\u5728\u5b50\u6a21\u578b Star \u4e0a\u3002","title":"Children"},{"location":"fluent/overview/#eager-load","text":"\u73b0\u5728\u5173\u7cfb\u5df2\u7ecf\u5b8c\u6210\u4e86\uff0c\u4f60\u53ef\u4ee5\u4f7f\u7528 with \u65b9\u6cd5\u6765\u81ea\u52a8\u83b7\u53d6\u548c\u5e8f\u5217\u5316\u661f\u7cfb-\u661f\u7684\u5173\u7cfb\u3002 app . get ( \"galaxies\" ) { req in Galaxy . query ( on : req . db ). with ( \\ . $ stars ). all () } @Children \u5173\u7cfb\u7684\u952e\u8def\u5f84\u88ab\u4f20\u9012\u7ed9 with \uff0c\u544a\u8bc9Fluent\u5728\u6240\u6709\u751f\u6210\u7684\u6a21\u578b\u4e2d\u81ea\u52a8\u52a0\u8f7d\u6b64\u5173\u7cfb\u3002\u8fd0\u884c\u9879\u76ee\uff0c\u5e76\u53d1\u8d77\u8bf7\u6c42 GET /galaxies \u3002\u4f60\u4f1a\u770b\u5230\u6240\u6709\u7684\u661f\u5df2\u7ecf\u81ea\u52a8\u5305\u542b\u5728\u54cd\u5e94\u4e2d\u3002 [ { \"id\" : ... , \"name\" : \"Milky Way\" , \"stars\" : [ { \"id\" : ... , \"name\" : \"Sun\" , \"galaxy\" : { \"id\" : ... } } ] } ]","title":"\u8d2a\u5a6a\u52a0\u8f7d(Eager Load)"},{"location":"fluent/overview/#siblings","text":"\u6700\u540e\u4e00\u79cd\u5173\u7cfb\u662f\u591a\u5bf9\u591a\uff0c\u6216\u79f0\u4e3a\u5144\u5f1f\u5173\u7cfb\u3002\u521b\u5efa\u4e00\u4e2a Tag \u6a21\u578b\uff0c\u5305\u542b id \u548c name \u5b57\u6bb5\uff0c\u6211\u4eec\u5c06\u7528\u5b83\u6765\u6807\u8bb0\u5177\u6709\u67d0\u4e9b\u7279\u5f81\u7684\u661f\u3002 final class Tag : Model , Content { // Name of the table or collection. static let schema : String = \"tags\" // Unique identifier for this Tag. @ ID ( key : . id ) var id : UUID ? // The Tag's name. @ Field ( key : \"name\" ) var name : String // Creates a new, empty Tag. init () {} // Creates a new Tag with all properties set. init ( id : UUID ? = nil , name : String ) { self . id = id self . name = name } } \u4e00\u4e2a\u6807\u7b7e\u53ef\u4ee5\u6709\u5f88\u591a\u661f\uff0c\u4e00\u4e2a\u661f\u53ef\u4ee5\u6709\u5f88\u591a\u6807\u7b7e\uff0c\u5b83\u4eec\u662f\u5144\u5f1f\u5173\u7cfb\u3002\u4e24\u4e2a\u6a21\u578b\u4e4b\u95f4\u7684\u5144\u5f1f\u5173\u7cfb\u9700\u8981\u7b2c\u4e09\u4e2a\u6a21\u578b\uff08\u79f0\u4e4b\u4e3apivot\uff09\u6765\u4fdd\u5b58\u5173\u7cfb\u6570\u636e\u3002\u6bcf\u4e00\u4e2a StarTag \u6a21\u578b\u5bf9\u8c61\u8868\u793a\u5355\u4e2a\u7684\u661f\u5bf9\u6807\u7b7e\u7684\u5173\u7cfb\uff0c\u6301\u6709\u4e00\u4e2a Star \u548c Tag \u7684id\u3002 final class StarTag : Model { // Name of the table or collection. static let schema : String = \"star_tag\" // Unique identifier for this pivot. @ ID ( key : . id ) var id : UUID ? // Reference to the Tag this pivot relates. @ Parent ( key : \"tag_id\" ) var tag : Tag // Reference to the Star this pivot relates. @ Parent ( key : \"star_id\" ) var star : Star // Creates a new, empty pivot. init () {} // Creates a new pivot with all properties set. init ( tagID : UUID , starID : UUID ) { self . $ tag . id = tagID self . $ star . id = starID } } \u73b0\u5728\uff0c\u8ba9\u6211\u4eec\u66f4\u65b0\u65b0\u7684 Tag \u6a21\u578b\uff0c\u5728\u5176\u4e2d\u6dfb\u52a0\u4e00\u4e2a stars \u5c5e\u6027\uff0c\u8868\u793a\u8fd9\u4e2a\u6807\u7b7e\u4e0b\u7684\u6240\u6709\u661f\u661f\u3002 @ Siblings ( through : StarTag . self , from : \\ . $ tag , to : \\ . $ star ) var stars : [ Star ] @Siblings \u5c5e\u6027\u5305\u88c5\u5668\u9700\u8981\u4e09\u4e2a\u53c2\u6570\u3002\u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u5148\u524d\u521b\u5efa\u7684pivot\u6a21\u578b StarTag \u3002\u63a5\u4e0b\u6765\u7684\u4e24\u4e2a\u53c2\u6570\u662fpivot\u6a21\u578b\u7236\u5173\u7cfb\u7684\u952e\u8def\u5f84\u3002 from \u952e\u8def\u5f84\u662fpivot\u6a21\u578b\u4e0e\u5f53\u524d\u6a21\u578b\u7684\u7236\u5173\u7cfb\uff0c\u5728\u8fd9\u91cc\u662f Tag \u3002 to \u952e\u8def\u5f84\u662fpivot\u6a21\u578b\u4e0e\u53e6\u4e00\u4e2a\u76f8\u5173\u6a21\u578b\u7684\u7236\u5173\u7cfb\uff0c\u5728\u8fd9\u91cc\u662f Star \u3002 \u8fd9\u4e09\u4e2a\u53c2\u6570\u7ed3\u5408\u5728\u4e00\u8d77\uff0c\u5f62\u6210\u4e00\u4e2a\u5173\u7cfb\uff1a\u4ece\u5f53\u524d\u7684\u6a21\u578b Tag \uff0c\u7a7f\u8fc7pivot\u6a21\u578b StarTag \uff0c\u5230\u6240\u671f\u671b\u7684\u6a21\u578b Star \u3002 \u73b0\u5728\u8ba9\u6211\u4eec\u66f4\u65b0 Star \u6a21\u578b\uff0c\u6765\u521b\u5efa\u4e00\u6761\u548c\u4e0a\u9762\u76f8\u53cd\u7684\u8def\u7ebf\u7684\u5173\u7cfb: @ Siblings ( through : StarTag . self , from : \\ . $ star , to : \\ . $ tag ) var tags : [ Tag ] \u8fd9\u4e9b\u5144\u5f1f\u5173\u7cfb\u5c5e\u6027\u4f9d\u8d56\u4e8e StarTag \u5b58\u50a8\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u9700\u8981\u66f4\u65b0 Star \u8fc1\u79fb\uff0c\u4f46\u662f\u6211\u4eec\u9700\u8981\u4e3a Tag \u548c StarTag \u521b\u5efa\u8fc1\u79fb: struct CreateTag : Migration { func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"tags\" ) . id () . field ( \"name\" , . string ) . create () } func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"tags\" ). delete () } } struct CreateStarTag : Migration { func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"star_tag\" ) . id () . field ( \"star_id\" , . uuid , . required , . references ( \"star\" , \"id\" )) . field ( \"tag_id\" , . uuid , . required , . references ( \"star\" , \"id\" )) . create () } func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"star_tag\" ). delete () } } \u7136\u540e\u5728configure.swift\u4e2d\u6dfb\u52a0\u8fc1\u79fb: app . migrations . add ( CreateTag ()) app . migrations . add ( CreateStarTag ()) \u73b0\u5728\u6211\u4eec\u60f3\u7ed9\u661f\u52a0\u6807\u7b7e\uff0c\u521b\u5efa\u4e00\u4e2a\u8def\u7531\u7528\u6765\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u6807\u7b7e\uff0c\u4e4b\u540e\u6211\u4eec\u9700\u8981\u521b\u5efa\u5c06\u6807\u7b7e\u6dfb\u52a0\u5230\u661f\u7684\u8def\u7531\u3002 app . post ( \"star\" , \":starID\" , \"tag\" , \":tagID\" ) { req -> EventLoopFuture < HTTPStatus > in let star = Star . find ( req . parameters . get ( \"starID\" ), on : req . db ) . unwrap ( or : Abort (. notFound )) let tag = Tag . find ( req . parameters . get ( \"tagID\" ), on : req . db ) . unwrap ( or : Abort (. notFound )) return star . and ( tag ). flatMap { ( star , tag ) in star . $ tags . attach ( tag , on : req . db ) }. transform ( to : . ok ) } \u8fd9\u4e2a\u8def\u7531\u5305\u542b\u4e86\u661f\u548c\u6807\u7b7e\u7684id\u53c2\u6570\u7ec4\u4ef6\uff0c\u6211\u4eec\u5e0c\u671b\u5f7c\u6b64\u5173\u8054\u3002 \u5982\u679c\u6211\u4eec\u60f3\u8981\u5728id\u4e3a1\u7684\u661f\u548cid\u4e3a2\u7684\u6807\u7b7e\u4e4b\u95f4\u5efa\u7acb\u5173\u7cfb\uff0c\u6211\u4eec\u9700\u8981\u53d1\u9001 POST \u8bf7\u6c42\u5230 /star/1/tag/2 \uff0c\u4e14\u6211\u4eec\u4f1a\u6536\u5230\u4e00\u4e2aHttp\u54cd\u5e94\u7801\u3002 \u9996\u5148\uff0c\u6211\u4eec\u9700\u8981\u5728\u6570\u636e\u5e93\u4e2d\u67e5\u627e\u661f\u548c\u6807\u7b7e\uff0c\u4ee5\u786e\u4fdd\u8fd9\u4e9bid\u662f\u6709\u6548\u7684\u3002 \u7136\u540e\uff0c\u6211\u4eec\u901a\u8fc7\u628a\u8fd9\u4e2aid\u4e3a2\u7684\u6807\u7b7e\uff0c\u9644\u52a0\u5230id\u4e3a1\u7684\u661f\u7684\u6240\u6709\u6807\u7b7e\u91cc\u6765\u521b\u5efa\u8fd9\u4e2a\u5173\u7cfb\u3002 \u7531\u4e8e\u661f\u7684\u5c5e\u6027\u662f\u4e00\u4e2a\u4e0e\u53e6\u5916\u6a21\u578b\u7684\u5173\u7cfb\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4f7f\u7528 $ \u64cd\u4f5c\u7b26\uff0c\u6765\u8bbf\u95ee\u5b83\u7684\u5c5e\u6027\u5305\u88c5\u5668 @Siblings \u3002 \u5728\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u4e0d\u83b7\u53d6\u5144\u5f1f\u5173\u7cfb\uff0c\u5982\u679c\u6211\u4eec\u5e0c\u671b\u5305\u542b\u5b83\u4eec\uff0c\u5728\u67e5\u8be2\u7684\u65f6\u5019\u9700\u8981\u63d2\u5165 with \u65b9\u6cd5\u3002\u6240\u4ee5\u6211\u4eec\u9700\u8981\u66f4\u65b0\u83b7\u53d6\u6240\u6709\u661f\u7684\u8def\u7531: app . get ( \"stars\" ) { req in Star . query ( on : req . db ). with ( \\ . $ tags ). all () }","title":"Siblings"},{"location":"fluent/overview/#_8","text":"\u8981\u521b\u5efa\u54cd\u5e94 Model \u4e0a\u7684\u4e8b\u4ef6\u94a9\u5b50\uff0c\u4f60\u53ef\u4ee5\u4e3a\u4f60\u7684\u6a21\u578b\u521b\u5efa\u4e2d\u95f4\u4ef6\uff0c\u4f60\u7684\u4e2d\u95f4\u4ef6\u5fc5\u987b\u9075\u5faa ModelMiddleware \u534f\u8bae. \u8fd9\u91cc\u4e00\u4e2a\u7b80\u5355\u7684\u4e2d\u95f4\u4ef6\u793a\u4f8b: struct GalaxyMiddleware : ModelMiddleware { // \u5f53\u6a21\u578b\u88ab\u521b\u5efa\u65f6\u6267\u884c\u3002 func create ( model : Galaxy , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { return next . create ( model , on : db ) } // \u5f53\u6a21\u578b\u66f4\u65b0\u65f6\u6267\u884c func update ( model : Galaxy , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { return next . update ( model , on : db ) } // \u5f53\u6a21\u578b\u8f6f\u5220\u9664\u65f6\u6267\u884c func softDelete ( model : Galaxy , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { return next . softDelete ( model , on : db ) } // \u5f53\u8fd8\u539f\u8f6f\u5220\u9664\u6a21\u578b\u7684\u65f6\u6267\u884c func restore ( model : Galaxy , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { return next . restore ( model , on : db ) } // \u5f53\u6a21\u578b\u5220\u9664\u65f6\u5019\u6267\u884c\u3002 // \u5982\u679c\"force\" \u53c2\u6570\u4e3atrue, \u6a21\u578b\u5c06\u88ab\u6c38\u4e45\u5220\u9664\u3002 // \u5373\u4f7f\u4f7f\u7528\u8f6f\u5220\u9664\u65f6\u95f4\u6233. func delete ( model : Galaxy , force : Bool , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { return next . delete ( model , force : force , on : db ) } } \u8fd9\u4e9b\u65b9\u6cd5\u4e2d\u7684\u6bcf\u4e00\u4e2a\u90fd\u6709\u4e00\u4e2a\u9ed8\u8ba4\u7684\u5b9e\u73b0\uff0c\u6240\u4ee5\u60a8\u53ea\u9700\u8981\u5305\u542b\u60a8\u9700\u8981\u7684\u65b9\u6cd5\u3002 \u4f60\u5e94\u8be5\u8fd4\u56de\u4e0b\u4e00\u4e2a AnyModelResponder \u76f8\u5e94\u7684\u65b9\u6cd5\uff0cFluent\u7ee7\u7eed\u5904\u7406\u4e8b\u4ef6\u3002 Important \u6b64\u4e2d\u95f4\u4ef6\u53ea\u54cd\u5e94\u8fd9\u4e9b\u51fd\u6570\u4e2d\u63d0\u4f9b\u7684 Model \u7c7b\u578b\u7684\u751f\u547d\u5468\u671f\u4e8b\u4ef6\u3002\u5728\u4e0a\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c GalaxyMiddleware \u5728Galaxy\u6a21\u578b\u4e0a\u54cd\u5e94\u4e8b\u4ef6\u3002 \u4f7f\u7528\u8fd9\u4e9b\u65b9\u6cd5\uff0c\u4f60\u53ef\u4ee5\u5728\u4e8b\u4ef6\u5b8c\u6210\u4e4b\u524d\u548c\u4e4b\u540e\u6267\u884c\u64cd\u4f5c\u3002\u5728\u4e8b\u4ef6\u5b8c\u6210\u540e\u6267\u884c\u64cd\u4f5c\uff0c\u53ef\u4ee5\u4f7f\u7528.flatMap() \u5728\u4ece\u4e0b\u4e00\u4e2a\u54cd\u5e94\u4e2d\u8fd4\u56de\u7684future\u4e2d\u6267\u884c.\u4f8b\u5982\uff1a struct GalaxyMiddleware : ModelMiddleware { func create ( model : Galaxy , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { // \u5728\u521b\u5efa\u6a21\u578b\u4e4b\u524d\uff0c\u53ef\u4ee5\u5728\u8fd9\u91cc\u4fee\u6539\u6a21\u578b\u3002 model . name = \"<New Galaxy Name>\" return next . create ( model , on : db ). flatMap { // \u4e00\u65e6\u521b\u5efa\u5b8c\u6210, \u8fd9\u91cc\u7684\u4ee3\u7801\u4f1a\u88ab\u6267\u884c print ( \"Galaxy \\( model . name ) was created\" ) } } } \u4e00\u65e6\u4f60\u521b\u5efa\u4e86\u4e2d\u95f4\u4ef6\uff0c\u4f60\u5fc5\u987b\u5c06\u5b83\u6ce8\u518c\u5728 Application \u7684\u6570\u636e\u5e93\u4e2d\u95f4\u4ef6\u914d\u7f6e\u4e2d\uff0c\u5728 configure.swift \u6587\u4ef6\u4e2d\u6dfb\u52a0: app . databases . middleware . use ( GalaxyMiddleware (), on : . psql )","title":"\u751f\u547d\u5468\u671f"},{"location":"fluent/overview/#timestamps","text":"Fluent\u901a\u8fc7\u5728\u6a21\u578b\u4e2d\u6307\u5b9a Timestamp \u5b57\u6bb5\u6765\u8ddf\u8e2a\u6a21\u578b\u4e0a\u7684\u521b\u5efa\u548c\u66f4\u65b0\u65f6\u95f4\u3002 \u5f53\u9700\u8981\u65f6\uff0cFluent\u81ea\u52a8\u8bbe\u7f6e\u5b57\u6bb5\u3002\u4f60\u53ef\u4ee5\u8fd9\u6837\u6dfb\u52a0\uff1a @ Timestamp ( key : \"created_at\" , on : . create ) var createdAt : Date ? @ Timestamp ( key : \"updated_at\" , on : . update ) var updatedAt : Date ? Info \u60a8\u53ef\u4ee5\u4e3a\u8fd9\u4e9b\u5b57\u6bb5\u4f7f\u7528\u4efb\u4f55\u540d\u79f0/\u952e. created_at / updated_at , \u53ea\u662f\u4e3a\u4e86\u8bf4\u660e\u76ee\u7684\u3002 \u5728\u8fc1\u79fb\u4e2d\u6dfb\u52a0\u65f6\u95f4\u6233\u5b57\u6bb5\u4f7f\u7528 .datetime \u7c7b\u578b\u3002 database . schema (...) ... . field ( \"created_at\" , . datetime ) . field ( \"updated_at\" , . datetime ) . create ()","title":"Timestamps"},{"location":"fluent/overview/#soft-delete","text":"\u8f6f\u5220\u9664\u5728\u6570\u636e\u5e93\u5c06\u9879\u76ee\u6807\u8bb0\u4e3a\u5df2\u5220\u9664\uff0c\u4f46\u5b9e\u9645\u4e0a\u5e76\u6ca1\u6709\u5220\u9664\u5b83\u3002 \u5f53\u4f60\u6709\u6570\u636e\u4fdd\u7559\u9700\u6c42\u65f6\uff0c\u8fd9\u53ef\u80fd\u662f\u6709\u7528\u7684\u3002 \u5728Fluent\u4e2d\uff0c\u5b83\u901a\u8fc7\u8bbe\u7f6e\u4e00\u4e2a\u5220\u9664\u65f6\u95f4\u6233\u6765\u5de5\u4f5c\u3002 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u8f6f\u5220\u9664\u9879\u4e0d\u4f1a\u51fa\u73b0\u5728\u67e5\u8be2\u4e2d\uff0c\u5e76\u4e14\u53ef\u4ee5\u968f\u65f6\u6062\u590d\u3002 Soft deletion marks an item as deleted in the database but doesn't actually remove it. This can be useful when you have data retention requirements, for example. In Fluent, it works by setting a deletion timestamp. By default, soft deleted items won't appear in queries and can be restored at any time. \u7c7b\u4f3c\u4e8e\u521b\u5efa\u548c\u66f4\u65b0\u65f6\u95f4\u6233\uff0c\u8981\u5728\u6a21\u578b\u4e2d\u542f\u7528\u8f6f\u5220\u9664\uff0c\u53ea\u9700\u8981\u5c06\u5220\u9664\u65f6\u95f4\u6233\u8bbe\u7f6e\u4e3a .delete : @ Timestamp ( key : \"deleted_at\" , on : . delete ) var deletedAt : Date ? \u8c03\u7528 Model.delete(on:) \u5220\u9664\u5177\u6709\u5220\u9664\u65f6\u95f4\u6233\u5c5e\u6027\u7684\u6a21\u578b\uff0c\u5c06\u81ea\u52a8\u8f6f\u5220\u9664\u5b83\u3002 \u5982\u679c\u4f60\u9700\u8981\u6267\u884c\u4e00\u4e2a\u67e5\u8be2\uff0c\u5305\u542b\u8f6f\u5220\u9664\u7684\u9879\u76ee\uff0c\u4f60\u53ef\u4ee5\u5728\u67e5\u8be2\u4e2d\u4f7f\u7528 withDeleted() // Get all galaxies including soft-deleted ones. Galaxy . query ( on : db ). withDeleted (). all () \u4f60\u53ef\u4ee5\u7528 restore(on:) \u65b9\u6cd5\u8fd8\u539f\u8f6f\u5220\u9664\u7684\u6a21\u578b: // Restore galaxy galaxy . restore ( on : db ) \u82e5\u8981\u6c38\u4e45\u5220\u9664\u5e26\u6709\u5220\u9664\u65f6\u95f4\u6233\u7684\u9879\uff0c\u8bf7\u4f7f\u7528\u201cforce\u201d\u53c2\u6570: // Permanently delete galaxy . delete ( force : true , on : db )","title":"Soft Delete"},{"location":"fluent/overview/#_9","text":"\u795d\u8d3a\u60a8\u521b\u5efa\u4e86\u7b2c\u4e00\u4e2a\u6a21\u578b\u548c\u8fc1\u79fb\uff0c\u5e76\u6267\u884c\u57fa\u672c\u7684\u521b\u5efa\u548c\u8bfb\u53d6\u64cd\u4f5c\u3002 \u6709\u5173\u6240\u6709\u8fd9\u4e9b\u7279\u6027\u7684\u66f4\u591a\u6df1\u5165\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605Fluent\u6307\u5357\u4e2d\u5404\u81ea\u7684\u7ae0\u8282\u3002","title":"\u4e0b\u4e00\u6b65"},{"location":"fluent/query-builder/","text":"Query Builder \u00b6 Coming soon.","title":"Query Builder"},{"location":"fluent/query-builder/#query-builder","text":"Coming soon.","title":"Query Builder"},{"location":"fluent/relations/","text":"Relations \u00b6 Coming soon.","title":"Relations"},{"location":"fluent/relations/#relations","text":"Coming soon.","title":"Relations"},{"location":"install/macos/","text":"\u5728 macOS \u4e0a\u5b89\u88c5 \u00b6 \u8981\u5728 macOS \u4e0a\u4f7f\u7528 Vapor\uff0c\u60a8\u5c06\u9700\u8981 Swift 5.2 \u6216\u66f4\u9ad8\u7248\u672c\u3002 Swift \u53ca\u5176\u6240\u6709\u4f9d\u8d56\u9879\u90fd\u4e0e Xcode \u6346\u7ed1\u3002 \u5b89\u88c5 Xcode \u00b6 \u4ece Mac App Store \u5b89\u88c5 Xcode 11 \u6216\u66f4\u9ad8\u7248\u672c\u3002 \u63d0\u793a \u5728\u64b0\u5199\u672c\u6587\u65f6\uff0c\u5305\u542b Swift 5.2 \u7684 Xcode 11.4 \u8fd8\u5904\u4e8e\u6d4b\u8bd5\u9636\u6bb5\u3002\u60a8\u53ef\u4ee5\u4ece \u5f00\u53d1\u8005\u7f51\u7ad9 \u4e0b\u8f7d\u5b83\uff0c\u4e5f\u53ef\u4ee5\u4ece Swift.org \u4e0b\u8f7d\u6700\u65b0\u7684 Swift 5.2 \u5de5\u5177\u94fe\u3002 \u4e0b\u8f7d Xcode \u4e4b\u540e\uff0c\u5fc5\u987b\u5c06\u5176\u6253\u5f00\u4ee5\u5b8c\u6210\u5b89\u88c5\u3002\u53ef\u80fd\u8fd8\u9700\u8981\u8010\u5fc3\u7b49\u5f85\u4e00\u4f1a\u513f\u3002 \u5b89\u88c5\u540e\uff0c\u6253\u5f00 Terminal \u8f93\u5165\u4ee5\u4e0b\u547d\u4ee4\u6253\u5370 Swift \u7684\u7248\u672c\uff0c\u68c0\u67e5\u7248\u672c\u53f7\u4ee5\u786e\u4fdd\u5b89\u88c5\u6210\u529f\u3002 swift --version \u60a8\u5e94\u8be5\u80fd\u591f\u770b\u5230 Swift \u7684\u7248\u672c\u4fe1\u606f\u5df2\u6253\u5370\u3002 Apple Swift version 5 .2 ( swiftlang-1100.0.270.13 clang-1100.0.33.7 ) Target: x86_64-apple-darwin19.0.0 Vapor 4 \u9700\u8981 Swift 5.2 \u6216\u66f4\u9ad8\u7248\u672c\u3002 \u5b89\u88c5 Toolbox \u00b6 \u73b0\u5728\u60a8\u5df2\u7ecf\u5b89\u88c5\u4e86 Swift\uff0c\u8ba9\u6211\u4eec\u5b89\u88c5 Vapor Toolbox \u3002 \u4f7f\u7528 Vapor \u4e0d\u9700\u8981\u6b64 CLI \u5de5\u5177\uff0c\u4f46\u662f\u5b83\u5305\u542b\u4e00\u4e9b\u5b9e\u7528\u7684\u7a0b\u5e8f\uff0c\u4f8b\u5982\u65b0\u9879\u76ee\u521b\u5efa\u8005\u3002 Toolbox \u901a\u8fc7 Homebrew \u5206\u53d1\u3002\u5982\u679c\u60a8\u8fd8\u6ca1\u6709\u5b89\u88c5 Homebrew\uff0c\u8bf7\u8bbf\u95ee brew.sh \u67e5\u770b\u5b89\u88c5\u8bf4\u660e\u3002 brew install vapor/tap/vapor-beta \u901a\u8fc7\u8f93\u51fa\u5e2e\u52a9\u5185\u5bb9\u4ee5\u786e\u4fdd\u5b89\u88c5\u6210\u529f\u3002 vapor-beta --help \u60a8\u5e94\u8be5\u53ef\u4ee5\u770b\u5230 Vapor \u5305\u542b\u7684\u53ef\u7528\u547d\u4ee4\u5217\u8868\u3002 \u4e0b\u4e00\u6b65 \u00b6 \u73b0\u5728\u60a8\u5df2\u7ecf\u5b89\u88c5\u4e86 Swift and Vapor Toolbox\uff0c\u5728 \u5f00\u59cb \u2192 \u4f60\u597d\uff0c\u4e16\u754c \u4e2d\u521b\u5efa\u60a8\u7684\u7b2c\u4e00\u4e2a Vapor \u5e94\u7528\u7a0b\u5e8f\u3002","title":"macOS"},{"location":"install/macos/#macos","text":"\u8981\u5728 macOS \u4e0a\u4f7f\u7528 Vapor\uff0c\u60a8\u5c06\u9700\u8981 Swift 5.2 \u6216\u66f4\u9ad8\u7248\u672c\u3002 Swift \u53ca\u5176\u6240\u6709\u4f9d\u8d56\u9879\u90fd\u4e0e Xcode \u6346\u7ed1\u3002","title":"\u5728 macOS \u4e0a\u5b89\u88c5"},{"location":"install/macos/#xcode","text":"\u4ece Mac App Store \u5b89\u88c5 Xcode 11 \u6216\u66f4\u9ad8\u7248\u672c\u3002 \u63d0\u793a \u5728\u64b0\u5199\u672c\u6587\u65f6\uff0c\u5305\u542b Swift 5.2 \u7684 Xcode 11.4 \u8fd8\u5904\u4e8e\u6d4b\u8bd5\u9636\u6bb5\u3002\u60a8\u53ef\u4ee5\u4ece \u5f00\u53d1\u8005\u7f51\u7ad9 \u4e0b\u8f7d\u5b83\uff0c\u4e5f\u53ef\u4ee5\u4ece Swift.org \u4e0b\u8f7d\u6700\u65b0\u7684 Swift 5.2 \u5de5\u5177\u94fe\u3002 \u4e0b\u8f7d Xcode \u4e4b\u540e\uff0c\u5fc5\u987b\u5c06\u5176\u6253\u5f00\u4ee5\u5b8c\u6210\u5b89\u88c5\u3002\u53ef\u80fd\u8fd8\u9700\u8981\u8010\u5fc3\u7b49\u5f85\u4e00\u4f1a\u513f\u3002 \u5b89\u88c5\u540e\uff0c\u6253\u5f00 Terminal \u8f93\u5165\u4ee5\u4e0b\u547d\u4ee4\u6253\u5370 Swift \u7684\u7248\u672c\uff0c\u68c0\u67e5\u7248\u672c\u53f7\u4ee5\u786e\u4fdd\u5b89\u88c5\u6210\u529f\u3002 swift --version \u60a8\u5e94\u8be5\u80fd\u591f\u770b\u5230 Swift \u7684\u7248\u672c\u4fe1\u606f\u5df2\u6253\u5370\u3002 Apple Swift version 5 .2 ( swiftlang-1100.0.270.13 clang-1100.0.33.7 ) Target: x86_64-apple-darwin19.0.0 Vapor 4 \u9700\u8981 Swift 5.2 \u6216\u66f4\u9ad8\u7248\u672c\u3002","title":"\u5b89\u88c5 Xcode"},{"location":"install/macos/#toolbox","text":"\u73b0\u5728\u60a8\u5df2\u7ecf\u5b89\u88c5\u4e86 Swift\uff0c\u8ba9\u6211\u4eec\u5b89\u88c5 Vapor Toolbox \u3002 \u4f7f\u7528 Vapor \u4e0d\u9700\u8981\u6b64 CLI \u5de5\u5177\uff0c\u4f46\u662f\u5b83\u5305\u542b\u4e00\u4e9b\u5b9e\u7528\u7684\u7a0b\u5e8f\uff0c\u4f8b\u5982\u65b0\u9879\u76ee\u521b\u5efa\u8005\u3002 Toolbox \u901a\u8fc7 Homebrew \u5206\u53d1\u3002\u5982\u679c\u60a8\u8fd8\u6ca1\u6709\u5b89\u88c5 Homebrew\uff0c\u8bf7\u8bbf\u95ee brew.sh \u67e5\u770b\u5b89\u88c5\u8bf4\u660e\u3002 brew install vapor/tap/vapor-beta \u901a\u8fc7\u8f93\u51fa\u5e2e\u52a9\u5185\u5bb9\u4ee5\u786e\u4fdd\u5b89\u88c5\u6210\u529f\u3002 vapor-beta --help \u60a8\u5e94\u8be5\u53ef\u4ee5\u770b\u5230 Vapor \u5305\u542b\u7684\u53ef\u7528\u547d\u4ee4\u5217\u8868\u3002","title":"\u5b89\u88c5 Toolbox"},{"location":"install/macos/#_1","text":"\u73b0\u5728\u60a8\u5df2\u7ecf\u5b89\u88c5\u4e86 Swift and Vapor Toolbox\uff0c\u5728 \u5f00\u59cb \u2192 \u4f60\u597d\uff0c\u4e16\u754c \u4e2d\u521b\u5efa\u60a8\u7684\u7b2c\u4e00\u4e2a Vapor \u5e94\u7528\u7a0b\u5e8f\u3002","title":"\u4e0b\u4e00\u6b65"},{"location":"install/ubuntu/","text":"\u5728 Ubuntu \u4e0a\u5b89\u88c5 \u00b6 \u8981\u5728 Ubuntu \u4e0a\u4f7f\u7528 Vapor\uff0c\u60a8\u5c06\u9700\u8981 Swift 5.2 \u6216\u66f4\u9ad8\u7248\u672c\u3002\u53ef\u4ee5\u4f7f\u7528 Swift.org \u4e0a\u63d0\u4f9b\u7684\u5de5\u5177\u94fe\u8fdb\u884c\u5b89\u88c5\u3002 \u652f\u6301\u7248\u672c \u00b6 Vapor \u652f\u6301\u7684 Ubuntu \u7248\u672c\u4e0e Swift 5.2 \u76f8\u540c\u3002 \u7248\u672c \u4ee3\u53f7 18.04 Bionic Beaver 16.04 Xenial Xerus \u5b89\u88c5 \u00b6 \u8bf7\u8bbf\u95ee Swift.org \u4f7f\u7528\u4e0b\u8f7d \u6307\u5357\uff0c\u4ee5\u83b7\u53d6\u6709\u5173\u5982\u4f55\u5728 Linux\u4e0a \u5b89\u88c5 Swift \u7684\u8bf4\u660e\u3002 Docker \u00b6 \u60a8\u8fd8\u53ef\u4ee5\u4f7f\u7528\u9884\u88c5\u7f16\u8bd1\u5668\u7684 Swift \u5b98\u65b9 Docker \u6620\u50cf\u3002\u5728 Swift Docker Hub \u4e0a\u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u3002 \u5b89\u88c5 Toolbox \u00b6 \u73b0\u5728\u60a8\u5df2\u7ecf\u5b89\u88c5\u4e86Swift\uff0c\u8ba9\u6211\u4eec\u5b89\u88c5 Vapor Toolbox \u3002\u4f7f\u7528 Vapor \u4e0d\u9700\u8981\u6b64CLI\u5de5\u5177\uff0c\u4f46\u5b83\u5305\u542b\u4e00\u4e9b\u5b9e\u7528\u7a0b\u5e8f\u3002 \u5728 Linux \u4e0a\uff0c\u60a8\u9700\u8981\u4ece\u6e90\u4ee3\u7801\u6784\u5efa Toolbox\uff0c\u5728 GitHub \u4e0a\u67e5\u770b Toolbox \uff0c\u4ee5\u627e\u5230\u6700\u65b0\u7248\u672c\u3002 git clone https://github.com/vapor/toolbox.git cd toolbox git checkout <desired version> swift build -c release --disable-sandbox mv .build/release/vapor /usr/local/bin \u901a\u8fc7\u8f93\u51fa\u5e2e\u52a9\u5185\u5bb9\u4ee5\u786e\u4fdd\u5b89\u88c5\u6210\u529f\u3002 vapor --help \u60a8\u5e94\u8be5\u53ef\u4ee5\u770b\u5230 Vapor \u5305\u542b\u7684\u53ef\u7528\u547d\u4ee4\u5217\u8868\u3002 \u4e0b\u4e00\u6b65 \u00b6 \u5b89\u88c5Swift\u4e4b\u540e\uff0c\u8bf7\u5728 \u5f00\u59cb \u2192 \u4f60\u597d\uff0c\u4e16\u754c \u4e2d\u521b\u5efa\u60a8\u7684\u7b2c\u4e00\u4e2a Vapor \u5e94\u7528\u7a0b\u5e8f\u3002","title":"Ubuntu"},{"location":"install/ubuntu/#ubuntu","text":"\u8981\u5728 Ubuntu \u4e0a\u4f7f\u7528 Vapor\uff0c\u60a8\u5c06\u9700\u8981 Swift 5.2 \u6216\u66f4\u9ad8\u7248\u672c\u3002\u53ef\u4ee5\u4f7f\u7528 Swift.org \u4e0a\u63d0\u4f9b\u7684\u5de5\u5177\u94fe\u8fdb\u884c\u5b89\u88c5\u3002","title":"\u5728 Ubuntu \u4e0a\u5b89\u88c5"},{"location":"install/ubuntu/#_1","text":"Vapor \u652f\u6301\u7684 Ubuntu \u7248\u672c\u4e0e Swift 5.2 \u76f8\u540c\u3002 \u7248\u672c \u4ee3\u53f7 18.04 Bionic Beaver 16.04 Xenial Xerus","title":"\u652f\u6301\u7248\u672c"},{"location":"install/ubuntu/#_2","text":"\u8bf7\u8bbf\u95ee Swift.org \u4f7f\u7528\u4e0b\u8f7d \u6307\u5357\uff0c\u4ee5\u83b7\u53d6\u6709\u5173\u5982\u4f55\u5728 Linux\u4e0a \u5b89\u88c5 Swift \u7684\u8bf4\u660e\u3002","title":"\u5b89\u88c5"},{"location":"install/ubuntu/#docker","text":"\u60a8\u8fd8\u53ef\u4ee5\u4f7f\u7528\u9884\u88c5\u7f16\u8bd1\u5668\u7684 Swift \u5b98\u65b9 Docker \u6620\u50cf\u3002\u5728 Swift Docker Hub \u4e0a\u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u3002","title":"Docker"},{"location":"install/ubuntu/#toolbox","text":"\u73b0\u5728\u60a8\u5df2\u7ecf\u5b89\u88c5\u4e86Swift\uff0c\u8ba9\u6211\u4eec\u5b89\u88c5 Vapor Toolbox \u3002\u4f7f\u7528 Vapor \u4e0d\u9700\u8981\u6b64CLI\u5de5\u5177\uff0c\u4f46\u5b83\u5305\u542b\u4e00\u4e9b\u5b9e\u7528\u7a0b\u5e8f\u3002 \u5728 Linux \u4e0a\uff0c\u60a8\u9700\u8981\u4ece\u6e90\u4ee3\u7801\u6784\u5efa Toolbox\uff0c\u5728 GitHub \u4e0a\u67e5\u770b Toolbox \uff0c\u4ee5\u627e\u5230\u6700\u65b0\u7248\u672c\u3002 git clone https://github.com/vapor/toolbox.git cd toolbox git checkout <desired version> swift build -c release --disable-sandbox mv .build/release/vapor /usr/local/bin \u901a\u8fc7\u8f93\u51fa\u5e2e\u52a9\u5185\u5bb9\u4ee5\u786e\u4fdd\u5b89\u88c5\u6210\u529f\u3002 vapor --help \u60a8\u5e94\u8be5\u53ef\u4ee5\u770b\u5230 Vapor \u5305\u542b\u7684\u53ef\u7528\u547d\u4ee4\u5217\u8868\u3002","title":"\u5b89\u88c5 Toolbox"},{"location":"install/ubuntu/#_3","text":"\u5b89\u88c5Swift\u4e4b\u540e\uff0c\u8bf7\u5728 \u5f00\u59cb \u2192 \u4f60\u597d\uff0c\u4e16\u754c \u4e2d\u521b\u5efa\u60a8\u7684\u7b2c\u4e00\u4e2a Vapor \u5e94\u7528\u7a0b\u5e8f\u3002","title":"\u4e0b\u4e00\u6b65"},{"location":"version/1_5/","text":"Redirecting... \u00b6","title":"1.5"},{"location":"version/1_5/#redirecting","text":"","title":"Redirecting..."},{"location":"version/2_0/","text":"Redirecting... \u00b6","title":"2.0"},{"location":"version/2_0/#redirecting","text":"","title":"Redirecting..."},{"location":"version/3_0/","text":"Redirecting... \u00b6","title":"3.0"},{"location":"version/3_0/#redirecting","text":"","title":"Redirecting..."},{"location":"version/4_0/","text":"Redirecting... \u00b6","title":"4.0"},{"location":"version/4_0/#redirecting","text":"","title":"Redirecting..."}]}