{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This is the documentation for Vapor, a web framework for Swift. Vapor is the most used web framework for Swift. It provides a beautifully expressive and easy to use foundation for your next website or API. Getting Started \u00b6 If this is your first time using Vapor, head to Install \u2192 macOS to install Swift and Vapor. Once you have Vapor installed, check out Getting Started \u2192 Hello, world to create your first Vapor app! Other Sources \u00b6 Here are some other great places to find information about Vapor. name description link Vapor Discord Chat with thousands of Vapor developers. visit \u2192 API docs Auto-generated documentation from code comments. visit \u2192 Stack Overflow Ask and answer questions with the vapor tag. visit \u2192 Swift Forums Post in Vapor's section of the Swift.org forums. visit \u2192 Source Code Learn how Vapor works under the hood. visit \u2192 GitHub Issues Report bugs or request features on GitHub. visit \u2192 Authors \u00b6 Tanner Nelson , Logan Wright , and the hundreds of members of the Vapor community.","title":"Welcome"},{"location":"#getting-started","text":"If this is your first time using Vapor, head to Install \u2192 macOS to install Swift and Vapor. Once you have Vapor installed, check out Getting Started \u2192 Hello, world to create your first Vapor app!","title":"Getting Started"},{"location":"#other-sources","text":"Here are some other great places to find information about Vapor. name description link Vapor Discord Chat with thousands of Vapor developers. visit \u2192 API docs Auto-generated documentation from code comments. visit \u2192 Stack Overflow Ask and answer questions with the vapor tag. visit \u2192 Swift Forums Post in Vapor's section of the Swift.org forums. visit \u2192 Source Code Learn how Vapor works under the hood. visit \u2192 GitHub Issues Report bugs or request features on GitHub. visit \u2192","title":"Other Sources"},{"location":"#authors","text":"Tanner Nelson , Logan Wright , and the hundreds of members of the Vapor community.","title":"Authors"},{"location":"async/","text":"Async \u00b6 You may have noticed some APIs in Vapor expect or return a generic EventLoopFuture type. If this is your first time hearing about futures, they might seem a little confusing at first. But don't worry, this guide will show you how to take advantage of their powerful APIs. Promises and futures are related, but distinct, types. Promises are used to create futures. Most of the time, you will be working with futures returned by Vapor's APIs and you will not need to worry about creating promises. type description mutability EventLoopFuture Reference to a value that may not be available yet. read-only EventLoopPromise A promise to provide some value asynchronously. read/write Futures are an alternative to callback-based asynchronous APIs. Futures can be chained and transformed in ways that simple closures cannot. Transforming \u00b6 Just like optionals and arrays in Swift, futures can be mapped and flat-mapped. These are the most common operations you will perform on futures. method argument description map (T) -> U Maps a future value to a different value. flatMapThrowing (T) throws -> U Maps a future value to a different value or an error. flatMap (T) -> EventLoopFuture<U> Maps a future value to different future value. transform U Maps a future to an already available value. If you look at the method signatures for map and flatMap on Optional<T> and Array<T> , you will see that they are very similar to the methods available on EventLoopFuture<T> . map \u00b6 The map method allows you to transform the future's value to another value. Because the future's value may not be available yet (it may be the result of an asynchronous task) we must provide a closure to accept the value. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... /// Map the future string to an integer let futureInt = futureString . map { string in print ( string ) // The actual String return Int ( string ) ?? 0 } /// We now have a future integer print ( futureInt ) // EventLoopFuture<Int> flatMapThrowing \u00b6 The flatMapThrowing method allows you to transform the future's value to another value or throw an error. Info Because throwing an error must create a new future internally, this method is prefixed flatMap even though the closure does not accept a future return. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... /// Map the future string to an integer let futureInt = futureString . flatMapThrowing { string in print ( string ) // The actual String // Convert the string to an integer or throw an error guard let int = Int ( string ) else { throw Abort (...) } return int } /// We now have a future integer print ( futureInt ) // EventLoopFuture<Int> flatMap \u00b6 The flatMap method allows you to transform the future's value to another future value. It gets the name \"flat\" map because it is what allows you to avoid creating nested futures (e.g., EventLoopFuture<EventLoopFuture<T>> ). In other words, it helps you keep your generics flat. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... /// Assume we have created an HTTP client let client : Client = ... /// flatMap the future string to a future response let futureResponse = futureString . flatMap { string in client . get ( string ) // EventLoopFuture<ClientResponse> } /// We now have a future response print ( futureResponse ) // EventLoopFuture<ClientResponse> Info If we instead used map in the above example, we would have ended up with: EventLoopFuture<EventLoopFuture<ClientResponse>> . To call a throwing method inside of a flatMap , use Swift's do / catch keywords and create a completed future . /// Assume future string and client from previous example. let futureResponse = futureString . flatMap { string in let url : URL do { // Some synchronous throwing method. url = try convertToURL ( string ) } catch { // Use event loop to make pre-completed future. return eventLoop . makeFailedFuture ( error ) } return client . get ( url ) // EventLoopFuture<ClientResponse> } transform \u00b6 The transform method allows you to modify a future's value, ignoring the existing value. This is especially useful for transforming the results of EventLoopFuture<Void> where the actual value of the future is not important. Tip EventLoopFuture<Void> , sometimes called a signal, is a future whose sole purpose is to notify you of completion or failure of some async operation. /// Assume we get a void future back from some API let userDidSave : EventLoopFuture < Void > = ... /// Transform the void future to an HTTP status let futureStatus = userDidSave . transform ( to : HTTPStatus . ok ) print ( futureStatus ) // EventLoopFuture<HTTPStatus> Even though we have supplied an already-available value to transform , this is still a transformation . The future will not complete until all previous futures have completed (or failed). Chaining \u00b6 The great part about transformations on futures is that they can be chained. This allows you to express many conversions and subtasks easily. Let's modify the examples from above to see how we can take advantage of chaining. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... /// Assume we have created an HTTP client let client : Client = ... /// Transform the string to a url, then to a response let futureResponse = futureString . flatMapThrowing { string in guard let url = URL ( string : string ) else { throw Abort (. badRequest , reason : \"Invalid URL string: \\( string ) \" ) } return url }. flatMap { url in client . get ( url ) } print ( futureResponse ) // EventLoopFuture<ClientResponse> After the initial call to map, there is a temporary EventLoopFuture<URL> created. This future is then immediately flat-mapped to a EventLoopFuture<Response> Future \u00b6 Let's take a look at some other methods for using EventLoopFuture<T> . makeFuture \u00b6 You can use an event loop to create pre-completed future with either the value or an error. // Create a pre-succeeded future. let futureString : EventLoopFuture < String > = eventLoop . makeSucceededFuture ( \"hello\" ) // Create a pre-failed future. let futureString : EventLoopFuture < String > = eventLoop . makeFailedFuture ( error ) whenComplete \u00b6 You can use whenComplete to add a callback that will be executed when the future succeeds or fails. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... futureString . whenComplete { result in switch result { case . success ( let string ): print ( string ) // The actual String case . failure ( let error ): print ( error ) // A Swift Error } } Note You can add as many callbacks to a future as you want. Wait \u00b6 You can use .wait() to synchronously wait for the future to be completed. Since a future may fail, this call is throwing. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... /// Block until the string is ready let string = try futureString . wait () print ( string ) /// String wait() can only be used on a background thread or the main thread, i.e., in configure.swift . It can not be used on an event loop thread, i.e., in route closures. Warning Attempting to call wait() on an event loop thread will cause an assertion failure. Promise \u00b6 Most of the time, you will be transforming futures returned by calls to Vapor's APIs. However, at some point you may need to create a promise of your own. To create a promise, you will need access to an EventLoop . You can get access to an event loop from Application or Request depending on context. let eventLoop : EventLoop // Create a new promise for some string. let promiseString = eventLoop . makePromise ( of : String . self ) print ( promiseString ) // EventLoopPromise<String> print ( promiseString . futureResult ) // EventLoopFuture<String> // Completes the associated future. promiseString . succeed ( \"Hello\" ) // Fails the associated future. promiseString . fail (...) Info A promise can only be completed once. Any subsequent completions will be ignored. Promises can be completed ( succeed / fail ) from any thread. This is why promises require an event loop to be initialized. Promises ensure that the completion action gets returned to its event loop for execution. Event Loop \u00b6 When your application boots, it will usually create one event loop for each core in the CPU it is running on. Each event loop has exactly one thread. If you are familiar with event loops from Node.js, the ones in Vapor are similar. The main difference is that Vapor can run multiple event loops in one process since Swift supports multi-threading. Each time a client connects to your server, it will be assigned to one of the event loops. From that point on, all communication between the server and that client will happen on that same event loop (and by association, that event loop's thread). The event loop is responsible for keeping track of each connected client's state. If there is a request from the client waiting to be read, the event loop triggers a read notification, causing the data to be read. Once the entire request is read, any futures waiting for that request's data will be completed. In route closures, you can access the current event loop via Request . req . eventLoop . makePromise ( of : ...) Warning Vapor expects that route closures will stay on req.eventLoop . If you hop threads, you must ensure access to Request and the final response future all happen on the request's event loop. Outside of route closures, you can get one of the available event loops via Application . app . eventLoopGroup . next (). makePromise ( of : ...) hop \u00b6 You can change a future's event loop using hop . futureString . hop ( to : otherEventLoop ) Blocking \u00b6 Calling blocking code on an event loop thread can prevent your application from responding to incoming requests in a timely manner. An example of a blocking call would be something like libc.sleep(_:) . router . get ( \"hello\" ) { req in /// Puts the event loop's thread to sleep. sleep ( 5 ) /// Returns a simple string once the thread re-awakens. return \"Hello, world!\" } sleep(_:) is a command that blocks the current thread for the number of seconds supplied. If you do blocking work like this directly on an event loop, the event loop will be unable to respond to any other clients assigned to it for the duration of the blocking work. In other words, if you do sleep(5) on an event loop, all of the other clients connected to that event loop (possibly hundreds or thousands) will be delayed for at least 5 seconds. Make sure to run any blocking work in the background. Use promises to notify the event loop when this work is done in a non-blocking way. router . get ( \"hello\" ) { req -> EventLoopFuture < String > in /// Create a new void promise let promise = req . eventLoop . makePromise ( of : Void . self ) /// Dispatch some work to happen on a background thread req . application . threadPool . submit { _ in /// Puts the background thread to sleep /// This will not affect any of the event loops sleep ( 5 ) /// When the \"blocking work\" has completed, /// complete the promise and its associated future. promise . succeed () } /// Wait for the future to be completed, /// then transform the result to a simple String return promise . futureResult . transform ( to : \"Hello, world!\" ) } Not all blocking calls will be as obvious as sleep(_:) . If you are suspicious that a call you are using may be blocking, research the method itself or ask someone. The sections below go over how methods can block in more detail. I/O Bound \u00b6 I/O bound blocking means waiting on a slow resource like a network or hard disk which can be orders of magnitude slower than the CPU. Blocking the CPU while you wait for these resources results in wasted time. Danger Never make blocking I/O bound calls directly on an event loop. All of Vapor's packages are built on SwiftNIO and use non-blocking I/O. However, there are many Swift packages and C libraries in the wild that use blocking I/O. Chances are if a function is doing disk or network IO and uses a synchronous API (no callbacks or futures) it is blocking. CPU Bound \u00b6 Most of the time during a request is spent waiting for external resources like database queries and network requests to load. Because Vapor and SwiftNIO are non-blocking, this downtime can be used for fulfilling other incoming requests. However, some routes in your application may need to do heavy CPU bound work as the result of a request. While an event loop is processing CPU bound work, it will be unable to respond to other incoming requests. This is normally fine since CPUs are fast and most CPU work web applications do is lightweight. But this can become a problem if routes with long running CPU work are preventing requests to faster routes from being responded to quickly. Identifying long running CPU work in your app and moving it to background threads can help improve the reliability and responsiveness of your service. CPU bound work is more of a gray area than I/O bound work, and it is ultimately up to you to determine where you want to draw the line. A common example of heavy CPU bound work is Bcrypt hashing during user signup and login. Bcrypt is deliberately very slow and CPU intensive for security reasons. This may be the most CPU intensive work a simple web application actually does. Moving hashing to a background thread can allow the CPU to interleave event loop work while calculating hashes which results in higher concurrency.","title":"Async"},{"location":"async/#async","text":"You may have noticed some APIs in Vapor expect or return a generic EventLoopFuture type. If this is your first time hearing about futures, they might seem a little confusing at first. But don't worry, this guide will show you how to take advantage of their powerful APIs. Promises and futures are related, but distinct, types. Promises are used to create futures. Most of the time, you will be working with futures returned by Vapor's APIs and you will not need to worry about creating promises. type description mutability EventLoopFuture Reference to a value that may not be available yet. read-only EventLoopPromise A promise to provide some value asynchronously. read/write Futures are an alternative to callback-based asynchronous APIs. Futures can be chained and transformed in ways that simple closures cannot.","title":"Async"},{"location":"async/#transforming","text":"Just like optionals and arrays in Swift, futures can be mapped and flat-mapped. These are the most common operations you will perform on futures. method argument description map (T) -> U Maps a future value to a different value. flatMapThrowing (T) throws -> U Maps a future value to a different value or an error. flatMap (T) -> EventLoopFuture<U> Maps a future value to different future value. transform U Maps a future to an already available value. If you look at the method signatures for map and flatMap on Optional<T> and Array<T> , you will see that they are very similar to the methods available on EventLoopFuture<T> .","title":"Transforming"},{"location":"async/#map","text":"The map method allows you to transform the future's value to another value. Because the future's value may not be available yet (it may be the result of an asynchronous task) we must provide a closure to accept the value. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... /// Map the future string to an integer let futureInt = futureString . map { string in print ( string ) // The actual String return Int ( string ) ?? 0 } /// We now have a future integer print ( futureInt ) // EventLoopFuture<Int>","title":"map"},{"location":"async/#flatmapthrowing","text":"The flatMapThrowing method allows you to transform the future's value to another value or throw an error. Info Because throwing an error must create a new future internally, this method is prefixed flatMap even though the closure does not accept a future return. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... /// Map the future string to an integer let futureInt = futureString . flatMapThrowing { string in print ( string ) // The actual String // Convert the string to an integer or throw an error guard let int = Int ( string ) else { throw Abort (...) } return int } /// We now have a future integer print ( futureInt ) // EventLoopFuture<Int>","title":"flatMapThrowing"},{"location":"async/#flatmap","text":"The flatMap method allows you to transform the future's value to another future value. It gets the name \"flat\" map because it is what allows you to avoid creating nested futures (e.g., EventLoopFuture<EventLoopFuture<T>> ). In other words, it helps you keep your generics flat. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... /// Assume we have created an HTTP client let client : Client = ... /// flatMap the future string to a future response let futureResponse = futureString . flatMap { string in client . get ( string ) // EventLoopFuture<ClientResponse> } /// We now have a future response print ( futureResponse ) // EventLoopFuture<ClientResponse> Info If we instead used map in the above example, we would have ended up with: EventLoopFuture<EventLoopFuture<ClientResponse>> . To call a throwing method inside of a flatMap , use Swift's do / catch keywords and create a completed future . /// Assume future string and client from previous example. let futureResponse = futureString . flatMap { string in let url : URL do { // Some synchronous throwing method. url = try convertToURL ( string ) } catch { // Use event loop to make pre-completed future. return eventLoop . makeFailedFuture ( error ) } return client . get ( url ) // EventLoopFuture<ClientResponse> }","title":"flatMap"},{"location":"async/#transform","text":"The transform method allows you to modify a future's value, ignoring the existing value. This is especially useful for transforming the results of EventLoopFuture<Void> where the actual value of the future is not important. Tip EventLoopFuture<Void> , sometimes called a signal, is a future whose sole purpose is to notify you of completion or failure of some async operation. /// Assume we get a void future back from some API let userDidSave : EventLoopFuture < Void > = ... /// Transform the void future to an HTTP status let futureStatus = userDidSave . transform ( to : HTTPStatus . ok ) print ( futureStatus ) // EventLoopFuture<HTTPStatus> Even though we have supplied an already-available value to transform , this is still a transformation . The future will not complete until all previous futures have completed (or failed).","title":"transform"},{"location":"async/#chaining","text":"The great part about transformations on futures is that they can be chained. This allows you to express many conversions and subtasks easily. Let's modify the examples from above to see how we can take advantage of chaining. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... /// Assume we have created an HTTP client let client : Client = ... /// Transform the string to a url, then to a response let futureResponse = futureString . flatMapThrowing { string in guard let url = URL ( string : string ) else { throw Abort (. badRequest , reason : \"Invalid URL string: \\( string ) \" ) } return url }. flatMap { url in client . get ( url ) } print ( futureResponse ) // EventLoopFuture<ClientResponse> After the initial call to map, there is a temporary EventLoopFuture<URL> created. This future is then immediately flat-mapped to a EventLoopFuture<Response>","title":"Chaining"},{"location":"async/#future","text":"Let's take a look at some other methods for using EventLoopFuture<T> .","title":"Future"},{"location":"async/#makefuture","text":"You can use an event loop to create pre-completed future with either the value or an error. // Create a pre-succeeded future. let futureString : EventLoopFuture < String > = eventLoop . makeSucceededFuture ( \"hello\" ) // Create a pre-failed future. let futureString : EventLoopFuture < String > = eventLoop . makeFailedFuture ( error )","title":"makeFuture"},{"location":"async/#whencomplete","text":"You can use whenComplete to add a callback that will be executed when the future succeeds or fails. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... futureString . whenComplete { result in switch result { case . success ( let string ): print ( string ) // The actual String case . failure ( let error ): print ( error ) // A Swift Error } } Note You can add as many callbacks to a future as you want.","title":"whenComplete"},{"location":"async/#wait","text":"You can use .wait() to synchronously wait for the future to be completed. Since a future may fail, this call is throwing. /// Assume we get a future string back from some API let futureString : EventLoopFuture < String > = ... /// Block until the string is ready let string = try futureString . wait () print ( string ) /// String wait() can only be used on a background thread or the main thread, i.e., in configure.swift . It can not be used on an event loop thread, i.e., in route closures. Warning Attempting to call wait() on an event loop thread will cause an assertion failure.","title":"Wait"},{"location":"async/#promise","text":"Most of the time, you will be transforming futures returned by calls to Vapor's APIs. However, at some point you may need to create a promise of your own. To create a promise, you will need access to an EventLoop . You can get access to an event loop from Application or Request depending on context. let eventLoop : EventLoop // Create a new promise for some string. let promiseString = eventLoop . makePromise ( of : String . self ) print ( promiseString ) // EventLoopPromise<String> print ( promiseString . futureResult ) // EventLoopFuture<String> // Completes the associated future. promiseString . succeed ( \"Hello\" ) // Fails the associated future. promiseString . fail (...) Info A promise can only be completed once. Any subsequent completions will be ignored. Promises can be completed ( succeed / fail ) from any thread. This is why promises require an event loop to be initialized. Promises ensure that the completion action gets returned to its event loop for execution.","title":"Promise"},{"location":"async/#event-loop","text":"When your application boots, it will usually create one event loop for each core in the CPU it is running on. Each event loop has exactly one thread. If you are familiar with event loops from Node.js, the ones in Vapor are similar. The main difference is that Vapor can run multiple event loops in one process since Swift supports multi-threading. Each time a client connects to your server, it will be assigned to one of the event loops. From that point on, all communication between the server and that client will happen on that same event loop (and by association, that event loop's thread). The event loop is responsible for keeping track of each connected client's state. If there is a request from the client waiting to be read, the event loop triggers a read notification, causing the data to be read. Once the entire request is read, any futures waiting for that request's data will be completed. In route closures, you can access the current event loop via Request . req . eventLoop . makePromise ( of : ...) Warning Vapor expects that route closures will stay on req.eventLoop . If you hop threads, you must ensure access to Request and the final response future all happen on the request's event loop. Outside of route closures, you can get one of the available event loops via Application . app . eventLoopGroup . next (). makePromise ( of : ...)","title":"Event Loop"},{"location":"async/#hop","text":"You can change a future's event loop using hop . futureString . hop ( to : otherEventLoop )","title":"hop"},{"location":"async/#blocking","text":"Calling blocking code on an event loop thread can prevent your application from responding to incoming requests in a timely manner. An example of a blocking call would be something like libc.sleep(_:) . router . get ( \"hello\" ) { req in /// Puts the event loop's thread to sleep. sleep ( 5 ) /// Returns a simple string once the thread re-awakens. return \"Hello, world!\" } sleep(_:) is a command that blocks the current thread for the number of seconds supplied. If you do blocking work like this directly on an event loop, the event loop will be unable to respond to any other clients assigned to it for the duration of the blocking work. In other words, if you do sleep(5) on an event loop, all of the other clients connected to that event loop (possibly hundreds or thousands) will be delayed for at least 5 seconds. Make sure to run any blocking work in the background. Use promises to notify the event loop when this work is done in a non-blocking way. router . get ( \"hello\" ) { req -> EventLoopFuture < String > in /// Create a new void promise let promise = req . eventLoop . makePromise ( of : Void . self ) /// Dispatch some work to happen on a background thread req . application . threadPool . submit { _ in /// Puts the background thread to sleep /// This will not affect any of the event loops sleep ( 5 ) /// When the \"blocking work\" has completed, /// complete the promise and its associated future. promise . succeed () } /// Wait for the future to be completed, /// then transform the result to a simple String return promise . futureResult . transform ( to : \"Hello, world!\" ) } Not all blocking calls will be as obvious as sleep(_:) . If you are suspicious that a call you are using may be blocking, research the method itself or ask someone. The sections below go over how methods can block in more detail.","title":"Blocking"},{"location":"async/#io-bound","text":"I/O bound blocking means waiting on a slow resource like a network or hard disk which can be orders of magnitude slower than the CPU. Blocking the CPU while you wait for these resources results in wasted time. Danger Never make blocking I/O bound calls directly on an event loop. All of Vapor's packages are built on SwiftNIO and use non-blocking I/O. However, there are many Swift packages and C libraries in the wild that use blocking I/O. Chances are if a function is doing disk or network IO and uses a synchronous API (no callbacks or futures) it is blocking.","title":"I/O Bound"},{"location":"async/#cpu-bound","text":"Most of the time during a request is spent waiting for external resources like database queries and network requests to load. Because Vapor and SwiftNIO are non-blocking, this downtime can be used for fulfilling other incoming requests. However, some routes in your application may need to do heavy CPU bound work as the result of a request. While an event loop is processing CPU bound work, it will be unable to respond to other incoming requests. This is normally fine since CPUs are fast and most CPU work web applications do is lightweight. But this can become a problem if routes with long running CPU work are preventing requests to faster routes from being responded to quickly. Identifying long running CPU work in your app and moving it to background threads can help improve the reliability and responsiveness of your service. CPU bound work is more of a gray area than I/O bound work, and it is ultimately up to you to determine where you want to draw the line. A common example of heavy CPU bound work is Bcrypt hashing during user signup and login. Bcrypt is deliberately very slow and CPU intensive for security reasons. This may be the most CPU intensive work a simple web application actually does. Moving hashing to a background thread can allow the CPU to interleave event loop work while calculating hashes which results in higher concurrency.","title":"CPU Bound"},{"location":"authentication/","text":"Authentication \u00b6 Authentication is the act of verifying a user's identity. This is done through the verification of credentials like a username and password or unique token. Authentication (sometimes called auth/c) is distinct from authorization (auth/z) which is the act of verifying a previously authenticated user's permissions to perform certain tasks. Introduction \u00b6 Vapor's Authentication API provides support for authenticating a user via the Authorization header, using Basic and Bearer . It also supports authenticating a user via the data decoded from the Content API. Authentication is implemented by creating an Authenticator which contains the verification logic. An authenticator can be used to protect individual route groups or an entire app. The following authenticator helpers ship with Vapor: Protocol Description RequestAuthenticator Base authenticator capable of creating middleware. BasicAuthenticator Authenticates Basic authorization header. BearerAuthenticator Authenticates Bearer authorization header. UserTokenAuthenticator Authenticates a token type with associated user. CredentialsAuthenticator Authenticates a credentials payload from the request body. If authentication is successful, the authenticator adds the verified user to req.auth . This user can then be accessed using req.auth.get(_:) in routes protected by the authenticator. If authentication fails, the user is not added to req.auth and any attempts to access it will fail. Authenticatable \u00b6 To use the Authentication API, you first need a user type that conforms to Authenticatable . This can be a struct , class , or even a Fluent Model . The following examples assume this simple User struct that has one property: name . import Vapor struct User : Authenticatable { var name : String } Each example below will create an authenticator named UserAuthenticator . Route \u00b6 Authenticators are middleware and be be used for protecting routes. let protected = app . grouped ( UserAuthenticator ()) protected . get ( \"me\" ) { req -> String in try req . auth . require ( User . self ). name } req.auth.require is used to fetch the authenticated User . If authentication failed, this method will throw an error, protecting the route. Guard Middleware \u00b6 You can also use GuardMiddleware in your route group to ensure that a user has been authenticated before reaching your route handler. let protected = app . grouped ( UserAuthenticator ()) . grouped ( User . guardMiddleware ()) Requiring authentication is not done by the authenticator middleware to allow for composition of authenticators. Read more about composition below. Basic \u00b6 Basic authentication sends a username and password in the Authorization header. The username and password are concatenated with a colon (e.g. test:secret ), base-64 encoded, and prefixed with \"Basic \" . The following example request encodes the username test with password secret . GET /me HTTP / 1.1 Authorization : Basic dGVzdDpzZWNyZXQ= Basic authentication is typically used once to log a user in and generate a token. This minimizes how frequently the user's sensitive password must be sent. You should never send Basic authorization over a plaintext or unverified TLS connection. To implement Basic authentication in your app, create a new authenticator conforming to BasicAuthenticator . Below is an example authenticator hard-coded to verify the request from above. import Vapor struct UserAuthenticator : BasicAuthenticator { typealias User = App . User func authenticate ( basic : BasicAuthorization , for request : Request ) -> EventLoopFuture < User ? > { guard basic . username == \"test\" && basic . password == \"secret\" else { return request . eventLoop . makeSucceededFuture ( nil ) } let test = User ( name : \"Vapor\" ) return request . eventLoop . makeSucceededFuture ( test ) } } This protocol requires you to implement authenticate(basic:for:) which will be called when an incoming request contains the Authorization: Basic ... header. A BasicAuthorization struct containing the username and password is passed to the method. In this test authenticator, the username and password are tested against hard-coded values. In a real authenticator, you might check against a database or external API. This is why the authenticate method allows you to return a future. Tip Passwords should never be stored in a database as plaintext. Always use password hashes for comparison. If the authentication parameters are correct, in this case matching the hard-coded values, a User named Vapor is returned. If the authentication parameters do not match, nil is returned, which signifies authentication failed. If you add this authenticator to your app, and test the route defined above, you should see the name \"Vapor\" returned for a successful login. If the credentials are not correct, you should see a 401 Unauthorized error. Bearer \u00b6 Bearer authentication sends a token in the Authorization header. The token is prefixed with \"Bearer \" . The following example request sends the token foo . GET /me HTTP / 1.1 Authorization : Bearer foo Bearer authentication is commonly used for authentication of API endpoints. The user typically requests a Bearer token by sending credentials like a username and password to a login endpoint. This token may last minutes or days depending on the application's needs. As long as the token is valid, the user can use it in place of his or her credentials to authenticate against the API. If the token becomes invalid, a new one can be generated using the login endpoint. To implement Bearer authentication in your app, create a new authenticator conforming to BearerAuthenticator . Below is an example authenticator hard-coded to verify the request from above. import Vapor struct UserAuthenticator : BearerAuthenticator { typealias User = App . User func authenticate ( bearer : BearerAuthorization , for request : Request ) -> EventLoopFuture < User ? > { guard bearer . token == \"foo\" else { return request . eventLoop . makeSucceededFuture ( nil ) } let test = User ( name : \"Vapor\" ) return request . eventLoop . makeSucceededFuture ( test ) } } This protocol requires you to implement authenticate(bearer:for:) which will be called when an incoming request contains the Authorization: Bearer ... header. A BearerAuthorization struct containing the token is passed to the method. In this test authenticator, the token is tested against a hard-coded value. In a real authenticator, you might verify the token by checking against a database or using cryptographic measures, like is done with JWT. This is why the authenticate method allows you to return a future. Tip When implementing token verification, it's important to consider horizontal scalability. If your application needs to handle many users concurrently, authentication can be a potential bottlneck. Consider how your design will scale across multiple instances of your application running at once. If the authentication parameters are correct, in this case matching the hard-coded value, a User named Vapor is returned. If the authentication parameters do not match, nil is returned, which signifies authentication failed. If you add this authenticator to your app, and test the route defined above, you should see the name \"Vapor\" returned for a successful login. If the credentials are not correct, you should see a 401 Unauthorized error. Composition \u00b6 Multiple authenticators can be composed (combined together) to create more complex endpoint authentication. Since an authenticator middleware will not reject the request if authentication fails, more than one of these middleware can be chained together. Authenticators can composed in two key ways. Composing Methods \u00b6 The first method of authentication composition is chaining more than one authenticator for the same user type. Take the following example: app . grouped ( UserPasswordAuthenticator ()) . grouped ( UserTokenAuthenticator ()) . grouped ( User . guardMiddleware ()) . post ( \"login\" ) { req in let user = try req . auth . require ( User . self ) // Do something with user. } This example assumes two authenticators UserPasswordAuthenticator and UserTokenAuthenticator that both authenticate User . Both of these authenticators are added to the route group. Finally, GuardMiddleware is added after the authenticators to require that User was successfully authenticated. This composition of authenticators results in a route that can be accessed by either password or token. Such a route could allow a user to login and generate a token, then continue to use that token to generate new tokens. Composing Users \u00b6 The second method of authentication composition is chaining authenticators for different user types. Take the following example: app . grouped ( AdminAuthenticator ()) . grouped ( UserAuthenticator ()) . get ( \"secure\" ) { req in guard req . auth . has ( Admin . self ) || req . auth . has ( User . self ) else { throw Abort (. unauthorized ) } // Do something. } This example assumes two authenticators AdminAuthenticator and UserAuthenticator that authenticate Admin and User , respectively. Both of these authenticators are added to the route group. Instead of using GuardMiddleware , a check in the route handler is added to see if either Admin or User were authenticated. If not, an error is thrown. This composition of authenticators results in a route that can be accessed by two different types of users with potentially different methods of authentication. Such a route could allow for normal user authentication while still giving access to a super-user. Manual \u00b6 You can also handle authentication manually using req.auth . This is especially useful for testing. To manually log a user in, use req.auth.login(_:) . Any Authenticatable user can be passed to this method. req . auth . login ( User ( name : \"Vapor\" )) To get the authenticated user, use req.auth.require(_:) let user : User = try req . auth . require ( User . self ) print ( user . name ) // String You can also use req.auth.get(_:) if you don't want to automatically throw an error when authentication fails. let user = req . auth . get ( User . self ) print ( user ?. name ) // String? To unauthenticate a user, pass the user type to req.auth.logout(_:) . req . auth . logout ( User . self ) Fluent \u00b6 Fluent defines two protocols ModelAuthenticatable and ModelTokenAuthenticatable which can be added to your existing models. Conforming your models to these protocols allows for the creation of authenticators for protecting endpoints. ModelTokenAuthenticatable authenticates with a Bearer token. This is what you use to protect most of your endpoints. ModelAuthenticatable authenticates with username and password and is used by a single endpoint for generating tokens. This guide assumes you are familiar with Fluent and have successfully configured your app to use a database. If you are new to Fluent, start with the overview . User \u00b6 To start, you will need a model representing the user that will be authenticated. For this guide, we'll be using the following model, but you are free to use an existing model. import Fluent import Vapor final class User : Model , Content { static let schema = \"users\" @ ID ( key : . id ) var id : UUID ? @ Field ( key : \"name\" ) var name : String @ Field ( key : \"email\" ) var email : String @ Field ( key : \"password_hash\" ) var passwordHash : String init () { } init ( id : UUID ? = nil , name : String , email : String , passwordHash : String ) { self . id = id self . name = name self . email = email self . passwordHash = passwordHash } } The model must be able to store a username, in this case an email, and a password hash. The corresponding migration for this example model is here: import Fluent import Vapor extension User { struct Migration : Fluent . Migration { var name : String { \"CreateUser\" } func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"users\" ) . id () . field ( \"name\" , . string , . required ) . field ( \"email\" , . string , . required ) . field ( \"password_hash\" , . string , . required ) . create () } func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"users\" ). delete () } } } Don't forget to add the migration to app.migrations . app . migrations . add ( User . Migration ()) The first thing you will need is an endpoint to create new users. Let's use POST /users . Create a Content struct representing the data this endpoint expects. import Vapor extension User { struct Create : Content { var name : String var email : String var password : String var confirmPassword : String } } If you like, you can conform this struct to Validatable to add validation requirements. import Vapor extension User . Create : Validatable { static func validations ( _ validations : inout Validations ) { validations . add ( \"name\" , as : String . self , is : ! . empty ) validations . add ( \"email\" , as : String . self , is : . email ) validations . add ( \"password\" , as : String . self , is : . count ( 8. ..)) } } Now you can create the POST /users endpoint. app . post ( \"users\" ) { req -> EventLoopFuture < User > in try User . Create . validate ( req ) let create = try req . content . decode ( User . Create . self ) guard create . password == create . confirmPassword else { throw Abort (. badRequest , reason : \"Passwords did not match\" ) } let user = try User ( name : create . name , email : create . email , passwordHash : Bcrypt . hash ( create . password ) ) return user . save ( on : req . db ) . map { user } } This endpoint validates the incoming request, decodes the User.Create struct, and checks that the passwords match. It then uses the decoded data to create a new User and saves it to the database. The plaintext password is hashed using Bcrypt before saving to the database. Build and run the project, making sure to migrate the database first, then use the following request to create a new user. POST /users HTTP / 1.1 Content-Length : 97 Content-Type : application/json { \"name\" : \"Vapor\" , \"email\" : \"test@vapor.codes\" , \"password\" : \"secret\" , \"confirmPassword\" : \"secret\" } Model Authenticatable \u00b6 Now that you have a user model and an endpoint to create new users, let's conform the model to ModelAuthenticatable . This will allow for the model to be authenticated using username and password. import Fluent import Vapor extension User : ModelAuthenticatable { static let usernameKey = \\ User . $ email static let passwordHashKey = \\ User . $ passwordHash func verify ( password : String ) throws -> Bool { try Bcrypt . verify ( password , created : self . passwordHash ) } } This extension adds ModelAuthenticatable conformance to User . The first two properties specify which fields should be used for storing the username and password hash respectively. The \\ notation creates a key path to the fields that Fluent can use to access them. The last requirement is a method for verifying plaintext passwords sent in the Basic authentication header. Since we're using Bcrypt to hash the password during signup, we'll use Bcrypt to verify that the supplied password matches the stored password hash. Now that the User conforms to ModelAuthenticatable , we can create an authenticator for protecting the login route. let passwordProtected = app . grouped ( User . authenticator ()) passwordProtected . post ( \"login\" ) { req -> User in try req . auth . require ( User . self ) } ModelAuthenticatable adds a static method authenticator for creating an authenticator. Test that this route works by sending the following request. POST /login HTTP / 1.1 Authorization : Basic dGVzdEB2YXBvci5jb2RlczpzZWNyZXQ= This request passes the username test@vapor.codes and password secret via the Basic authentication header. You should see the previously created user returned. While you could theoretically use Basic authentication to protect all of your endpoints, it's recommended to use a separate token instead. This minimizes how often you must send the user's sensitive password over the Internet. It also makes authentication much faster since you only need to perform password hashing during login. User Token \u00b6 Create a new model for representing user tokens. import Fluent import Vapor final class UserToken : Model , Content { static let schema = \"user_tokens\" @ ID ( key : . id ) var id : UUID ? @ Field ( key : \"value\" ) var value : String @ Parent ( key : \"user_id\" ) var user : User init () { } init ( id : UUID ? = nil , value : String , userID : User . IDValue ) { self . id = id self . value = value self . $ user . id = userID } } This model must have a value field for storing the token's unique string. It must also have a parent-relation to the user model. You may add additional properties to this token as you see fit, such as an expiration date. Next, create a migration for this model. import Fluent extension UserToken { struct Migration : Fluent . Migration { var name : String { \"CreateUserToken\" } func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"user_tokens\" ) . id () . field ( \"value\" , . string , . required ) . field ( \"user_id\" , . uuid , . required , . references ( \"users\" , \"id\" )) . unique ( on : \"value\" ) . create () } func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"user_tokens\" ). delete () } } } Notice that this migration makes the value field unique. It also creates a foreign key reference between the user_id field and the users table. Don't forget to add the migration to app.migrations . app . migrations . add ( UserToken . Migration ()) Finally, add a method on User for generating a new token. This method will be used during login. extension User { func generateToken () throws -> UserToken { try . init ( value : [ UInt8 ]. random ( count : 16 ). base64 , userID : self . requireID () ) } } Here we're using [UInt8].random(count:) to generate a random token value. For this example, 16 bytes, or 128 bits, of random data are being used. You can adjust this number as you see fit. The random data is then base-64 encoded to make it easy to transmit in HTTP headers. Now that you can generate user tokens, update the POST /login route to create and return a token. let passwordProtected = app . grouped ( User . authenticator ()) passwordProtected . post ( \"login\" ) { req -> EventLoopFuture < UserToken > in let user = try req . auth . require ( User . self ) let token = try user . generateToken () return token . save ( on : req . db ) . map { token } } Test that this route works by using the same login request from above. You should now get a token upon logging in that looks something like: 8gtg300Jwdhc/Ffw784EXA== Hold onto the token you get as we'll use it shortly. Model Token Authenticatable \u00b6 Conform UserToken to ModelTokenAuthenticatable . This will allow for tokens to authenticate your User model. import Vapor import Fluent extension UserToken : ModelTokenAuthenticatable { static let valueKey = \\ UserToken . $ value static let userKey = \\ UserToken . $ user var isValid : Bool { true } } The first protocol requirement specifies which field stores the token's unique value. This is the value that will be sent in the Bearer authentication header. The second requirement specifies the parent-relation to the User model. This is how Fluent will look up the authenticated user. The final requirement is an isValid boolean. If this is false , the token will be deleted from the database and the user will not be authenticated. For simplicity, we'll make the tokens eternal by hard-coding this to true . Now that the token conforms to ModelTokenAuthenticatable , you can create an authenticator for protecting routes. Create a new endpoint GET /me for getting the currently authenticated user. let tokenProtected = app . grouped ( UserToken . authenticator ()) tokenProtected . get ( \"me\" ) { req -> User in try req . auth . require ( User . self ) } Similar to User , UserToken now has a static authenticator() method that can generate an authenticator. The authenticator will attempt to find a matching UserToken using the value provided in the Bearer authentication header. If it finds a match, it will fetch the related User and authenticate it. Test that this route works by sending the following HTTP request where the token is the value you saved from the POST /login request. GET /me HTTP / 1.1 Authorization : Bearer <token> You should see the authenticated User returned. Session \u00b6 Vapor's Session API can be used to automatically persist user authentication between requests. This works by storing a unique identifier for the user in the request's session data after successful login. On subsequent requests, the user's identifier is fetched from the session and used to authenticate the user before calling your route handler. Sessions are great for front-end web applications built in Vapor that serve HTML directly to web browsers. For APIs, we recommend using stateless, token-based authentication to persist user data between requests. Session Authenticatable \u00b6 To use session-based authentication, you will need a type that conforms to SessionAuthenticatable . For this example, we'll use a simple struct. import Vapor struct User { var email : String } To conform to SessionAuthenticatable , you will need to specify a sessionID . This is the value that will be stored in the session data and must uniquely identify the user. extension User : SessionAuthenticatable { var sessionID : String { self . email } } For our simple User type, we'll use the email address as the unique session identifier. Session Authenticator \u00b6 Next, we'll need a SessionAuthenticator to handle resolving instances of our User from the persisted session identifier. struct UserSessionAuthenticator : SessionAuthenticator { typealias User = App . User func authenticate ( sessionID : String , for request : Request ) -> EventLoopFuture < Void > { let user = User ( email : sessionID ) request . auth . login ( user ) return request . eventLoop . makeSucceededFuture (()) } } Since all the information we need to initialize our example User is contained in the session identifier, we can create and login the user synchronously. In a real-world application, you would likely use the session identifier to perform a database lookup or API request to fetch the rest of the user data before authenticating. Next, let's create a simple bearer authenticator to perform the initial authentication. struct UserBearerAuthenticator : BearerAuthenticator { func authenticate ( bearer : BearerAuthorization , for request : Request ) -> EventLoopFuture < Void > { if bearer . token == \"test\" { let user = User ( name : \"hello@vapor.codes\" ) request . auth . login ( user ) } return request . eventLoop . makeSucceededFuture (()) } } This authenticator will authenticate a user with the email hello@vapor.codes when the bearer token test is sent. Finally, let's combine all these pieces together in your application. // Create protected route group which requires user auth. let protected = app . routes . grouped ([ app . sessions . middleware , UserSessionAuthenticator (), UserBearerAuthenticator (), User . guardMiddleware (), ]) // Add GET /me route for reading user's email. protected . get ( \"me\" ) { req -> String in try req . auth . require ( User . self ). email } SessionsMiddleware is added first to enable session support on the application. More information about configuring sessions can be found in the Session API section. Next, the SessionAuthenticator is added. This handles authenticating the user if a session is active. If the authentication has not been persisted in the session yet, the request will be forwarded to the next authenticator. UserBearerAuthenticator will check the bearer token and authenticate the user if it equals \"test\" . Finally, User.guardMiddleware() will ensure that User has been authenticated by one of the previous middleware. If the user has not been authenticated, an error will be thrown. To test this route, first send the following request: GET /me HTTP / 1.1 authorization : Bearer test This will cause UserBearerAuthenticator to authenticate the user. Once authenticated, UserSessionAuthenticator will persist the user's identifier in session storage and generate a cookie. Use the cookie from the response in a second request to the route. GET /me HTTP / 1.1 cookie : vapor_session=123 This time, UserSessionAuthenticator will authenticate the user and you should again see the user's email returned. Model Session Authenticatable \u00b6 Fluent models can generate SessionAuthenticator s by conforming to ModelSessionAuthenticatable . This will use the model's unique identifier as the session identifier and automatically perform a database lookup to restore the model from the session. import Fluent final class User : Model { ... } // Allow this model to be persisted in sessions. extension User : ModelSessionAuthenticatable { } You can add ModelSessionAuthenticatable to any existing model as an empty conformance. Once added, a new static method will be available for creating a SessionAuthenticator for that model. User . sessionAuthenticator () This will use the application's default database for resolving the user. To specify a database, pass the identifier. User . sessionAuthenticator (. sqlite )","title":"Authentication"},{"location":"authentication/#authentication","text":"Authentication is the act of verifying a user's identity. This is done through the verification of credentials like a username and password or unique token. Authentication (sometimes called auth/c) is distinct from authorization (auth/z) which is the act of verifying a previously authenticated user's permissions to perform certain tasks.","title":"Authentication"},{"location":"authentication/#introduction","text":"Vapor's Authentication API provides support for authenticating a user via the Authorization header, using Basic and Bearer . It also supports authenticating a user via the data decoded from the Content API. Authentication is implemented by creating an Authenticator which contains the verification logic. An authenticator can be used to protect individual route groups or an entire app. The following authenticator helpers ship with Vapor: Protocol Description RequestAuthenticator Base authenticator capable of creating middleware. BasicAuthenticator Authenticates Basic authorization header. BearerAuthenticator Authenticates Bearer authorization header. UserTokenAuthenticator Authenticates a token type with associated user. CredentialsAuthenticator Authenticates a credentials payload from the request body. If authentication is successful, the authenticator adds the verified user to req.auth . This user can then be accessed using req.auth.get(_:) in routes protected by the authenticator. If authentication fails, the user is not added to req.auth and any attempts to access it will fail.","title":"Introduction"},{"location":"authentication/#authenticatable","text":"To use the Authentication API, you first need a user type that conforms to Authenticatable . This can be a struct , class , or even a Fluent Model . The following examples assume this simple User struct that has one property: name . import Vapor struct User : Authenticatable { var name : String } Each example below will create an authenticator named UserAuthenticator .","title":"Authenticatable"},{"location":"authentication/#route","text":"Authenticators are middleware and be be used for protecting routes. let protected = app . grouped ( UserAuthenticator ()) protected . get ( \"me\" ) { req -> String in try req . auth . require ( User . self ). name } req.auth.require is used to fetch the authenticated User . If authentication failed, this method will throw an error, protecting the route.","title":"Route"},{"location":"authentication/#guard-middleware","text":"You can also use GuardMiddleware in your route group to ensure that a user has been authenticated before reaching your route handler. let protected = app . grouped ( UserAuthenticator ()) . grouped ( User . guardMiddleware ()) Requiring authentication is not done by the authenticator middleware to allow for composition of authenticators. Read more about composition below.","title":"Guard Middleware"},{"location":"authentication/#basic","text":"Basic authentication sends a username and password in the Authorization header. The username and password are concatenated with a colon (e.g. test:secret ), base-64 encoded, and prefixed with \"Basic \" . The following example request encodes the username test with password secret . GET /me HTTP / 1.1 Authorization : Basic dGVzdDpzZWNyZXQ= Basic authentication is typically used once to log a user in and generate a token. This minimizes how frequently the user's sensitive password must be sent. You should never send Basic authorization over a plaintext or unverified TLS connection. To implement Basic authentication in your app, create a new authenticator conforming to BasicAuthenticator . Below is an example authenticator hard-coded to verify the request from above. import Vapor struct UserAuthenticator : BasicAuthenticator { typealias User = App . User func authenticate ( basic : BasicAuthorization , for request : Request ) -> EventLoopFuture < User ? > { guard basic . username == \"test\" && basic . password == \"secret\" else { return request . eventLoop . makeSucceededFuture ( nil ) } let test = User ( name : \"Vapor\" ) return request . eventLoop . makeSucceededFuture ( test ) } } This protocol requires you to implement authenticate(basic:for:) which will be called when an incoming request contains the Authorization: Basic ... header. A BasicAuthorization struct containing the username and password is passed to the method. In this test authenticator, the username and password are tested against hard-coded values. In a real authenticator, you might check against a database or external API. This is why the authenticate method allows you to return a future. Tip Passwords should never be stored in a database as plaintext. Always use password hashes for comparison. If the authentication parameters are correct, in this case matching the hard-coded values, a User named Vapor is returned. If the authentication parameters do not match, nil is returned, which signifies authentication failed. If you add this authenticator to your app, and test the route defined above, you should see the name \"Vapor\" returned for a successful login. If the credentials are not correct, you should see a 401 Unauthorized error.","title":"Basic"},{"location":"authentication/#bearer","text":"Bearer authentication sends a token in the Authorization header. The token is prefixed with \"Bearer \" . The following example request sends the token foo . GET /me HTTP / 1.1 Authorization : Bearer foo Bearer authentication is commonly used for authentication of API endpoints. The user typically requests a Bearer token by sending credentials like a username and password to a login endpoint. This token may last minutes or days depending on the application's needs. As long as the token is valid, the user can use it in place of his or her credentials to authenticate against the API. If the token becomes invalid, a new one can be generated using the login endpoint. To implement Bearer authentication in your app, create a new authenticator conforming to BearerAuthenticator . Below is an example authenticator hard-coded to verify the request from above. import Vapor struct UserAuthenticator : BearerAuthenticator { typealias User = App . User func authenticate ( bearer : BearerAuthorization , for request : Request ) -> EventLoopFuture < User ? > { guard bearer . token == \"foo\" else { return request . eventLoop . makeSucceededFuture ( nil ) } let test = User ( name : \"Vapor\" ) return request . eventLoop . makeSucceededFuture ( test ) } } This protocol requires you to implement authenticate(bearer:for:) which will be called when an incoming request contains the Authorization: Bearer ... header. A BearerAuthorization struct containing the token is passed to the method. In this test authenticator, the token is tested against a hard-coded value. In a real authenticator, you might verify the token by checking against a database or using cryptographic measures, like is done with JWT. This is why the authenticate method allows you to return a future. Tip When implementing token verification, it's important to consider horizontal scalability. If your application needs to handle many users concurrently, authentication can be a potential bottlneck. Consider how your design will scale across multiple instances of your application running at once. If the authentication parameters are correct, in this case matching the hard-coded value, a User named Vapor is returned. If the authentication parameters do not match, nil is returned, which signifies authentication failed. If you add this authenticator to your app, and test the route defined above, you should see the name \"Vapor\" returned for a successful login. If the credentials are not correct, you should see a 401 Unauthorized error.","title":"Bearer"},{"location":"authentication/#composition","text":"Multiple authenticators can be composed (combined together) to create more complex endpoint authentication. Since an authenticator middleware will not reject the request if authentication fails, more than one of these middleware can be chained together. Authenticators can composed in two key ways.","title":"Composition"},{"location":"authentication/#composing-methods","text":"The first method of authentication composition is chaining more than one authenticator for the same user type. Take the following example: app . grouped ( UserPasswordAuthenticator ()) . grouped ( UserTokenAuthenticator ()) . grouped ( User . guardMiddleware ()) . post ( \"login\" ) { req in let user = try req . auth . require ( User . self ) // Do something with user. } This example assumes two authenticators UserPasswordAuthenticator and UserTokenAuthenticator that both authenticate User . Both of these authenticators are added to the route group. Finally, GuardMiddleware is added after the authenticators to require that User was successfully authenticated. This composition of authenticators results in a route that can be accessed by either password or token. Such a route could allow a user to login and generate a token, then continue to use that token to generate new tokens.","title":"Composing Methods"},{"location":"authentication/#composing-users","text":"The second method of authentication composition is chaining authenticators for different user types. Take the following example: app . grouped ( AdminAuthenticator ()) . grouped ( UserAuthenticator ()) . get ( \"secure\" ) { req in guard req . auth . has ( Admin . self ) || req . auth . has ( User . self ) else { throw Abort (. unauthorized ) } // Do something. } This example assumes two authenticators AdminAuthenticator and UserAuthenticator that authenticate Admin and User , respectively. Both of these authenticators are added to the route group. Instead of using GuardMiddleware , a check in the route handler is added to see if either Admin or User were authenticated. If not, an error is thrown. This composition of authenticators results in a route that can be accessed by two different types of users with potentially different methods of authentication. Such a route could allow for normal user authentication while still giving access to a super-user.","title":"Composing Users"},{"location":"authentication/#manual","text":"You can also handle authentication manually using req.auth . This is especially useful for testing. To manually log a user in, use req.auth.login(_:) . Any Authenticatable user can be passed to this method. req . auth . login ( User ( name : \"Vapor\" )) To get the authenticated user, use req.auth.require(_:) let user : User = try req . auth . require ( User . self ) print ( user . name ) // String You can also use req.auth.get(_:) if you don't want to automatically throw an error when authentication fails. let user = req . auth . get ( User . self ) print ( user ?. name ) // String? To unauthenticate a user, pass the user type to req.auth.logout(_:) . req . auth . logout ( User . self )","title":"Manual"},{"location":"authentication/#fluent","text":"Fluent defines two protocols ModelAuthenticatable and ModelTokenAuthenticatable which can be added to your existing models. Conforming your models to these protocols allows for the creation of authenticators for protecting endpoints. ModelTokenAuthenticatable authenticates with a Bearer token. This is what you use to protect most of your endpoints. ModelAuthenticatable authenticates with username and password and is used by a single endpoint for generating tokens. This guide assumes you are familiar with Fluent and have successfully configured your app to use a database. If you are new to Fluent, start with the overview .","title":"Fluent"},{"location":"authentication/#user","text":"To start, you will need a model representing the user that will be authenticated. For this guide, we'll be using the following model, but you are free to use an existing model. import Fluent import Vapor final class User : Model , Content { static let schema = \"users\" @ ID ( key : . id ) var id : UUID ? @ Field ( key : \"name\" ) var name : String @ Field ( key : \"email\" ) var email : String @ Field ( key : \"password_hash\" ) var passwordHash : String init () { } init ( id : UUID ? = nil , name : String , email : String , passwordHash : String ) { self . id = id self . name = name self . email = email self . passwordHash = passwordHash } } The model must be able to store a username, in this case an email, and a password hash. The corresponding migration for this example model is here: import Fluent import Vapor extension User { struct Migration : Fluent . Migration { var name : String { \"CreateUser\" } func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"users\" ) . id () . field ( \"name\" , . string , . required ) . field ( \"email\" , . string , . required ) . field ( \"password_hash\" , . string , . required ) . create () } func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"users\" ). delete () } } } Don't forget to add the migration to app.migrations . app . migrations . add ( User . Migration ()) The first thing you will need is an endpoint to create new users. Let's use POST /users . Create a Content struct representing the data this endpoint expects. import Vapor extension User { struct Create : Content { var name : String var email : String var password : String var confirmPassword : String } } If you like, you can conform this struct to Validatable to add validation requirements. import Vapor extension User . Create : Validatable { static func validations ( _ validations : inout Validations ) { validations . add ( \"name\" , as : String . self , is : ! . empty ) validations . add ( \"email\" , as : String . self , is : . email ) validations . add ( \"password\" , as : String . self , is : . count ( 8. ..)) } } Now you can create the POST /users endpoint. app . post ( \"users\" ) { req -> EventLoopFuture < User > in try User . Create . validate ( req ) let create = try req . content . decode ( User . Create . self ) guard create . password == create . confirmPassword else { throw Abort (. badRequest , reason : \"Passwords did not match\" ) } let user = try User ( name : create . name , email : create . email , passwordHash : Bcrypt . hash ( create . password ) ) return user . save ( on : req . db ) . map { user } } This endpoint validates the incoming request, decodes the User.Create struct, and checks that the passwords match. It then uses the decoded data to create a new User and saves it to the database. The plaintext password is hashed using Bcrypt before saving to the database. Build and run the project, making sure to migrate the database first, then use the following request to create a new user. POST /users HTTP / 1.1 Content-Length : 97 Content-Type : application/json { \"name\" : \"Vapor\" , \"email\" : \"test@vapor.codes\" , \"password\" : \"secret\" , \"confirmPassword\" : \"secret\" }","title":"User"},{"location":"authentication/#model-authenticatable","text":"Now that you have a user model and an endpoint to create new users, let's conform the model to ModelAuthenticatable . This will allow for the model to be authenticated using username and password. import Fluent import Vapor extension User : ModelAuthenticatable { static let usernameKey = \\ User . $ email static let passwordHashKey = \\ User . $ passwordHash func verify ( password : String ) throws -> Bool { try Bcrypt . verify ( password , created : self . passwordHash ) } } This extension adds ModelAuthenticatable conformance to User . The first two properties specify which fields should be used for storing the username and password hash respectively. The \\ notation creates a key path to the fields that Fluent can use to access them. The last requirement is a method for verifying plaintext passwords sent in the Basic authentication header. Since we're using Bcrypt to hash the password during signup, we'll use Bcrypt to verify that the supplied password matches the stored password hash. Now that the User conforms to ModelAuthenticatable , we can create an authenticator for protecting the login route. let passwordProtected = app . grouped ( User . authenticator ()) passwordProtected . post ( \"login\" ) { req -> User in try req . auth . require ( User . self ) } ModelAuthenticatable adds a static method authenticator for creating an authenticator. Test that this route works by sending the following request. POST /login HTTP / 1.1 Authorization : Basic dGVzdEB2YXBvci5jb2RlczpzZWNyZXQ= This request passes the username test@vapor.codes and password secret via the Basic authentication header. You should see the previously created user returned. While you could theoretically use Basic authentication to protect all of your endpoints, it's recommended to use a separate token instead. This minimizes how often you must send the user's sensitive password over the Internet. It also makes authentication much faster since you only need to perform password hashing during login.","title":"Model Authenticatable"},{"location":"authentication/#user-token","text":"Create a new model for representing user tokens. import Fluent import Vapor final class UserToken : Model , Content { static let schema = \"user_tokens\" @ ID ( key : . id ) var id : UUID ? @ Field ( key : \"value\" ) var value : String @ Parent ( key : \"user_id\" ) var user : User init () { } init ( id : UUID ? = nil , value : String , userID : User . IDValue ) { self . id = id self . value = value self . $ user . id = userID } } This model must have a value field for storing the token's unique string. It must also have a parent-relation to the user model. You may add additional properties to this token as you see fit, such as an expiration date. Next, create a migration for this model. import Fluent extension UserToken { struct Migration : Fluent . Migration { var name : String { \"CreateUserToken\" } func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"user_tokens\" ) . id () . field ( \"value\" , . string , . required ) . field ( \"user_id\" , . uuid , . required , . references ( \"users\" , \"id\" )) . unique ( on : \"value\" ) . create () } func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"user_tokens\" ). delete () } } } Notice that this migration makes the value field unique. It also creates a foreign key reference between the user_id field and the users table. Don't forget to add the migration to app.migrations . app . migrations . add ( UserToken . Migration ()) Finally, add a method on User for generating a new token. This method will be used during login. extension User { func generateToken () throws -> UserToken { try . init ( value : [ UInt8 ]. random ( count : 16 ). base64 , userID : self . requireID () ) } } Here we're using [UInt8].random(count:) to generate a random token value. For this example, 16 bytes, or 128 bits, of random data are being used. You can adjust this number as you see fit. The random data is then base-64 encoded to make it easy to transmit in HTTP headers. Now that you can generate user tokens, update the POST /login route to create and return a token. let passwordProtected = app . grouped ( User . authenticator ()) passwordProtected . post ( \"login\" ) { req -> EventLoopFuture < UserToken > in let user = try req . auth . require ( User . self ) let token = try user . generateToken () return token . save ( on : req . db ) . map { token } } Test that this route works by using the same login request from above. You should now get a token upon logging in that looks something like: 8gtg300Jwdhc/Ffw784EXA== Hold onto the token you get as we'll use it shortly.","title":"User Token"},{"location":"authentication/#model-token-authenticatable","text":"Conform UserToken to ModelTokenAuthenticatable . This will allow for tokens to authenticate your User model. import Vapor import Fluent extension UserToken : ModelTokenAuthenticatable { static let valueKey = \\ UserToken . $ value static let userKey = \\ UserToken . $ user var isValid : Bool { true } } The first protocol requirement specifies which field stores the token's unique value. This is the value that will be sent in the Bearer authentication header. The second requirement specifies the parent-relation to the User model. This is how Fluent will look up the authenticated user. The final requirement is an isValid boolean. If this is false , the token will be deleted from the database and the user will not be authenticated. For simplicity, we'll make the tokens eternal by hard-coding this to true . Now that the token conforms to ModelTokenAuthenticatable , you can create an authenticator for protecting routes. Create a new endpoint GET /me for getting the currently authenticated user. let tokenProtected = app . grouped ( UserToken . authenticator ()) tokenProtected . get ( \"me\" ) { req -> User in try req . auth . require ( User . self ) } Similar to User , UserToken now has a static authenticator() method that can generate an authenticator. The authenticator will attempt to find a matching UserToken using the value provided in the Bearer authentication header. If it finds a match, it will fetch the related User and authenticate it. Test that this route works by sending the following HTTP request where the token is the value you saved from the POST /login request. GET /me HTTP / 1.1 Authorization : Bearer <token> You should see the authenticated User returned.","title":"Model Token Authenticatable"},{"location":"authentication/#session","text":"Vapor's Session API can be used to automatically persist user authentication between requests. This works by storing a unique identifier for the user in the request's session data after successful login. On subsequent requests, the user's identifier is fetched from the session and used to authenticate the user before calling your route handler. Sessions are great for front-end web applications built in Vapor that serve HTML directly to web browsers. For APIs, we recommend using stateless, token-based authentication to persist user data between requests.","title":"Session"},{"location":"authentication/#session-authenticatable","text":"To use session-based authentication, you will need a type that conforms to SessionAuthenticatable . For this example, we'll use a simple struct. import Vapor struct User { var email : String } To conform to SessionAuthenticatable , you will need to specify a sessionID . This is the value that will be stored in the session data and must uniquely identify the user. extension User : SessionAuthenticatable { var sessionID : String { self . email } } For our simple User type, we'll use the email address as the unique session identifier.","title":"Session Authenticatable"},{"location":"authentication/#session-authenticator","text":"Next, we'll need a SessionAuthenticator to handle resolving instances of our User from the persisted session identifier. struct UserSessionAuthenticator : SessionAuthenticator { typealias User = App . User func authenticate ( sessionID : String , for request : Request ) -> EventLoopFuture < Void > { let user = User ( email : sessionID ) request . auth . login ( user ) return request . eventLoop . makeSucceededFuture (()) } } Since all the information we need to initialize our example User is contained in the session identifier, we can create and login the user synchronously. In a real-world application, you would likely use the session identifier to perform a database lookup or API request to fetch the rest of the user data before authenticating. Next, let's create a simple bearer authenticator to perform the initial authentication. struct UserBearerAuthenticator : BearerAuthenticator { func authenticate ( bearer : BearerAuthorization , for request : Request ) -> EventLoopFuture < Void > { if bearer . token == \"test\" { let user = User ( name : \"hello@vapor.codes\" ) request . auth . login ( user ) } return request . eventLoop . makeSucceededFuture (()) } } This authenticator will authenticate a user with the email hello@vapor.codes when the bearer token test is sent. Finally, let's combine all these pieces together in your application. // Create protected route group which requires user auth. let protected = app . routes . grouped ([ app . sessions . middleware , UserSessionAuthenticator (), UserBearerAuthenticator (), User . guardMiddleware (), ]) // Add GET /me route for reading user's email. protected . get ( \"me\" ) { req -> String in try req . auth . require ( User . self ). email } SessionsMiddleware is added first to enable session support on the application. More information about configuring sessions can be found in the Session API section. Next, the SessionAuthenticator is added. This handles authenticating the user if a session is active. If the authentication has not been persisted in the session yet, the request will be forwarded to the next authenticator. UserBearerAuthenticator will check the bearer token and authenticate the user if it equals \"test\" . Finally, User.guardMiddleware() will ensure that User has been authenticated by one of the previous middleware. If the user has not been authenticated, an error will be thrown. To test this route, first send the following request: GET /me HTTP / 1.1 authorization : Bearer test This will cause UserBearerAuthenticator to authenticate the user. Once authenticated, UserSessionAuthenticator will persist the user's identifier in session storage and generate a cookie. Use the cookie from the response in a second request to the route. GET /me HTTP / 1.1 cookie : vapor_session=123 This time, UserSessionAuthenticator will authenticate the user and you should again see the user's email returned.","title":"Session Authenticator"},{"location":"authentication/#model-session-authenticatable","text":"Fluent models can generate SessionAuthenticator s by conforming to ModelSessionAuthenticatable . This will use the model's unique identifier as the session identifier and automatically perform a database lookup to restore the model from the session. import Fluent final class User : Model { ... } // Allow this model to be persisted in sessions. extension User : ModelSessionAuthenticatable { } You can add ModelSessionAuthenticatable to any existing model as an empty conformance. Once added, a new static method will be available for creating a SessionAuthenticator for that model. User . sessionAuthenticator () This will use the application's default database for resolving the user. To specify a database, pass the identifier. User . sessionAuthenticator (. sqlite )","title":"Model Session Authenticatable"},{"location":"client/","text":"Client \u00b6 Vapor's client API allows you to make HTTP calls to external resources. It is built on async-http-client and integrates with the content API. Overview \u00b6 You can get access to the default client via Application or in a route handler via Request . app . client // Client app . get ( \"test\" ) { req in req . client // Client } The application's client is useful for making HTTP requests during configuration time. If you are making HTTP requests in a route handler, always use the request's client. Methods \u00b6 To make a GET request, pass the desired URL to the get convenience method. req . client . get ( \"https://httpbin.org/status/200\" ). map { res in // Handle the response. } There are methods for each of the HTTP verbs like get , post , and delete . The client's response is returned as a future and contains the HTTP status, headers, and body. Content \u00b6 Vapor's content API is available for handling data in client requests and responses. To encode content or query parameters to the request, use the beforeSend closure. req . client . post ( \"https://httpbin.org/status/200\" ) { req in // Encode query string to the request URL. try req . query . encode ([ \"q\" : \"test\" ]) // Encode JSON to the request body. try req . content . encode ([ \"hello\" : \"world\" ]) }. map { res in // Handle the response. } To decode content from the response, use flatMapThrowing on the client's response future. req . client . get ( \"https://httpbin.org/json\" ). flatMapThrowing { res in try res . content . decode ( MyJSONResponse . self ) }. map { json in // Handle the json response. } Configuration \u00b6 You can configure the underlying HTTP client via the application. // Disable automatic redirect following. app . client . configuration . redirectConfiguration = . disallow Note that you must configure the default client before using it for the first time.","title":"Client"},{"location":"client/#client","text":"Vapor's client API allows you to make HTTP calls to external resources. It is built on async-http-client and integrates with the content API.","title":"Client"},{"location":"client/#overview","text":"You can get access to the default client via Application or in a route handler via Request . app . client // Client app . get ( \"test\" ) { req in req . client // Client } The application's client is useful for making HTTP requests during configuration time. If you are making HTTP requests in a route handler, always use the request's client.","title":"Overview"},{"location":"client/#methods","text":"To make a GET request, pass the desired URL to the get convenience method. req . client . get ( \"https://httpbin.org/status/200\" ). map { res in // Handle the response. } There are methods for each of the HTTP verbs like get , post , and delete . The client's response is returned as a future and contains the HTTP status, headers, and body.","title":"Methods"},{"location":"client/#content","text":"Vapor's content API is available for handling data in client requests and responses. To encode content or query parameters to the request, use the beforeSend closure. req . client . post ( \"https://httpbin.org/status/200\" ) { req in // Encode query string to the request URL. try req . query . encode ([ \"q\" : \"test\" ]) // Encode JSON to the request body. try req . content . encode ([ \"hello\" : \"world\" ]) }. map { res in // Handle the response. } To decode content from the response, use flatMapThrowing on the client's response future. req . client . get ( \"https://httpbin.org/json\" ). flatMapThrowing { res in try res . content . decode ( MyJSONResponse . self ) }. map { json in // Handle the json response. }","title":"Content"},{"location":"client/#configuration","text":"You can configure the underlying HTTP client via the application. // Disable automatic redirect following. app . client . configuration . redirectConfiguration = . disallow Note that you must configure the default client before using it for the first time.","title":"Configuration"},{"location":"commands/","text":"Commands \u00b6 Vapor's Command API allows you to build custom command-line functions and interact with the terminal. It is what Vapor's default commands like serve , routes , and migrate are built on. Default Commands \u00b6 You can learn more about Vapor's default commands using the --help option. vapor run --help You can use --help on a specific command to see what arguments and options it accepts. vapor run serve --help Custom Commands \u00b6 You can create your own commands by creating types conforming to Command . import Vapor struct HelloCommand : Command { ... } Adding the custom command to app.commands will make it available via vapor run . app . commands . use ( HelloCommand (), as : \"hello\" ) To conform to Command , you must implement the run method. This requires declaring a Signature . You must also provide default help text. import Vapor struct HelloCommand : Command { struct Signature : CommandSignature { } var help : String { \"Says hello\" } func run ( using context : CommandContext , signature : Signature ) throws { context . console . print ( \"Hello, world!\" ) } } This simple command example has no arguments or options, so leave the signature empty. You can get access to the current console via the supplied context. Console has many helpful methods for prompting user input, output formatting, and more. let name = context . console . ask ( \"What is your \\( \"name\" , color : . blue ) ?\" ) context . console . print ( \"Hello, \\( name ) \ud83d\udc4b\" ) Test your command by running: vapor run hello Cowsay \u00b6 Take a look at this re-creation of the famous cowsay command for an example of using @Argument and @Option . import Vapor struct Cowsay : Command { struct Signature : CommandSignature { @ Argument ( name : \"message\" ) var message : String @ Option ( name : \"eyes\" , short : \"e\" ) var eyes : String ? @ Option ( name : \"tongue\" , short : \"t\" ) var tongue : String ? } var help : String { \"Generates ASCII picture of a cow with a message.\" } func run ( using context : CommandContext , signature : Signature ) throws { let eyes = signature . eyes ?? \"oo\" let tongue = signature . tongue ?? \" \" let cow = # \"\"\" < $M > \\ ^__^ \\ ($E)\\_______ (__)\\ )\\/\\ $T ||----w | || || \"\"\" #. replacingOccurrences ( of : \"$M\" , with : signature . message ) . replacingOccurrences ( of : \"$E\" , with : eyes ) . replacingOccurrences ( of : \"$T\" , with : tongue ) context . console . print ( cow ) } } Try adding this to your application and running it. app . commands . use ( Cowsay (), as : \"cowsay\" ) vapor run cowsay sup --eyes ^^ --tongue \"U \"","title":"Commands"},{"location":"commands/#commands","text":"Vapor's Command API allows you to build custom command-line functions and interact with the terminal. It is what Vapor's default commands like serve , routes , and migrate are built on.","title":"Commands"},{"location":"commands/#default-commands","text":"You can learn more about Vapor's default commands using the --help option. vapor run --help You can use --help on a specific command to see what arguments and options it accepts. vapor run serve --help","title":"Default Commands"},{"location":"commands/#custom-commands","text":"You can create your own commands by creating types conforming to Command . import Vapor struct HelloCommand : Command { ... } Adding the custom command to app.commands will make it available via vapor run . app . commands . use ( HelloCommand (), as : \"hello\" ) To conform to Command , you must implement the run method. This requires declaring a Signature . You must also provide default help text. import Vapor struct HelloCommand : Command { struct Signature : CommandSignature { } var help : String { \"Says hello\" } func run ( using context : CommandContext , signature : Signature ) throws { context . console . print ( \"Hello, world!\" ) } } This simple command example has no arguments or options, so leave the signature empty. You can get access to the current console via the supplied context. Console has many helpful methods for prompting user input, output formatting, and more. let name = context . console . ask ( \"What is your \\( \"name\" , color : . blue ) ?\" ) context . console . print ( \"Hello, \\( name ) \ud83d\udc4b\" ) Test your command by running: vapor run hello","title":"Custom Commands"},{"location":"commands/#cowsay","text":"Take a look at this re-creation of the famous cowsay command for an example of using @Argument and @Option . import Vapor struct Cowsay : Command { struct Signature : CommandSignature { @ Argument ( name : \"message\" ) var message : String @ Option ( name : \"eyes\" , short : \"e\" ) var eyes : String ? @ Option ( name : \"tongue\" , short : \"t\" ) var tongue : String ? } var help : String { \"Generates ASCII picture of a cow with a message.\" } func run ( using context : CommandContext , signature : Signature ) throws { let eyes = signature . eyes ?? \"oo\" let tongue = signature . tongue ?? \" \" let cow = # \"\"\" < $M > \\ ^__^ \\ ($E)\\_______ (__)\\ )\\/\\ $T ||----w | || || \"\"\" #. replacingOccurrences ( of : \"$M\" , with : signature . message ) . replacingOccurrences ( of : \"$E\" , with : eyes ) . replacingOccurrences ( of : \"$T\" , with : tongue ) context . console . print ( cow ) } } Try adding this to your application and running it. app . commands . use ( Cowsay (), as : \"cowsay\" ) vapor run cowsay sup --eyes ^^ --tongue \"U \"","title":"Cowsay"},{"location":"content/","text":"Content \u00b6 Vapor's content API allows you to easily encode / decode Codable structs to / from HTTP messages. JSON encoding is used by default with out-of-the-box support for URL-Encoded Form and Multipart . The API is also configurable, allowing for you to add, modify, or replace encoding strategies for certain HTTP content types. Overview \u00b6 To understand how Vapor's content API works, you should first understand a few basics about HTTP messages. Take a look at the following example request. POST /greeting HTTP / 1.1 content-type : application/json content-length : 18 { \"hello\" : \"world\" } This request indicates that it contains JSON-encoded data using the content-type header and application/json media type. As promised, some JSON data follows after the headers in the body. Content Struct \u00b6 The first step to decoding this HTTP message is creating a Codable type that matches the expected structure. struct Greeting : Content { var hello : String } Conforming the type to Content will automatically add conformance to Codable alongside additional utilities for working with the content API. Once you have the content structure, you can decode it from the incoming request using req.content . app . post ( \"greeting\" ) { req in let greeting = try req . content . decode ( Greeting . self ) print ( greeting . hello ) // \"world\" return HTTPStatus . ok } The decode method uses the request's content type to find an appropriate decoder. If there is no decoder found, or the request does not contain the content type header, a 415 error will be thrown. That means that this route automatically accepts all of the other supported content types, such as url-encoded form: POST /greeting HTTP / 1.1 content-type : application/x-www-form-urlencoded content-length : 11 hello=world Supported Media Types \u00b6 Below are the media types the content API supports by default. name header value media type JSON application/json .json Multipart multipart/form-data .formData URL-Encoded Form application/x-www-form-urlencoded .urlEncodedForm Plaintext text/plain .plainText HTML text/html .html Not all media types support all Codable features. For example, JSON does not support top-level fragments and Plaintext does not support nested data. Query \u00b6 Vapor's Content APIs support handling URL encoded data in the URL's query string. Decoding \u00b6 To understand how decoding a URL query string works, take a look at the following example request. GET /hello?name=Vapor HTTP / 1.1 content-length : 0 Just like the APIs for handling HTTP message body content, the first step for parsing URL query strings is to create a struct that matches the expected structure. struct Hello : Content { var name : String ? } Note that name is an optional String since URL query strings should always be optional. If you want to require a parameter, use a route parameter instead. Now that you have a Content struct for this route's expected query string, you can decode it. app . get ( \"hello\" ) { req -> String in let hello = try req . query . decode ( Hello . self ) return \"Hello, \\( hello . name ?? \"Anonymous\" ) \" } This route would result in the following response given the example request from above: HTTP / 1.1 200 OK content-length : 12 Hello, Vapor If the query string were omitted, like in the following request, the name \"Anonymous\" would be used instead. GET /hello HTTP / 1.1 content-length : 0 Single Value \u00b6 In addition to decoding to a Content struct, Vapor also supports fetching single values from the query string using subscripts. let name : String ? = req . query [ \"name\" ] Override Defaults \u00b6 The default encoders and decoders used by Vapor's Content APIs can be configured. Global \u00b6 ContentConfiguration.global lets you change the encoders and decoders Vapor uses by default. This is useful for changing how your entire application parses and serializes data. // create a new JSON encoder that uses unix-timestamp dates let encoder = JSONEncoder () encoder . dateEncodingStrategy = . secondsSince1970 // override the global encoder used for the `.json` media type ContentConfiguration . global . use ( encoder : encoder , for : . json ) Mutating ContentConfiguration is usually done in configure.swift . One-Off \u00b6 Calls to encoding and decoding methods like req.content.decode support passing in custom coders for one-off usages. // create a new JSON decoder that uses unix-timestamp dates let decoder = JSONDecoder () decoder . dateDecodingStrategy = . secondsSince1970 // decodes Hello struct using custom decoder let hello = try req . content . decode ( Hello . self , using : decoder ) Custom Coders \u00b6 Applications and third-party packages can add support for media types that Vapor does not support by default by creating custom coders. Content \u00b6 Vapor specifies two protocols for coders capable of handling content in HTTP message bodies: ContentDecoder and ContentEncoder . public protocol ContentEncoder { func encode < E >( _ encodable : E , to body : inout ByteBuffer , headers : inout HTTPHeaders ) throws where E : Encodable } public protocol ContentDecoder { func decode < D >( _ decodable : D . Type , from body : ByteBuffer , headers : HTTPHeaders ) throws -> D where D : Decodable } Conforming to these protocols allows your custom coders to be registered to ContentConfiguration as specified above. URL Query \u00b6 Vapor specifies two protocols for coders capable of handling content in URL query strings: URLQueryDecoder and URLQueryEncoder . public protocol URLQueryDecoder { func decode < D >( _ decodable : D . Type , from url : URI ) throws -> D where D : Decodable } public protocol URLQueryEncoder { func encode < E >( _ encodable : E , to url : inout URI ) throws where E : Encodable } Conforming to these protocols allows your custom coders to be registered to ContentConfiguration for handling URL query strings using the use(urlEncoder:) and use(urlDecoder:) methods.","title":"Content"},{"location":"content/#content","text":"Vapor's content API allows you to easily encode / decode Codable structs to / from HTTP messages. JSON encoding is used by default with out-of-the-box support for URL-Encoded Form and Multipart . The API is also configurable, allowing for you to add, modify, or replace encoding strategies for certain HTTP content types.","title":"Content"},{"location":"content/#overview","text":"To understand how Vapor's content API works, you should first understand a few basics about HTTP messages. Take a look at the following example request. POST /greeting HTTP / 1.1 content-type : application/json content-length : 18 { \"hello\" : \"world\" } This request indicates that it contains JSON-encoded data using the content-type header and application/json media type. As promised, some JSON data follows after the headers in the body.","title":"Overview"},{"location":"content/#content-struct","text":"The first step to decoding this HTTP message is creating a Codable type that matches the expected structure. struct Greeting : Content { var hello : String } Conforming the type to Content will automatically add conformance to Codable alongside additional utilities for working with the content API. Once you have the content structure, you can decode it from the incoming request using req.content . app . post ( \"greeting\" ) { req in let greeting = try req . content . decode ( Greeting . self ) print ( greeting . hello ) // \"world\" return HTTPStatus . ok } The decode method uses the request's content type to find an appropriate decoder. If there is no decoder found, or the request does not contain the content type header, a 415 error will be thrown. That means that this route automatically accepts all of the other supported content types, such as url-encoded form: POST /greeting HTTP / 1.1 content-type : application/x-www-form-urlencoded content-length : 11 hello=world","title":"Content Struct"},{"location":"content/#supported-media-types","text":"Below are the media types the content API supports by default. name header value media type JSON application/json .json Multipart multipart/form-data .formData URL-Encoded Form application/x-www-form-urlencoded .urlEncodedForm Plaintext text/plain .plainText HTML text/html .html Not all media types support all Codable features. For example, JSON does not support top-level fragments and Plaintext does not support nested data.","title":"Supported Media Types"},{"location":"content/#query","text":"Vapor's Content APIs support handling URL encoded data in the URL's query string.","title":"Query"},{"location":"content/#decoding","text":"To understand how decoding a URL query string works, take a look at the following example request. GET /hello?name=Vapor HTTP / 1.1 content-length : 0 Just like the APIs for handling HTTP message body content, the first step for parsing URL query strings is to create a struct that matches the expected structure. struct Hello : Content { var name : String ? } Note that name is an optional String since URL query strings should always be optional. If you want to require a parameter, use a route parameter instead. Now that you have a Content struct for this route's expected query string, you can decode it. app . get ( \"hello\" ) { req -> String in let hello = try req . query . decode ( Hello . self ) return \"Hello, \\( hello . name ?? \"Anonymous\" ) \" } This route would result in the following response given the example request from above: HTTP / 1.1 200 OK content-length : 12 Hello, Vapor If the query string were omitted, like in the following request, the name \"Anonymous\" would be used instead. GET /hello HTTP / 1.1 content-length : 0","title":"Decoding"},{"location":"content/#single-value","text":"In addition to decoding to a Content struct, Vapor also supports fetching single values from the query string using subscripts. let name : String ? = req . query [ \"name\" ]","title":"Single Value"},{"location":"content/#override-defaults","text":"The default encoders and decoders used by Vapor's Content APIs can be configured.","title":"Override Defaults"},{"location":"content/#global","text":"ContentConfiguration.global lets you change the encoders and decoders Vapor uses by default. This is useful for changing how your entire application parses and serializes data. // create a new JSON encoder that uses unix-timestamp dates let encoder = JSONEncoder () encoder . dateEncodingStrategy = . secondsSince1970 // override the global encoder used for the `.json` media type ContentConfiguration . global . use ( encoder : encoder , for : . json ) Mutating ContentConfiguration is usually done in configure.swift .","title":"Global"},{"location":"content/#one-off","text":"Calls to encoding and decoding methods like req.content.decode support passing in custom coders for one-off usages. // create a new JSON decoder that uses unix-timestamp dates let decoder = JSONDecoder () decoder . dateDecodingStrategy = . secondsSince1970 // decodes Hello struct using custom decoder let hello = try req . content . decode ( Hello . self , using : decoder )","title":"One-Off"},{"location":"content/#custom-coders","text":"Applications and third-party packages can add support for media types that Vapor does not support by default by creating custom coders.","title":"Custom Coders"},{"location":"content/#content_1","text":"Vapor specifies two protocols for coders capable of handling content in HTTP message bodies: ContentDecoder and ContentEncoder . public protocol ContentEncoder { func encode < E >( _ encodable : E , to body : inout ByteBuffer , headers : inout HTTPHeaders ) throws where E : Encodable } public protocol ContentDecoder { func decode < D >( _ decodable : D . Type , from body : ByteBuffer , headers : HTTPHeaders ) throws -> D where D : Decodable } Conforming to these protocols allows your custom coders to be registered to ContentConfiguration as specified above.","title":"Content"},{"location":"content/#url-query","text":"Vapor specifies two protocols for coders capable of handling content in URL query strings: URLQueryDecoder and URLQueryEncoder . public protocol URLQueryDecoder { func decode < D >( _ decodable : D . Type , from url : URI ) throws -> D where D : Decodable } public protocol URLQueryEncoder { func encode < E >( _ encodable : E , to url : inout URI ) throws where E : Encodable } Conforming to these protocols allows your custom coders to be registered to ContentConfiguration for handling URL query strings using the use(urlEncoder:) and use(urlDecoder:) methods.","title":"URL Query"},{"location":"crypto/","text":"Crypto \u00b6 Vapor includes SwiftCrypto which is a Linux-compatible port of Apple's CryptoKit library. Some additional crypto APIs are exposed for things SwiftCrypto does not have yet, like Bcrypt and TOTP . SwiftCrypto \u00b6 Swift's Crypto library implements Apple's CryptoKit API. As such, the CryptoKit documentation and the WWDC talk are great resources for learning the API. These APIs will be available automatically when you import Vapor. import Vapor let digest = SHA256 . hash ( data : Data ( \"hello\" . utf8 )) print ( digest ) CryptoKit includes support for: Hashing: SHA512 , SHA384 , SHA256 Message Authentication Codes: HMAC Ciphers: AES , ChaChaPoly Public-Key Cryptography: Curve25519 , P521 , P384 , P256 Insecure hashing: SHA1 , MD5 Bcrypt \u00b6 Bcrypt is a password hashing algorithm that uses a randomized salt to ensure hashing the same password multiple times doesn't result in the same digest. Vapor provides a Bcrypt type for hashing and comparing passwords. import Vapor let digest = try Bcrypt . hash ( \"test\" ) Because Bcrypt uses a salt, password hashes cannot be compared directly. Both the plaintext password and the existing digest must be verified together. import Vapor let pass = try Bcrypt . verify ( \"test\" , created : digest ) if pass { // Password and digest match. } else { // Wrong password. } Login with Bcrypt passwords can be implemented by first fetching the user's password digest from the database by email or username. The known digest can then be verified against the supplied plaintext password. TOTP \u00b6 Coming soon.","title":"Crypto"},{"location":"crypto/#crypto","text":"Vapor includes SwiftCrypto which is a Linux-compatible port of Apple's CryptoKit library. Some additional crypto APIs are exposed for things SwiftCrypto does not have yet, like Bcrypt and TOTP .","title":"Crypto"},{"location":"crypto/#swiftcrypto","text":"Swift's Crypto library implements Apple's CryptoKit API. As such, the CryptoKit documentation and the WWDC talk are great resources for learning the API. These APIs will be available automatically when you import Vapor. import Vapor let digest = SHA256 . hash ( data : Data ( \"hello\" . utf8 )) print ( digest ) CryptoKit includes support for: Hashing: SHA512 , SHA384 , SHA256 Message Authentication Codes: HMAC Ciphers: AES , ChaChaPoly Public-Key Cryptography: Curve25519 , P521 , P384 , P256 Insecure hashing: SHA1 , MD5","title":"SwiftCrypto"},{"location":"crypto/#bcrypt","text":"Bcrypt is a password hashing algorithm that uses a randomized salt to ensure hashing the same password multiple times doesn't result in the same digest. Vapor provides a Bcrypt type for hashing and comparing passwords. import Vapor let digest = try Bcrypt . hash ( \"test\" ) Because Bcrypt uses a salt, password hashes cannot be compared directly. Both the plaintext password and the existing digest must be verified together. import Vapor let pass = try Bcrypt . verify ( \"test\" , created : digest ) if pass { // Password and digest match. } else { // Wrong password. } Login with Bcrypt passwords can be implemented by first fetching the user's password digest from the database by email or username. The known digest can then be verified against the supplied plaintext password.","title":"Bcrypt"},{"location":"crypto/#totp","text":"Coming soon.","title":"TOTP"},{"location":"environment/","text":"Environment \u00b6 Vapor's Environment API helps you configure your app dynamically. By default, your app will use the development environment. You can define other useful environments like production or staging and change how your app is configured in each case. You can also load in variables from the process's environment or .env (dotenv) files depending on your needs. To access the current environment, use app.environment . You can switch on this property in configure(_:) to execute different configuration logic. switch app . environment { case . production : app . databases . use (....) default : app . databases . use (...) } Changing Environment \u00b6 By default, your app will run in the development environment. You can change this by passing the --env ( -e ) flag during app boot. vapor run serve -- env production Vapor includes the following environments: name short description production prod Deployed to your users. development dev Local development. testing test For unit testing. Info The production environment will default to notice level logging unless otherwise specified. All other environments default to info . You can pass either the full or short name to the --env ( -e ) flag. vapor run serve - e prod Process Variables \u00b6 Environment offers a simple, string-based API for accessing the process's environment variables. let foo = Environment . get ( \"FOO\" ) print ( foo ) // String? In addition to get , Environment offers a dynamic member lookup API via process . let foo = Environment . process . FOO print ( foo ) // String? When running your app in the terminal, you can set environment variables using export . export FOO = BAR vapor run serve When running your app in Xcode, you can set environment variables by editing the Run scheme. .env (dotenv) \u00b6 Dotenv files contain a list of key-value pairs to be automatically loaded into the environment. These files make it easy to configure environment variables without needing to set them manually. Vapor will look for dotenv files in the current working directory. If you're using Xcode, make sure to set the working directory by editing the Run scheme. Assume the following .env file placed in your projects root folder: FOO = BAR When your application boots, you will be able to access the contents of this file like other process environment variables. let foo = Environment . get ( \"FOO\" ) print ( foo ) // String? Info Variables specified in .env files will not overwrite variables that already exist in the process environment. Alongside .env , Vapor will also attempt to load a dotenv file for the current environment. For example, when in the development environment, Vapor will load .env.development . Any values in the specific environment file will take precedence over the general .env file. A typical pattern is for projects to include a .env file as a template with default values. Specific environment files are ignored with the following pattern in .gitignore : .env.* When the project is cloned to a new computer, the template .env file can be copied and have the correct values inserted. cp .env .env.development vim .env.development Warning Dotenv files with sensitive information such as passwords should not be committed to version control. If you're having difficulty getting dotenv files to load, try enabling debug logging with --log debug for more information. Custom Environments \u00b6 To define a custom environment name, extend Environment . extension Environment { static var staging : Environment { . custom ( name : \"staging\" ) } } The application's environment is usually set in main.swift using Environment.detect() . import Vapor var env = try Environment . detect () try LoggingSystem . bootstrap ( from : & env ) let app = Application ( env ) defer { app . shutdown () } The detect method uses the process's command line arguments and parses the --env flag automatically. You can override this behavior by initializing a custom Environment struct. let env = Environment ( name : \"testing\" , arguments : [ \"vapor\" ]) The arguments array must contain at least one argument which represents the executable name. Further arguments can be supplied to simulate passing arguments via the command line. This is especially useful for testing.","title":"Environment"},{"location":"environment/#environment","text":"Vapor's Environment API helps you configure your app dynamically. By default, your app will use the development environment. You can define other useful environments like production or staging and change how your app is configured in each case. You can also load in variables from the process's environment or .env (dotenv) files depending on your needs. To access the current environment, use app.environment . You can switch on this property in configure(_:) to execute different configuration logic. switch app . environment { case . production : app . databases . use (....) default : app . databases . use (...) }","title":"Environment"},{"location":"environment/#changing-environment","text":"By default, your app will run in the development environment. You can change this by passing the --env ( -e ) flag during app boot. vapor run serve -- env production Vapor includes the following environments: name short description production prod Deployed to your users. development dev Local development. testing test For unit testing. Info The production environment will default to notice level logging unless otherwise specified. All other environments default to info . You can pass either the full or short name to the --env ( -e ) flag. vapor run serve - e prod","title":"Changing Environment"},{"location":"environment/#process-variables","text":"Environment offers a simple, string-based API for accessing the process's environment variables. let foo = Environment . get ( \"FOO\" ) print ( foo ) // String? In addition to get , Environment offers a dynamic member lookup API via process . let foo = Environment . process . FOO print ( foo ) // String? When running your app in the terminal, you can set environment variables using export . export FOO = BAR vapor run serve When running your app in Xcode, you can set environment variables by editing the Run scheme.","title":"Process Variables"},{"location":"environment/#env-dotenv","text":"Dotenv files contain a list of key-value pairs to be automatically loaded into the environment. These files make it easy to configure environment variables without needing to set them manually. Vapor will look for dotenv files in the current working directory. If you're using Xcode, make sure to set the working directory by editing the Run scheme. Assume the following .env file placed in your projects root folder: FOO = BAR When your application boots, you will be able to access the contents of this file like other process environment variables. let foo = Environment . get ( \"FOO\" ) print ( foo ) // String? Info Variables specified in .env files will not overwrite variables that already exist in the process environment. Alongside .env , Vapor will also attempt to load a dotenv file for the current environment. For example, when in the development environment, Vapor will load .env.development . Any values in the specific environment file will take precedence over the general .env file. A typical pattern is for projects to include a .env file as a template with default values. Specific environment files are ignored with the following pattern in .gitignore : .env.* When the project is cloned to a new computer, the template .env file can be copied and have the correct values inserted. cp .env .env.development vim .env.development Warning Dotenv files with sensitive information such as passwords should not be committed to version control. If you're having difficulty getting dotenv files to load, try enabling debug logging with --log debug for more information.","title":".env (dotenv)"},{"location":"environment/#custom-environments","text":"To define a custom environment name, extend Environment . extension Environment { static var staging : Environment { . custom ( name : \"staging\" ) } } The application's environment is usually set in main.swift using Environment.detect() . import Vapor var env = try Environment . detect () try LoggingSystem . bootstrap ( from : & env ) let app = Application ( env ) defer { app . shutdown () } The detect method uses the process's command line arguments and parses the --env flag automatically. You can override this behavior by initializing a custom Environment struct. let env = Environment ( name : \"testing\" , arguments : [ \"vapor\" ]) The arguments array must contain at least one argument which represents the executable name. Further arguments can be supplied to simulate passing arguments via the command line. This is especially useful for testing.","title":"Custom Environments"},{"location":"errors/","text":"Errors \u00b6 Vapor builds on Swift's Error protocol for error handling. Route handlers can either throw an error or return a failed EventLoopFuture . Throwing or returning a Swift Error will result in a 500 status response and the error will be logged. AbortError and DebuggableError can be used to change the resulting response and logging respectively. The handling of errors is done by ErrorMiddleware . This middleware is added to the application by default and can be replaced with custom logic if desired. Abort \u00b6 Vapor provides a default error struct named Abort . This struct conforms to both AbortError and DebuggableError . You can initialize it with an HTTP status and optional failure reason. // 400 error, default \"Not Found\" reason used. throw Abort (. notFound ) // 401 error, custom reason used. throw Abort (. unauthorized , reason : \"Invalid Credentials\" ) In asynchronous situations where throwing is not supported, like in a flatMap closure, you can return a failed future. guard let user = user else { req . eventLoop . makeFailedFuture ( Abort (. notFound )) } return user . save () Vapor includes a helper extension for unwrapping futures with optional values: unwrap(or:) . User . find ( id , on : db ) . unwrap ( or : Abort (. notFound )) . flatMap { user in // Non-optional User supplied to closure. } If User.find returns nil , the future will be failed with the supplied error. Otherwise, the flatMap will be supplied with a non-optional value. Abort Error \u00b6 By default, any Swift Error thrown or returned by a route closure will result in a 500 Internal Server Error response. When built in debug mode, ErrorMiddleware will include a description of the error. This is stripped out for security reasons when the project is built in release mode. To configure the resulting HTTP response status or reason for a particular error, conform it to AbortError . import Vapor enum MyError { case userNotLoggedIn case invalidEmail ( String ) } extension MyError : AbortError { var reason : String { switch self { case . userNotLoggedIn : return \"User is not logged in.\" case . invalidEmail ( let email ): return \"Email address is not valid: \\( email ) .\" } } var status : HTTPStatus { switch self { case . userNotLoggedIn : return . unauthorized case . invalidEmail : return . badRequest } } } Debuggable Error \u00b6 ErrorMiddleware uses the Logger.report(error:) method for logging errors thrown by your routes. This method will check for conformance to protocols like CustomStringConvertible and LocalizedError to log readable messages. To customize error logging, you can conform your errors to DebuggableError . This protocol includes a number of helpful properties like a unique identifier, source location, and stack trace. Most of these properties are optional which makes adopting the conformance easy. To best conform to DebuggableError , your error should be a struct so that it can store source and stack trace information if needed. Below is an example of the aforementioned MyError enum updated to use a struct and capture error source information. import Vapor struct MyError : DebuggableError { enum Value { case userNotLoggedIn case invalidEmail ( String ) } var identifier : String { switch self . value { case . userNotLoggedIn : return \"userNotLoggedIn\" case . invalidEmail : return \"invalidEmail\" } } var reason : String { switch self . value { case . userNotLoggedIn : return \"User is not logged in.\" case . invalidEmail ( let email ): return \"Email address is not valid: \\( email ) .\" } } var value : Value var source : ErrorSource ? init ( _ value : Value , file : String = #file , function : String = #function , line : UInt = #line , column : UInt = #column ) { self . value = value self . source = . init ( file : file , function : function , line : line , column : column ) } } DebuggableError has several other properties like possibleCauses and suggestedFixes that you can use to improve the debuggability of your errors. Take a look at the protocol itself for more information. Stack Traces \u00b6 Vapor includes support for viewing stack traces for both normal Swift errors and crashes. Swift Backtrace \u00b6 Vapor uses the SwiftBacktrace library to provide stack traces after a fatal error or assertion on Linux. In order for this to work, your app must include debug symbols during compilation. swift build -c release -Xswiftc -g Error Traces \u00b6 By default, Abort will capture the current stack trace when initialized. Your custom error types can achieve this by conforming to DebuggableError and storing StackTrace.capture() . import Vapor struct MyError : DebuggableError { var identifier : String var reason : String var stackTrace : StackTrace ? init ( identifier : String , reason : String , stackTrace : StackTrace ? = . capture () ) { self . identifier = identifier self . reason = reason self . stackTrace = stackTrace } } When your application's log level is set to .debug or lower, error stack traces will be included in log output. Stack traces will not be captured when the log level is greater than .debug . To override this behavior, set StackTrace.isCaptureEnabled manually in configure . // Always capture stack traces, regardless of log level. StackTrace . isCaptureEnabled = true Error Middleware \u00b6 ErrorMiddleware is the only middleware added to your application by default. This middleware converts Swift errors that have been thrown or returned by your route handlers into HTTP responses. Without this middleware, errors thrown will result in the connection being closed without a response. To customize error handling beyond what AbortError and DebuggableError provide, you can replace ErrorMiddleware with your own error handling logic. To do this, first remove the default error middleware by setting app.middleware to an empty configuration. Then, add your own error handling middleware as the first middleware to your application. // Remove all existing middleware. app . middleware = . init () // Add custom error handling middleware first. app . middleware . use ( MyErrorMiddleware ()) Very few middleware should go before the error handling middleware. A notable exception to this rule is CORSMiddleware .","title":"Errors"},{"location":"errors/#errors","text":"Vapor builds on Swift's Error protocol for error handling. Route handlers can either throw an error or return a failed EventLoopFuture . Throwing or returning a Swift Error will result in a 500 status response and the error will be logged. AbortError and DebuggableError can be used to change the resulting response and logging respectively. The handling of errors is done by ErrorMiddleware . This middleware is added to the application by default and can be replaced with custom logic if desired.","title":"Errors"},{"location":"errors/#abort","text":"Vapor provides a default error struct named Abort . This struct conforms to both AbortError and DebuggableError . You can initialize it with an HTTP status and optional failure reason. // 400 error, default \"Not Found\" reason used. throw Abort (. notFound ) // 401 error, custom reason used. throw Abort (. unauthorized , reason : \"Invalid Credentials\" ) In asynchronous situations where throwing is not supported, like in a flatMap closure, you can return a failed future. guard let user = user else { req . eventLoop . makeFailedFuture ( Abort (. notFound )) } return user . save () Vapor includes a helper extension for unwrapping futures with optional values: unwrap(or:) . User . find ( id , on : db ) . unwrap ( or : Abort (. notFound )) . flatMap { user in // Non-optional User supplied to closure. } If User.find returns nil , the future will be failed with the supplied error. Otherwise, the flatMap will be supplied with a non-optional value.","title":"Abort"},{"location":"errors/#abort-error","text":"By default, any Swift Error thrown or returned by a route closure will result in a 500 Internal Server Error response. When built in debug mode, ErrorMiddleware will include a description of the error. This is stripped out for security reasons when the project is built in release mode. To configure the resulting HTTP response status or reason for a particular error, conform it to AbortError . import Vapor enum MyError { case userNotLoggedIn case invalidEmail ( String ) } extension MyError : AbortError { var reason : String { switch self { case . userNotLoggedIn : return \"User is not logged in.\" case . invalidEmail ( let email ): return \"Email address is not valid: \\( email ) .\" } } var status : HTTPStatus { switch self { case . userNotLoggedIn : return . unauthorized case . invalidEmail : return . badRequest } } }","title":"Abort Error"},{"location":"errors/#debuggable-error","text":"ErrorMiddleware uses the Logger.report(error:) method for logging errors thrown by your routes. This method will check for conformance to protocols like CustomStringConvertible and LocalizedError to log readable messages. To customize error logging, you can conform your errors to DebuggableError . This protocol includes a number of helpful properties like a unique identifier, source location, and stack trace. Most of these properties are optional which makes adopting the conformance easy. To best conform to DebuggableError , your error should be a struct so that it can store source and stack trace information if needed. Below is an example of the aforementioned MyError enum updated to use a struct and capture error source information. import Vapor struct MyError : DebuggableError { enum Value { case userNotLoggedIn case invalidEmail ( String ) } var identifier : String { switch self . value { case . userNotLoggedIn : return \"userNotLoggedIn\" case . invalidEmail : return \"invalidEmail\" } } var reason : String { switch self . value { case . userNotLoggedIn : return \"User is not logged in.\" case . invalidEmail ( let email ): return \"Email address is not valid: \\( email ) .\" } } var value : Value var source : ErrorSource ? init ( _ value : Value , file : String = #file , function : String = #function , line : UInt = #line , column : UInt = #column ) { self . value = value self . source = . init ( file : file , function : function , line : line , column : column ) } } DebuggableError has several other properties like possibleCauses and suggestedFixes that you can use to improve the debuggability of your errors. Take a look at the protocol itself for more information.","title":"Debuggable Error"},{"location":"errors/#stack-traces","text":"Vapor includes support for viewing stack traces for both normal Swift errors and crashes.","title":"Stack Traces"},{"location":"errors/#swift-backtrace","text":"Vapor uses the SwiftBacktrace library to provide stack traces after a fatal error or assertion on Linux. In order for this to work, your app must include debug symbols during compilation. swift build -c release -Xswiftc -g","title":"Swift Backtrace"},{"location":"errors/#error-traces","text":"By default, Abort will capture the current stack trace when initialized. Your custom error types can achieve this by conforming to DebuggableError and storing StackTrace.capture() . import Vapor struct MyError : DebuggableError { var identifier : String var reason : String var stackTrace : StackTrace ? init ( identifier : String , reason : String , stackTrace : StackTrace ? = . capture () ) { self . identifier = identifier self . reason = reason self . stackTrace = stackTrace } } When your application's log level is set to .debug or lower, error stack traces will be included in log output. Stack traces will not be captured when the log level is greater than .debug . To override this behavior, set StackTrace.isCaptureEnabled manually in configure . // Always capture stack traces, regardless of log level. StackTrace . isCaptureEnabled = true","title":"Error Traces"},{"location":"errors/#error-middleware","text":"ErrorMiddleware is the only middleware added to your application by default. This middleware converts Swift errors that have been thrown or returned by your route handlers into HTTP responses. Without this middleware, errors thrown will result in the connection being closed without a response. To customize error handling beyond what AbortError and DebuggableError provide, you can replace ErrorMiddleware with your own error handling logic. To do this, first remove the default error middleware by setting app.middleware to an empty configuration. Then, add your own error handling middleware as the first middleware to your application. // Remove all existing middleware. app . middleware = . init () // Add custom error handling middleware first. app . middleware . use ( MyErrorMiddleware ()) Very few middleware should go before the error handling middleware. A notable exception to this rule is CORSMiddleware .","title":"Error Middleware"},{"location":"folder-structure/","text":"Folder Structure \u00b6 Now that you've created, built, and run your first Vapor app, let's take a moment to familiarize you with Vapor's folder structure. The structure is based on SPM 's folder structure, so if you've worked with SPM before it should be familiar. . \u251c\u2500\u2500 Public \u251c\u2500\u2500 Sources \u2502 \u251c\u2500\u2500 App \u2502 \u2502 \u251c\u2500\u2500 Controllers \u2502 \u2502 \u251c\u2500\u2500 Migrations \u2502 \u2502 \u251c\u2500\u2500 Models \u2502 \u2502 \u251c\u2500\u2500 app.swift \u2502 \u2502 \u251c\u2500\u2500 configure.swift \u2502 \u2502 \u2514\u2500\u2500 routes.swift \u2502 \u2514\u2500\u2500 Run \u2502 \u2514\u2500\u2500 main.swift \u251c\u2500\u2500 Tests \u2502 \u2514\u2500\u2500 AppTests \u2514\u2500\u2500 Package.swift The sections below explain each part of the folder structure in more detail. Public \u00b6 This folder contains any public files that will be served by your app if FileMiddleware is enabled. This is usually images, style sheets, and browser scripts. For example, a request to localhost:8080/favicon.ico will check to see if Public/favicon.ico exists and return it. You will need to enable FileMiddleware in your configure.swift file before Vapor can serve public files. // Serves files from `Public/` directory let fileMiddleware = FileMiddleware ( publicDirectory : app . directory . publicDirectory ) app . middleware . use ( fileMiddleware ) Sources \u00b6 This folder contains all of the Swift source files for your project. The top level folders, App and Run , reflect your package's modules, as declared in the SPM manifest. App \u00b6 This is where all of your application logic goes. Controllers \u00b6 Controllers are great way of grouping together application logic. Most controllers have many functions that accept a request and return some sort of response. Migrations \u00b6 The migrations folder is where your database migrations go if you are using Fluent. Models \u00b6 The models folder is a great place to store your Content structs or Fluent Model s. app.swift \u00b6 This file contains the app(_:) function which creates a configured instance of your Vapor Application . This method is used by the Run target's main.swift file to create and run your application. This method is also used in tests to create an instance of your application for testing. configure.swift \u00b6 This file contains the configure(_:) function. This method is called by app(_:) to configure the newly created Application . This is where you should register services like routes, databases, providers, and more. routes.swift \u00b6 This file contains the routes(_:) function. This method is called near the end of configure(_:) to register routes to your Application . Tests \u00b6 Each non-executable module in your Sources folder can have a corresponding folder in Tests . This contains code built on the XCTest module for testing your package. Tests can be run using swift test on the command line or pressing \u2318+U in Xcode. AppTests \u00b6 This folder contains the unit tests for code in your App module. Package.swift \u00b6 Finally is SPM 's package manifest.","title":"Folder Structure"},{"location":"folder-structure/#folder-structure","text":"Now that you've created, built, and run your first Vapor app, let's take a moment to familiarize you with Vapor's folder structure. The structure is based on SPM 's folder structure, so if you've worked with SPM before it should be familiar. . \u251c\u2500\u2500 Public \u251c\u2500\u2500 Sources \u2502 \u251c\u2500\u2500 App \u2502 \u2502 \u251c\u2500\u2500 Controllers \u2502 \u2502 \u251c\u2500\u2500 Migrations \u2502 \u2502 \u251c\u2500\u2500 Models \u2502 \u2502 \u251c\u2500\u2500 app.swift \u2502 \u2502 \u251c\u2500\u2500 configure.swift \u2502 \u2502 \u2514\u2500\u2500 routes.swift \u2502 \u2514\u2500\u2500 Run \u2502 \u2514\u2500\u2500 main.swift \u251c\u2500\u2500 Tests \u2502 \u2514\u2500\u2500 AppTests \u2514\u2500\u2500 Package.swift The sections below explain each part of the folder structure in more detail.","title":"Folder Structure"},{"location":"folder-structure/#public","text":"This folder contains any public files that will be served by your app if FileMiddleware is enabled. This is usually images, style sheets, and browser scripts. For example, a request to localhost:8080/favicon.ico will check to see if Public/favicon.ico exists and return it. You will need to enable FileMiddleware in your configure.swift file before Vapor can serve public files. // Serves files from `Public/` directory let fileMiddleware = FileMiddleware ( publicDirectory : app . directory . publicDirectory ) app . middleware . use ( fileMiddleware )","title":"Public"},{"location":"folder-structure/#sources","text":"This folder contains all of the Swift source files for your project. The top level folders, App and Run , reflect your package's modules, as declared in the SPM manifest.","title":"Sources"},{"location":"folder-structure/#app","text":"This is where all of your application logic goes.","title":"App"},{"location":"folder-structure/#controllers","text":"Controllers are great way of grouping together application logic. Most controllers have many functions that accept a request and return some sort of response.","title":"Controllers"},{"location":"folder-structure/#migrations","text":"The migrations folder is where your database migrations go if you are using Fluent.","title":"Migrations"},{"location":"folder-structure/#models","text":"The models folder is a great place to store your Content structs or Fluent Model s.","title":"Models"},{"location":"folder-structure/#appswift","text":"This file contains the app(_:) function which creates a configured instance of your Vapor Application . This method is used by the Run target's main.swift file to create and run your application. This method is also used in tests to create an instance of your application for testing.","title":"app.swift"},{"location":"folder-structure/#configureswift","text":"This file contains the configure(_:) function. This method is called by app(_:) to configure the newly created Application . This is where you should register services like routes, databases, providers, and more.","title":"configure.swift"},{"location":"folder-structure/#routesswift","text":"This file contains the routes(_:) function. This method is called near the end of configure(_:) to register routes to your Application .","title":"routes.swift"},{"location":"folder-structure/#tests","text":"Each non-executable module in your Sources folder can have a corresponding folder in Tests . This contains code built on the XCTest module for testing your package. Tests can be run using swift test on the command line or pressing \u2318+U in Xcode.","title":"Tests"},{"location":"folder-structure/#apptests","text":"This folder contains the unit tests for code in your App module.","title":"AppTests"},{"location":"folder-structure/#packageswift","text":"Finally is SPM 's package manifest.","title":"Package.swift"},{"location":"hello-world/","text":"Hello, world \u00b6 This guide will take you step by step through creating a new Vapor project, building it, and running the server. If you have not yet installed Swift or Vapor Toolbox, check out the install section. Install \u2192 macOS Install \u2192 Ubuntu New Project \u00b6 The first step is to create a new Vapor project on your computer. Open up your terminal and use Toolbox's new project command. This will create a new folder in the current directory containing the project. vapor-beta new hello -n Tip The -n flag gives you a bare bones template by automatically answering no to all questions. Once the command finishes, change into the newly created folder and open Xcode. cd hello open Package.swift Build & Run \u00b6 You should now have Xcode open. Click the play button to build and run your project. You should see the terminal pop up at the bottom of the screen. [ INFO ] Server starting on http://127.0.0.1:8080 Visit Localhost \u00b6 Open your web browser, and visit localhost:8080/hello You should see the following page. Hello, world! Congratulations on creating, building, and running your first Vapor app! \ud83c\udf89","title":"Hello, world"},{"location":"hello-world/#hello-world","text":"This guide will take you step by step through creating a new Vapor project, building it, and running the server. If you have not yet installed Swift or Vapor Toolbox, check out the install section. Install \u2192 macOS Install \u2192 Ubuntu","title":"Hello, world"},{"location":"hello-world/#new-project","text":"The first step is to create a new Vapor project on your computer. Open up your terminal and use Toolbox's new project command. This will create a new folder in the current directory containing the project. vapor-beta new hello -n Tip The -n flag gives you a bare bones template by automatically answering no to all questions. Once the command finishes, change into the newly created folder and open Xcode. cd hello open Package.swift","title":"New Project"},{"location":"hello-world/#build-run","text":"You should now have Xcode open. Click the play button to build and run your project. You should see the terminal pop up at the bottom of the screen. [ INFO ] Server starting on http://127.0.0.1:8080","title":"Build &amp; Run"},{"location":"hello-world/#visit-localhost","text":"Open your web browser, and visit localhost:8080/hello You should see the following page. Hello, world! Congratulations on creating, building, and running your first Vapor app! \ud83c\udf89","title":"Visit Localhost"},{"location":"logging/","text":"Logging \u00b6 Vapor's logging API is built on top of SwiftLog . This means Vapor is compatible with all of SwiftLog's backend implementations . Logger \u00b6 Instances of Logger are used for outputting log messages. Vapor provides a few easy ways to get access to a logger. Request \u00b6 Each incoming Request has a unique logger that you should use for any logs specific to that request. app . get ( \"hello\" ) { req -> String in req . logger . info ( \"Hello, logs!\" ) return \"Hello, world!\" } The request logger includes a unique UUID identifying the incoming request to make tracking logs easier. [ INFO ] Hello, logs! [request-id: C637065A-8CB0-4502-91DC-9B8615C5D315] (App/routes.swift:10) Info Logger metadata will only be shown in debug log level or lower. Application \u00b6 For log messages during app boot and configuration, use Application 's logger. app . logger . info ( \"Setting up migrations...\" ) app . migrations . use (...) Custom Logger \u00b6 In situations where you don't have access to Application or Request , you can initialize a new Logger . let logger = Logger ( label : \"dev.logger.my\" ) logger . info (...) While custom loggers will still output to your configured logging backend, they will not have important metadata attached like request UUID. Use the request or application specific loggers wherever possible. Level \u00b6 SwiftLog supports several different logging levels. name description trace Appropriate for messages that contain information only when debugging a program. debug Appropriate for messages that contain information normally of use only when debugging a program. info Appropriate for informational messages. notice Appropriate for conditions that are not error conditions, but that may require special handling. warning Appropriate for messages that are not error conditions, but more severe than notice. error Appropriate for error conditions. critical Appropriate for critical error conditions that usually require immediate attention. When a critical message is logged, the logging backend is free to perform more heavy-weight operations to capture system state (such as capturing stack traces) to facilitate debugging. By default, Vapor will use info level logging. When run with the production environment, notice will be used to improve performance. Changing Log Level \u00b6 Regardless of environment mode, you can override the logging level to increase or decrease the amount of logs produced. The first method is to pass the optional --log flag when booting your application. vapor run serve --log debug The second method is to set the LOG_LEVEL environment variable. export LOG_LEVEL = debug vapor run serve Both of these can be done in Xcode by editing the Run scheme. Configuration \u00b6 SwiftLog is configured by boostrapping the LoggingSystem once per process. Vapor projects typically do this in main.swift . import Vapor var env = try Environment . detect () try LoggingSystem . bootstrap ( from : & env ) bootstrap(from:) is a helper method provided by Vapor that will configure the default log handler based on command-line arguments and environment variables. The default log handler supports outputting messages to the terminal with ANSI color support. Custom Handler \u00b6 You can override Vapor's default log handler and register your own. import Logging LoggingSystem . bootstrap { label in StreamLogHandler . standardOutput ( label : label ) } All of SwiftLog's supported backends will work with Vapor. However, changing the log level with command-line arguments and environment variables is only compatible with Vapor's default log handler.","title":"Logging"},{"location":"logging/#logging","text":"Vapor's logging API is built on top of SwiftLog . This means Vapor is compatible with all of SwiftLog's backend implementations .","title":"Logging"},{"location":"logging/#logger","text":"Instances of Logger are used for outputting log messages. Vapor provides a few easy ways to get access to a logger.","title":"Logger"},{"location":"logging/#request","text":"Each incoming Request has a unique logger that you should use for any logs specific to that request. app . get ( \"hello\" ) { req -> String in req . logger . info ( \"Hello, logs!\" ) return \"Hello, world!\" } The request logger includes a unique UUID identifying the incoming request to make tracking logs easier. [ INFO ] Hello, logs! [request-id: C637065A-8CB0-4502-91DC-9B8615C5D315] (App/routes.swift:10) Info Logger metadata will only be shown in debug log level or lower.","title":"Request"},{"location":"logging/#application","text":"For log messages during app boot and configuration, use Application 's logger. app . logger . info ( \"Setting up migrations...\" ) app . migrations . use (...)","title":"Application"},{"location":"logging/#custom-logger","text":"In situations where you don't have access to Application or Request , you can initialize a new Logger . let logger = Logger ( label : \"dev.logger.my\" ) logger . info (...) While custom loggers will still output to your configured logging backend, they will not have important metadata attached like request UUID. Use the request or application specific loggers wherever possible.","title":"Custom Logger"},{"location":"logging/#level","text":"SwiftLog supports several different logging levels. name description trace Appropriate for messages that contain information only when debugging a program. debug Appropriate for messages that contain information normally of use only when debugging a program. info Appropriate for informational messages. notice Appropriate for conditions that are not error conditions, but that may require special handling. warning Appropriate for messages that are not error conditions, but more severe than notice. error Appropriate for error conditions. critical Appropriate for critical error conditions that usually require immediate attention. When a critical message is logged, the logging backend is free to perform more heavy-weight operations to capture system state (such as capturing stack traces) to facilitate debugging. By default, Vapor will use info level logging. When run with the production environment, notice will be used to improve performance.","title":"Level"},{"location":"logging/#changing-log-level","text":"Regardless of environment mode, you can override the logging level to increase or decrease the amount of logs produced. The first method is to pass the optional --log flag when booting your application. vapor run serve --log debug The second method is to set the LOG_LEVEL environment variable. export LOG_LEVEL = debug vapor run serve Both of these can be done in Xcode by editing the Run scheme.","title":"Changing Log Level"},{"location":"logging/#configuration","text":"SwiftLog is configured by boostrapping the LoggingSystem once per process. Vapor projects typically do this in main.swift . import Vapor var env = try Environment . detect () try LoggingSystem . bootstrap ( from : & env ) bootstrap(from:) is a helper method provided by Vapor that will configure the default log handler based on command-line arguments and environment variables. The default log handler supports outputting messages to the terminal with ANSI color support.","title":"Configuration"},{"location":"logging/#custom-handler","text":"You can override Vapor's default log handler and register your own. import Logging LoggingSystem . bootstrap { label in StreamLogHandler . standardOutput ( label : label ) } All of SwiftLog's supported backends will work with Vapor. However, changing the log level with command-line arguments and environment variables is only compatible with Vapor's default log handler.","title":"Custom Handler"},{"location":"middleware/","text":"Middleware \u00b6 Middleware is a logic chain between the client and a Vapor route handler. It allows you to perform operations on incoming requests before they get to the route handler and on outgoing responses before they go to the client. Configuration \u00b6 Middleware can be registered globally (on every route) in configure(_:) using app.middleware . app . middleware . use ( MyMiddleware ()) You can also add middleware to individual routes using route groups. let group = app . grouped ( MyMiddleware ()) group . get ( \"foo\" ) { req in // This request has passed through MyMiddleware. } Order \u00b6 The order in which middleware are added is important. Requests coming into your application will go through the middleware in the order they are added. Responses leaving your application will go back through the middleware in reverse order. Route-specific middleware always runs after application middleware. Take the following example: app . middleware . use ( MiddlewareA ()) app . middleware . use ( MiddlewareB ()) app . group ( MiddlewareC ()) { $0 . get ( \"hello\" ) { req in \"Hello, middleware.\" } } A request to GET /hello will visit middleware in the following order: Request \u2192 A \u2192 B \u2192 C \u2192 Handler \u2192 C \u2192 B \u2192 A \u2192 Response File Middleware \u00b6 FileMiddleware enables the serving of assets from the Public folder of your project to the client. You might include static files like stylesheets or bitmap images here. let file = FileMiddleware ( publicDirectory : app . directory . publicDirectory ) app . middleware . use ( file ) Once FileMiddleware is registered, a file like Public/images/logo.png can be linked from a Leaf template as <img src=\"/images/logo.png\"/> . CORS Middleware \u00b6 Cross-origin resource sharing (CORS) is a mechanism that allows restricted resources on a web page to be requested from another domain outside the domain from which the first resource was served. REST APIs built in Vapor will require a CORS policy in order to safely return requests to modern web browsers. An example configuration could look something like this: let corsConfiguration = CORSMiddleware . Configuration ( allowedOrigin : . all , allowedMethods : [. GET , . POST , . PUT , . OPTIONS , . DELETE , . PATCH ], allowedHeaders : [. accept , . authorization , . contentType , . origin , . xRequestedWith , . userAgent , . accessControlAllowOrigin ] ) let cors = CORSMiddleware ( configuration : corsConfiguration ) let error = ErrorMiddleware . default ( environment : app . environment ) // Clear any existing middleware. app . middleware = . init () app . middleware . use ( cors ) app . middleware . use ( error ) Given that thrown errors are immediately returned to the client, the CORSMiddleware must be listed before the ErrorMiddleware . Otherwise, the HTTP error response will be returned without CORS headers, and cannot be read by the browser.","title":"Middleware"},{"location":"middleware/#middleware","text":"Middleware is a logic chain between the client and a Vapor route handler. It allows you to perform operations on incoming requests before they get to the route handler and on outgoing responses before they go to the client.","title":"Middleware"},{"location":"middleware/#configuration","text":"Middleware can be registered globally (on every route) in configure(_:) using app.middleware . app . middleware . use ( MyMiddleware ()) You can also add middleware to individual routes using route groups. let group = app . grouped ( MyMiddleware ()) group . get ( \"foo\" ) { req in // This request has passed through MyMiddleware. }","title":"Configuration"},{"location":"middleware/#order","text":"The order in which middleware are added is important. Requests coming into your application will go through the middleware in the order they are added. Responses leaving your application will go back through the middleware in reverse order. Route-specific middleware always runs after application middleware. Take the following example: app . middleware . use ( MiddlewareA ()) app . middleware . use ( MiddlewareB ()) app . group ( MiddlewareC ()) { $0 . get ( \"hello\" ) { req in \"Hello, middleware.\" } } A request to GET /hello will visit middleware in the following order: Request \u2192 A \u2192 B \u2192 C \u2192 Handler \u2192 C \u2192 B \u2192 A \u2192 Response","title":"Order"},{"location":"middleware/#file-middleware","text":"FileMiddleware enables the serving of assets from the Public folder of your project to the client. You might include static files like stylesheets or bitmap images here. let file = FileMiddleware ( publicDirectory : app . directory . publicDirectory ) app . middleware . use ( file ) Once FileMiddleware is registered, a file like Public/images/logo.png can be linked from a Leaf template as <img src=\"/images/logo.png\"/> .","title":"File Middleware"},{"location":"middleware/#cors-middleware","text":"Cross-origin resource sharing (CORS) is a mechanism that allows restricted resources on a web page to be requested from another domain outside the domain from which the first resource was served. REST APIs built in Vapor will require a CORS policy in order to safely return requests to modern web browsers. An example configuration could look something like this: let corsConfiguration = CORSMiddleware . Configuration ( allowedOrigin : . all , allowedMethods : [. GET , . POST , . PUT , . OPTIONS , . DELETE , . PATCH ], allowedHeaders : [. accept , . authorization , . contentType , . origin , . xRequestedWith , . userAgent , . accessControlAllowOrigin ] ) let cors = CORSMiddleware ( configuration : corsConfiguration ) let error = ErrorMiddleware . default ( environment : app . environment ) // Clear any existing middleware. app . middleware = . init () app . middleware . use ( cors ) app . middleware . use ( error ) Given that thrown errors are immediately returned to the client, the CORSMiddleware must be listed before the ErrorMiddleware . Otherwise, the HTTP error response will be returned without CORS headers, and cannot be read by the browser.","title":"CORS Middleware"},{"location":"passwords/","text":"Passwords \u00b6 Vapor includes a password hashing API to help you store and verify passwords securely. This API is configurable based on environment and supports asynchronous hashing. Configuration \u00b6 To configure the Application's password hasher, use app.passwords . import Vapor app . passwords . use (...) Bcrypt \u00b6 To use Vapor's Bcrypt API for password hashing, specify .bcrypt . This is the default. app . passwords . use (. bcrypt ) Bcrypt will use a cost of 12 unless otherwise specified. You can configure this by passing the cost parameter. app . passwords . use (. bcrypt ( cost : 8 )) Plaintext \u00b6 Vapor includes an insecure password hasher that stores and verifies passwords as plaintext. This should not be used in production but can be useful for testing. switch app . environment { case . testing : app . passwords . use (. plaintext ) default : break } Hashing \u00b6 To hash passwords, use the password helper available on Request . let digest = try req . password . hash ( \"vapor\" ) Password digests can be verified against the plaintext password using the verify method. let bool = try req . password . verify ( \"vapor\" , created : digest ) The same API is available on Application for use during boot. let digest = try app . password . hash ( \"vapor\" ) Async \u00b6 Password hashing algorithms are designed to be slow and CPU intensive. Because of this, you may want to avoid blocking the event loop while hashing passwords. Vapor provides an asynchronous password hashing API that dispatches hashing to a background thread pool. To use the asynchronous API, use the async property on a password hasher. req . password . async . hash ( \"vapor\" ). map { digest in // Handle digest. } Verifying digests works similarly: req . password . async . verify ( \"vapor\" , created : digest ). map { bool in // Handle result. } Calculating hashes on background threads can free your application's event loops up to handle more incoming requests.","title":"Passwords"},{"location":"passwords/#passwords","text":"Vapor includes a password hashing API to help you store and verify passwords securely. This API is configurable based on environment and supports asynchronous hashing.","title":"Passwords"},{"location":"passwords/#configuration","text":"To configure the Application's password hasher, use app.passwords . import Vapor app . passwords . use (...)","title":"Configuration"},{"location":"passwords/#bcrypt","text":"To use Vapor's Bcrypt API for password hashing, specify .bcrypt . This is the default. app . passwords . use (. bcrypt ) Bcrypt will use a cost of 12 unless otherwise specified. You can configure this by passing the cost parameter. app . passwords . use (. bcrypt ( cost : 8 ))","title":"Bcrypt"},{"location":"passwords/#plaintext","text":"Vapor includes an insecure password hasher that stores and verifies passwords as plaintext. This should not be used in production but can be useful for testing. switch app . environment { case . testing : app . passwords . use (. plaintext ) default : break }","title":"Plaintext"},{"location":"passwords/#hashing","text":"To hash passwords, use the password helper available on Request . let digest = try req . password . hash ( \"vapor\" ) Password digests can be verified against the plaintext password using the verify method. let bool = try req . password . verify ( \"vapor\" , created : digest ) The same API is available on Application for use during boot. let digest = try app . password . hash ( \"vapor\" )","title":"Hashing"},{"location":"passwords/#async","text":"Password hashing algorithms are designed to be slow and CPU intensive. Because of this, you may want to avoid blocking the event loop while hashing passwords. Vapor provides an asynchronous password hashing API that dispatches hashing to a background thread pool. To use the asynchronous API, use the async property on a password hasher. req . password . async . hash ( \"vapor\" ). map { digest in // Handle digest. } Verifying digests works similarly: req . password . async . verify ( \"vapor\" , created : digest ). map { bool in // Handle result. } Calculating hashes on background threads can free your application's event loops up to handle more incoming requests.","title":"Async"},{"location":"queues/","text":"Queues \u00b6 Vapor Queues ( vapor/queues ) is a pure Swift queuing system that allows you to offload task responsibility to a side worker. Some of the tasks this package works well for: Sending emails outside of the main request thread Performing complex or long-running database operations Ensuring job integrity and resilience Speeding up response time by delaying non-critical processing Scheduling jobs to occur at a specific time This package is similar to Ruby Sidekiq . It provides the following features: Safe handling of SIGTERM and SIGINT signals sent by hosting providers to indicate a shutdown, restart, or new deploy. Different queue priorities. For example, you can specify a queue job to be run on the email queue and another job to be run on the data-processing queue. Implements the reliable queue process to help with unexpected failures. Includes a maxRetryCount feature that will repeat the job until it succeeds up until a specified count. Uses NIO to utilize all available cores and EventLoops for jobs. Allows users to schedule repeating tasks Queues currently has one officially supported driver which interfaces with the main protocol: QueuesRedisDriver Queues also has community-based drivers: - JobsPostgresqlDriver Tip You should not install the vapor/queues package directly unless you are building a new driver. Install one of the driver packages instead. Getting Started \u00b6 Let's take a look at how you can get started using Queues. Package \u00b6 The first step to using Queues is adding one of the drivers as a dependency to your project in your SwiftPM package manifest file. In this example, we'll use the Redis driver. // swift-tools-version:5.2 import PackageDescription let package = Package ( name : \"MyApp\" , dependencies : [ /// Any other dependencies ... . package ( url : \"https://github.com/vapor/queues-redis-driver.git\" , from : \"1.0.0\" ), ], targets : [ . target ( name : \"App\" , dependencies : [ . product ( name : \"QueuesRedisDriver\" , package : \"queues-redis-driver\" ) ]), . target ( name : \"Run\" , dependencies : [. target ( name : \"App\" )]), . testTarget ( name : \"AppTests\" , dependencies : [. target ( name : \"App\" )]), ] ) If you edit the manifest directly inside Xcode, it will automatically pick up the changes and fetch the new dependency when the file is saved. Otherwise, from Terminal, run swift package resolve to fetch the new dependency. Config \u00b6 The next step is to configure Queues in configure.swift . We'll use the Redis library as an example: try app . queues . use (. redis ( url : \"redis://127.0.0.1:6379\" )) Registering a Job \u00b6 After modeling a job you must add it to your configuration section like this: //Register jobs let emailJob = EmailJob () app . queues . add ( emailJob ) Running Workers as Processes \u00b6 To start a new queue worker, run vapor run queues . You can also specify a specific type of worker to run: vapor run queues --queue emails . Tip Workers should stay running in production. Consult your hosting provider to find out how to keep long-running processes alive. Heroku, for example, allows you to specify \"worker\" dynos like this in your Procfile: worker: Run run queues Running Workers in-process \u00b6 To run a worker in the same process as your application (as opposed to starting a whole separate server to handle it), call the convenience methods on Application : try app . queues . startInProcessJobs ( on : . default ) To run scheduled jobs in process, call the following method: try app . queues . startScheduledJobs () Warning If you don't start the queue worker either via command line or the in-process worker the jobs will not dispatch. The Job Protocol \u00b6 Jobs are defined by the Job protocol. Modeling a Job object: \u00b6 import Vapor import Foundation import Queues struct Email : Codable { let to : String let message : String } struct EmailJob : Job { typealias Payload = Email func dequeue ( _ context : QueueContext , _ payload : Email ) -> EventLoopFuture < Void > { // This is where you would send the email return context . eventLoop . future () } func error ( _ context : QueueContext , _ error : Error , _ payload : Email ) -> EventLoopFuture < Void > { // If you don't want to handle errors you can simply return a future. You can also omit this function entirely. return context . eventLoop . future () } } Tip Don't forget to follow the instructions in Getting Started to add this job to your configuration file. Dispatching Jobs \u00b6 To dispatch a queue job, you need access to an instance of Application or Request . You will most likely be dispatching jobs inside of a route handler: app . get ( \"email\" ) { req -> EventLoopFuture < String > in return req . queue . dispatch ( EmailJob . self , . init ( to : \"email@email.com\" , message : \"message\" ) ). map { \"done\" } } Setting maxRetryCount \u00b6 Jobs will automatically retry themselves upon error if you specify a maxRetryCount . For example: app . get ( \"email\" ) { req -> EventLoopFuture < String > in return req . queue . dispatch ( EmailJob . self , . init ( to : \"email@email.com\" , message : \"message\" ), maxRetryCount : 3 ). map { \"done\" } } Specifying a delay \u00b6 Jobs can also be set to only run after a certain Date has passed. To specify a delay, pass a Date into the delayUntil parameter in dispatch : app . get ( \"email\" ) { req -> EventLoopFuture < String > in let futureDate = Date ( timeIntervalSinceNow : 60 * 60 * 24 ) // One day return req . queue . dispatch ( EmailJob . self , . init ( to : \"email@email.com\" , message : \"message\" ), maxRetryCount : 3 , delayUntil : futureDate ). map { \"done\" } } If a job is dequeued before its delay parameter, the job will be re-queued by the driver. Specify a priority \u00b6 Jobs can be sorted into different queue types/priorities depending on your needs. For example, you may want to open an email queue and a background-processing queue to sort jobs. Start by extending JobsQueueName : extension JobsQueueName { static let emails = JobsQueueName ( string : \"emails\" ) } Then, specify the queue type when you retrieve the jobs object: app . get ( \"email\" ) { req -> EventLoopFuture < String > in let futureDate = Date ( timeIntervalSinceNow : 60 * 60 * 24 ) // One day return req . queues (. emails ) . dispatch ( EmailJob . self , . init ( to : \"email@email.com\" , message : \"message\" ), maxRetryCount : 3 , delayUntil : futureDate ). map { \"done\" } } If you do not specify a queue the job will be run on the default queue. Make sure to follow the instructions in Getting Started to start workers for each queue type. Scheduling Jobs \u00b6 The Queues package also allows you to schedule jobs to occur at certain points in time. Starting the scheduler worker \u00b6 The scheduler requires a separate worker process to be running, similar to the queue worker. You can start the worker by running this command: swift run Run queues --scheduled Tip Workers should stay running in production. Consult your hosting provider to find out how to keep long-running processes alive. Heroku, for example, allows you to specify \"worker\" dynos like this in your Procfile: worker: Run run queues --scheduled Creating a ScheduledJob \u00b6 To being, start by creating a new ScheduledJob : import Vapor import Jobs struct CleanupJob : ScheduledJob { // Add extra services here via dependency injection, if you need them. func run ( context : QueueContext ) -> EventLoopFuture < Void > { // Do some work here, perhaps queue up another job. return context . eventLoop . makeSucceededFuture (()) } } Then, in your configure code, register the scheduled job: app . queues . schedule ( CleanupJob ()) . yearly () . in (. may ) . on ( 23 ) . at (. noon ) The job in the example above will be run every year on May 23rd at 12:00 PM. Tip The Scheduler takes the timezone of your server. Available builder methods \u00b6 There are five main methods that can be called on a scheduler, each of which creates its respective builder object that contains more helper methods. You should continue building out a scheduler object until the compiler does not give you a warning about an unused result. See below for all available methods: Helper Function Available Modifiers Description yearly() in(_ month: Month) -> Monthly The month to run the job in. Returns a Monthly object for further building. monthly() on(_ day: Day) -> Daily The day to run the job in. Returns a Daily object for further building. weekly() on(_ weekday: Weekday) -> Daily The day of the week to run the job on. Returns a Daily object. daily() at(_ time: Time) The time to run the job on. Final method in the chain. at(_ hour: Hour24, _ minute: Minute) The hour and minute to run the job on. Final method in the chain. at(_ hour: Hour12, _ minute: Minute, _ period: HourPeriod) The hour, minute, and period to run the job on. Final method of the chain hourly() at(_ minute: Minute) The minute to run the job at. Final method of the chain. Available helpers \u00b6 Queues ships with some helpers enums to make scheduling easier: Helper Function Available Helper Enum yearly() .january , .february , .march , ... monthly() .first , .last , .exact(1) weekly() .sunday , .monday , .tuesday , ... daily() .midnight , .noon To use the helper enum, call in to the appropriate modifier on the helper function and pass the value. For example: // Every year in January . yearly (). in (. january ) // Every month on the first day . monthly (). on (. first ) // Every week on Sunday . weekly (). on (. sunday ) // Every day at midnight . daily (). at (. midnight )","title":"Queues"},{"location":"queues/#queues","text":"Vapor Queues ( vapor/queues ) is a pure Swift queuing system that allows you to offload task responsibility to a side worker. Some of the tasks this package works well for: Sending emails outside of the main request thread Performing complex or long-running database operations Ensuring job integrity and resilience Speeding up response time by delaying non-critical processing Scheduling jobs to occur at a specific time This package is similar to Ruby Sidekiq . It provides the following features: Safe handling of SIGTERM and SIGINT signals sent by hosting providers to indicate a shutdown, restart, or new deploy. Different queue priorities. For example, you can specify a queue job to be run on the email queue and another job to be run on the data-processing queue. Implements the reliable queue process to help with unexpected failures. Includes a maxRetryCount feature that will repeat the job until it succeeds up until a specified count. Uses NIO to utilize all available cores and EventLoops for jobs. Allows users to schedule repeating tasks Queues currently has one officially supported driver which interfaces with the main protocol: QueuesRedisDriver Queues also has community-based drivers: - JobsPostgresqlDriver Tip You should not install the vapor/queues package directly unless you are building a new driver. Install one of the driver packages instead.","title":"Queues"},{"location":"queues/#getting-started","text":"Let's take a look at how you can get started using Queues.","title":"Getting Started"},{"location":"queues/#package","text":"The first step to using Queues is adding one of the drivers as a dependency to your project in your SwiftPM package manifest file. In this example, we'll use the Redis driver. // swift-tools-version:5.2 import PackageDescription let package = Package ( name : \"MyApp\" , dependencies : [ /// Any other dependencies ... . package ( url : \"https://github.com/vapor/queues-redis-driver.git\" , from : \"1.0.0\" ), ], targets : [ . target ( name : \"App\" , dependencies : [ . product ( name : \"QueuesRedisDriver\" , package : \"queues-redis-driver\" ) ]), . target ( name : \"Run\" , dependencies : [. target ( name : \"App\" )]), . testTarget ( name : \"AppTests\" , dependencies : [. target ( name : \"App\" )]), ] ) If you edit the manifest directly inside Xcode, it will automatically pick up the changes and fetch the new dependency when the file is saved. Otherwise, from Terminal, run swift package resolve to fetch the new dependency.","title":"Package"},{"location":"queues/#config","text":"The next step is to configure Queues in configure.swift . We'll use the Redis library as an example: try app . queues . use (. redis ( url : \"redis://127.0.0.1:6379\" ))","title":"Config"},{"location":"queues/#registering-a-job","text":"After modeling a job you must add it to your configuration section like this: //Register jobs let emailJob = EmailJob () app . queues . add ( emailJob )","title":"Registering a Job"},{"location":"queues/#running-workers-as-processes","text":"To start a new queue worker, run vapor run queues . You can also specify a specific type of worker to run: vapor run queues --queue emails . Tip Workers should stay running in production. Consult your hosting provider to find out how to keep long-running processes alive. Heroku, for example, allows you to specify \"worker\" dynos like this in your Procfile: worker: Run run queues","title":"Running Workers as Processes"},{"location":"queues/#running-workers-in-process","text":"To run a worker in the same process as your application (as opposed to starting a whole separate server to handle it), call the convenience methods on Application : try app . queues . startInProcessJobs ( on : . default ) To run scheduled jobs in process, call the following method: try app . queues . startScheduledJobs () Warning If you don't start the queue worker either via command line or the in-process worker the jobs will not dispatch.","title":"Running Workers in-process"},{"location":"queues/#the-job-protocol","text":"Jobs are defined by the Job protocol.","title":"The Job Protocol"},{"location":"queues/#modeling-a-job-object","text":"import Vapor import Foundation import Queues struct Email : Codable { let to : String let message : String } struct EmailJob : Job { typealias Payload = Email func dequeue ( _ context : QueueContext , _ payload : Email ) -> EventLoopFuture < Void > { // This is where you would send the email return context . eventLoop . future () } func error ( _ context : QueueContext , _ error : Error , _ payload : Email ) -> EventLoopFuture < Void > { // If you don't want to handle errors you can simply return a future. You can also omit this function entirely. return context . eventLoop . future () } } Tip Don't forget to follow the instructions in Getting Started to add this job to your configuration file.","title":"Modeling a Job object:"},{"location":"queues/#dispatching-jobs","text":"To dispatch a queue job, you need access to an instance of Application or Request . You will most likely be dispatching jobs inside of a route handler: app . get ( \"email\" ) { req -> EventLoopFuture < String > in return req . queue . dispatch ( EmailJob . self , . init ( to : \"email@email.com\" , message : \"message\" ) ). map { \"done\" } }","title":"Dispatching Jobs"},{"location":"queues/#setting-maxretrycount","text":"Jobs will automatically retry themselves upon error if you specify a maxRetryCount . For example: app . get ( \"email\" ) { req -> EventLoopFuture < String > in return req . queue . dispatch ( EmailJob . self , . init ( to : \"email@email.com\" , message : \"message\" ), maxRetryCount : 3 ). map { \"done\" } }","title":"Setting maxRetryCount"},{"location":"queues/#specifying-a-delay","text":"Jobs can also be set to only run after a certain Date has passed. To specify a delay, pass a Date into the delayUntil parameter in dispatch : app . get ( \"email\" ) { req -> EventLoopFuture < String > in let futureDate = Date ( timeIntervalSinceNow : 60 * 60 * 24 ) // One day return req . queue . dispatch ( EmailJob . self , . init ( to : \"email@email.com\" , message : \"message\" ), maxRetryCount : 3 , delayUntil : futureDate ). map { \"done\" } } If a job is dequeued before its delay parameter, the job will be re-queued by the driver.","title":"Specifying a delay"},{"location":"queues/#specify-a-priority","text":"Jobs can be sorted into different queue types/priorities depending on your needs. For example, you may want to open an email queue and a background-processing queue to sort jobs. Start by extending JobsQueueName : extension JobsQueueName { static let emails = JobsQueueName ( string : \"emails\" ) } Then, specify the queue type when you retrieve the jobs object: app . get ( \"email\" ) { req -> EventLoopFuture < String > in let futureDate = Date ( timeIntervalSinceNow : 60 * 60 * 24 ) // One day return req . queues (. emails ) . dispatch ( EmailJob . self , . init ( to : \"email@email.com\" , message : \"message\" ), maxRetryCount : 3 , delayUntil : futureDate ). map { \"done\" } } If you do not specify a queue the job will be run on the default queue. Make sure to follow the instructions in Getting Started to start workers for each queue type.","title":"Specify a priority"},{"location":"queues/#scheduling-jobs","text":"The Queues package also allows you to schedule jobs to occur at certain points in time.","title":"Scheduling Jobs"},{"location":"queues/#starting-the-scheduler-worker","text":"The scheduler requires a separate worker process to be running, similar to the queue worker. You can start the worker by running this command: swift run Run queues --scheduled Tip Workers should stay running in production. Consult your hosting provider to find out how to keep long-running processes alive. Heroku, for example, allows you to specify \"worker\" dynos like this in your Procfile: worker: Run run queues --scheduled","title":"Starting the scheduler worker"},{"location":"queues/#creating-a-scheduledjob","text":"To being, start by creating a new ScheduledJob : import Vapor import Jobs struct CleanupJob : ScheduledJob { // Add extra services here via dependency injection, if you need them. func run ( context : QueueContext ) -> EventLoopFuture < Void > { // Do some work here, perhaps queue up another job. return context . eventLoop . makeSucceededFuture (()) } } Then, in your configure code, register the scheduled job: app . queues . schedule ( CleanupJob ()) . yearly () . in (. may ) . on ( 23 ) . at (. noon ) The job in the example above will be run every year on May 23rd at 12:00 PM. Tip The Scheduler takes the timezone of your server.","title":"Creating a ScheduledJob"},{"location":"queues/#available-builder-methods","text":"There are five main methods that can be called on a scheduler, each of which creates its respective builder object that contains more helper methods. You should continue building out a scheduler object until the compiler does not give you a warning about an unused result. See below for all available methods: Helper Function Available Modifiers Description yearly() in(_ month: Month) -> Monthly The month to run the job in. Returns a Monthly object for further building. monthly() on(_ day: Day) -> Daily The day to run the job in. Returns a Daily object for further building. weekly() on(_ weekday: Weekday) -> Daily The day of the week to run the job on. Returns a Daily object. daily() at(_ time: Time) The time to run the job on. Final method in the chain. at(_ hour: Hour24, _ minute: Minute) The hour and minute to run the job on. Final method in the chain. at(_ hour: Hour12, _ minute: Minute, _ period: HourPeriod) The hour, minute, and period to run the job on. Final method of the chain hourly() at(_ minute: Minute) The minute to run the job at. Final method of the chain.","title":"Available builder methods"},{"location":"queues/#available-helpers","text":"Queues ships with some helpers enums to make scheduling easier: Helper Function Available Helper Enum yearly() .january , .february , .march , ... monthly() .first , .last , .exact(1) weekly() .sunday , .monday , .tuesday , ... daily() .midnight , .noon To use the helper enum, call in to the appropriate modifier on the helper function and pass the value. For example: // Every year in January . yearly (). in (. january ) // Every month on the first day . monthly (). on (. first ) // Every week on Sunday . weekly (). on (. sunday ) // Every day at midnight . daily (). at (. midnight )","title":"Available helpers"},{"location":"routing/","text":"Routing \u00b6 Routing is the process of finding the appropriate request handler for an incoming request. At the core of Vapor's routing is a high-performance, trie-node router from RoutingKit . Overview \u00b6 To understand how routing works in Vapor, you should first understand a few basics about HTTP requests. Take a look at the following example request. GET /hello/vapor HTTP / 1.1 host : vapor.codes content-length : 0 This is a simple GET HTTP request to the URL /hello/vapor . This is the kind of HTTP request your browser would make if you pointed it to the following URL. http://vapor.codes/hello/vapor HTTP Method \u00b6 The first part of the request is the HTTP method. GET is the most common HTTP method, but there are several you will use often. These HTTP methods are often associated with CRUD semantics. method crud GET Read POST Create PUT Replace PATCH Update DELETE Delete Request Path \u00b6 Right after the HTTP method is the request's URI. This consists of a path starting with / and an optional query string after ? . The HTTP method and path are what Vapor uses to route requests. After the URI is the HTTP version followed by zero or more headers and finally a body. Since this is a GET request, it does not have a body. Router Methods \u00b6 Let's take a look at how this request could be handled in Vapor. app . get ( \"hello\" , \"vapor\" ) { req in return \"Hello, vapor!\" } All of the common HTTP methods are available as methods on Application . They accept one or more string arguments that represent the request's path separated by / . Note that you could also write this using on followed by the method. app . on (. GET , \"hello\" , \"vapor\" ) { ... } With this route registered, the example HTTP request from above will result in the following HTTP response. HTTP / 1.1 200 OK content-length : 13 content-type : text/plain; charset=utf-8 Hello, vapor! Route Parameters \u00b6 Now that we've successfully routed a request based on the HTTP method and path, let's try making the path dynamic. Notice that the name \"vapor\" is hardcoded in both the path and the response. Let's make this dynamic so that you can visit /hello/<any name> and get a response. app . get ( \"hello\" , \":name\" ) { req -> String in let name = req . parameters . get ( \"name\" ) ! return \"Hello, \\( name ) !\" } By using a path component prefixed with : , we indicate to the router that this is a dynamic component. Any string supplied here will now match this route. We can then use req.parameters to access the value of the string. If you run the example request again, you'll still get a response that says hello to vapor. However, you can now include any name after /hello/ and see it included in the response. Let's try /hello/swift . GET /hello/swift HTTP / 1.1 content-length : 0 HTTP / 1.1 200 OK content-length : 13 content-type : text/plain; charset=utf-8 Hello, swift! Now that you understand the basics, check out each section to learn more about parameters, groups, and more. Routes \u00b6 A route specifies a request handler for a given HTTP method and URI path. It can also store additional metadata. Methods \u00b6 Routes can be registered directly to your Application using various HTTP method helpers. // responds to GET /foo/bar/baz app . get ( \"foo\" , \"bar\" , \"baz\" ) { req in ... } Route handlers support returning anything that is ResponseEncodable . This includes Content and any EventLoopFuture 's where the future value is ResponseEncodable . You can specify the return type of a route using -> T before in . This can be useful in situations where the compiler cannot determine the return type. app . get ( \"foo\" ) { req -> String in return \"bar\" } These are the supported route helper methods: get post patch put delete In addition to the HTTP method helpers, there is an on function that accepts HTTP method as an input parameter. // responds to OPTIONS /foo/bar/baz app . on (. OPTIONS , \"foo\" , \"bar\" , \"baz\" ) { req in ... } Path Component \u00b6 Each route registration method accepts a variadic list of PathComponent . This type is expressible by string literal and has four cases: Constant ( foo ) Parameter ( :foo ) Anything ( * ) Catchall ( ** ) Constant \u00b6 This is a static route component. Only requests with an exactly matching string at this position will be permitted. // responds to GET /foo/bar/baz app . get ( \"foo\" , \"bar\" , \"baz\" ) { req in ... } Parameter \u00b6 This is a dynamic route component. Any string at this position will be allowed. A parameter path component is specified with a : prefix. The string following the : will be used as the parameter's name. You can use the name to later fetch the parameters value from the request. // responds to GET /foo/bar/baz // responds to GET /foo/qux/baz // ... app . get ( \"foo\" , \":bar\" , \"baz\" ) { req in ... } Anything \u00b6 This is very similar to parameter except the value is discarded. This path component is specified as just * . // responds to GET /foo/bar/baz // responds to GET /foo/qux/baz // ... app . get ( \"foo\" , \"*\" , \"baz\" ) { req in ... } Catchall \u00b6 This is a dynamic route component that matches one or more components. It is specified using ** . Any string at this position or later positions will be allowed in the request. // responds to GET /foo/bar // responds to GET /foo/bar/baz // ... app . get ( \"foo\" , \"**\" ) { req in ... } Parameters \u00b6 When using a parameter path component (prefixed with : ), the value of the URI at that position will be stored in req.parameters . You can use the name of the path component to access the value. // responds to GET /hello/foo // responds to GET /hello/bar // ... app . get ( \"hello\" , \":name\" ) { req -> String in let name = req . parameters . get ( \"name\" ) ! return \"Hello, \\( name ) !\" } Tip We can be sure that req.parameters.get will never return nil here since our route path includes :name . However, if you are accessing route parameters in middleware or in code triggered by multiple routes, you will want to handle the possibility of nil . If you use ** to specify a Catchall, you can retrieve the matched path like this: // responds to GET /hello/foo/bar/baz // ... app . get ( \"hello\" , \":name\" , \"**\" ) { req -> String in let name = req . parameters . get ( \"name\" ) ! let attached = req . parameters . get ( \"**\" ) ! return \"Hello, \\( name ) with \\( attached ) !\" // Hello, foo with bar/baz! } req.parameters also supports casting the parameter to LosslessStringConvertible types automatically. // responds to GET /hello/42 // responds to GET /hello/1337 // ... app . get ( \"number\" , \":x\" ) { req -> String in guard let int = req . parameters . get ( \"x\" , as : Int . self ) else { throw Abort (. badRequest ) } return \" \\( int ) is a great number\" } Body Streaming \u00b6 When registering a route using the on method, you can specify how the request body should be handled. By default, the request body is collected into memory before calling your handler. This is useful since it allows for request content decoding to be synchronous. However, for large requests like file uploads this can potentially strain your system memory. To change how the request body is handled, use the body parameter when registering a route. There are two methods: collect : Collects the request body into memory stream : Streams the request body app . on (. POST , \"file-upload\" , body : . stream ) { req in ... } When the request body is streamed, req.body.data will be nil . You must use req.body.drain to handle each chunk as it is sent to your route. Viewing Routes \u00b6 You can access your application's routes by making the Routes service or using app.routes . print ( app . routes . all ) // [Route] Vapor also ships with a routes command that prints all available routes in an ASCII formatted table. $ swift run Run routes +--------+----------------+ | GET | / | +--------+----------------+ | GET | /hello/ | +--------+----------------+ | GET | /todos | +--------+----------------+ | POST | /todos | +--------+----------------+ | DELETE | /todos/:todoID | +--------+----------------+ Metadata \u00b6 All route registration methods return the created Route . This allows you to metadata to the route's userInfo dictionary. There are some default methods available, like adding a description. app . get ( \"hello\" , \":name\" ) { req in ... }. description ( \"says hello\" ) Route Groups \u00b6 Route grouping allows you to create a set of routes with a path prefix or specific middleware. Grouping supports a builder and closure based syntax. All grouping methods return a RouteBuilder meaning you can infinitely mix, match, and nest your groups with other route building methods. Path Prefix \u00b6 Path prefixing route groups allow you to prepend one or more path components to a group of routes. let users = app . grouped ( \"users\" ) // GET /users users . get { req in ... } // POST /users users . post { req in ... } // GET /users/:id users . get ( \":id\" ) { req in let id = req . parameters . get ( \"id\" ) ! ... } Any path component you can pass into methods like get or post can be passed into grouped . There is an alternative, closure-based syntax as well. app . group ( \"users\" ) { users in // GET /users users . get { req in ... } // POST /users users . post { req in ... } // GET /users/:id users . get ( \":id\" ) { req in let id = req . parameters . get ( \"id\" ) ! ... } } Nesting path prefixing route groups allows you to concisely define CRUD APIs. app . group ( \"users\" ) { users in // GET /users users . get { ... } // POST /users users . post { ... } users . group ( \":id\" ) { user in // GET /users/:id user . get { ... } // PATCH /users/:id user . patch { ... } // PUT /users/:id user . put { ... } } } Middleware \u00b6 In addition to prefixing path components, you can also add middleware to route groups. app . get ( \"fast-thing\" ) { req in ... } app . group ( RateLimitMiddleware ( requestsPerMinute : 5 )) { rateLimited in rateLimited . get ( \"slow-thing\" ) { req in ... } } This is especially useful for protecting subsets of your routes with different authentication middleware. app . post ( \"login\" ) { ... } let auth = app . grouped ( AuthMiddleware ()) auth . get ( \"dashboard\" ) { ... } auth . get ( \"logout\" ) { ... }","title":"Routing"},{"location":"routing/#routing","text":"Routing is the process of finding the appropriate request handler for an incoming request. At the core of Vapor's routing is a high-performance, trie-node router from RoutingKit .","title":"Routing"},{"location":"routing/#overview","text":"To understand how routing works in Vapor, you should first understand a few basics about HTTP requests. Take a look at the following example request. GET /hello/vapor HTTP / 1.1 host : vapor.codes content-length : 0 This is a simple GET HTTP request to the URL /hello/vapor . This is the kind of HTTP request your browser would make if you pointed it to the following URL. http://vapor.codes/hello/vapor","title":"Overview"},{"location":"routing/#http-method","text":"The first part of the request is the HTTP method. GET is the most common HTTP method, but there are several you will use often. These HTTP methods are often associated with CRUD semantics. method crud GET Read POST Create PUT Replace PATCH Update DELETE Delete","title":"HTTP Method"},{"location":"routing/#request-path","text":"Right after the HTTP method is the request's URI. This consists of a path starting with / and an optional query string after ? . The HTTP method and path are what Vapor uses to route requests. After the URI is the HTTP version followed by zero or more headers and finally a body. Since this is a GET request, it does not have a body.","title":"Request Path"},{"location":"routing/#router-methods","text":"Let's take a look at how this request could be handled in Vapor. app . get ( \"hello\" , \"vapor\" ) { req in return \"Hello, vapor!\" } All of the common HTTP methods are available as methods on Application . They accept one or more string arguments that represent the request's path separated by / . Note that you could also write this using on followed by the method. app . on (. GET , \"hello\" , \"vapor\" ) { ... } With this route registered, the example HTTP request from above will result in the following HTTP response. HTTP / 1.1 200 OK content-length : 13 content-type : text/plain; charset=utf-8 Hello, vapor!","title":"Router Methods"},{"location":"routing/#route-parameters","text":"Now that we've successfully routed a request based on the HTTP method and path, let's try making the path dynamic. Notice that the name \"vapor\" is hardcoded in both the path and the response. Let's make this dynamic so that you can visit /hello/<any name> and get a response. app . get ( \"hello\" , \":name\" ) { req -> String in let name = req . parameters . get ( \"name\" ) ! return \"Hello, \\( name ) !\" } By using a path component prefixed with : , we indicate to the router that this is a dynamic component. Any string supplied here will now match this route. We can then use req.parameters to access the value of the string. If you run the example request again, you'll still get a response that says hello to vapor. However, you can now include any name after /hello/ and see it included in the response. Let's try /hello/swift . GET /hello/swift HTTP / 1.1 content-length : 0 HTTP / 1.1 200 OK content-length : 13 content-type : text/plain; charset=utf-8 Hello, swift! Now that you understand the basics, check out each section to learn more about parameters, groups, and more.","title":"Route Parameters"},{"location":"routing/#routes","text":"A route specifies a request handler for a given HTTP method and URI path. It can also store additional metadata.","title":"Routes"},{"location":"routing/#methods","text":"Routes can be registered directly to your Application using various HTTP method helpers. // responds to GET /foo/bar/baz app . get ( \"foo\" , \"bar\" , \"baz\" ) { req in ... } Route handlers support returning anything that is ResponseEncodable . This includes Content and any EventLoopFuture 's where the future value is ResponseEncodable . You can specify the return type of a route using -> T before in . This can be useful in situations where the compiler cannot determine the return type. app . get ( \"foo\" ) { req -> String in return \"bar\" } These are the supported route helper methods: get post patch put delete In addition to the HTTP method helpers, there is an on function that accepts HTTP method as an input parameter. // responds to OPTIONS /foo/bar/baz app . on (. OPTIONS , \"foo\" , \"bar\" , \"baz\" ) { req in ... }","title":"Methods"},{"location":"routing/#path-component","text":"Each route registration method accepts a variadic list of PathComponent . This type is expressible by string literal and has four cases: Constant ( foo ) Parameter ( :foo ) Anything ( * ) Catchall ( ** )","title":"Path Component"},{"location":"routing/#constant","text":"This is a static route component. Only requests with an exactly matching string at this position will be permitted. // responds to GET /foo/bar/baz app . get ( \"foo\" , \"bar\" , \"baz\" ) { req in ... }","title":"Constant"},{"location":"routing/#parameter","text":"This is a dynamic route component. Any string at this position will be allowed. A parameter path component is specified with a : prefix. The string following the : will be used as the parameter's name. You can use the name to later fetch the parameters value from the request. // responds to GET /foo/bar/baz // responds to GET /foo/qux/baz // ... app . get ( \"foo\" , \":bar\" , \"baz\" ) { req in ... }","title":"Parameter"},{"location":"routing/#anything","text":"This is very similar to parameter except the value is discarded. This path component is specified as just * . // responds to GET /foo/bar/baz // responds to GET /foo/qux/baz // ... app . get ( \"foo\" , \"*\" , \"baz\" ) { req in ... }","title":"Anything"},{"location":"routing/#catchall","text":"This is a dynamic route component that matches one or more components. It is specified using ** . Any string at this position or later positions will be allowed in the request. // responds to GET /foo/bar // responds to GET /foo/bar/baz // ... app . get ( \"foo\" , \"**\" ) { req in ... }","title":"Catchall"},{"location":"routing/#parameters","text":"When using a parameter path component (prefixed with : ), the value of the URI at that position will be stored in req.parameters . You can use the name of the path component to access the value. // responds to GET /hello/foo // responds to GET /hello/bar // ... app . get ( \"hello\" , \":name\" ) { req -> String in let name = req . parameters . get ( \"name\" ) ! return \"Hello, \\( name ) !\" } Tip We can be sure that req.parameters.get will never return nil here since our route path includes :name . However, if you are accessing route parameters in middleware or in code triggered by multiple routes, you will want to handle the possibility of nil . If you use ** to specify a Catchall, you can retrieve the matched path like this: // responds to GET /hello/foo/bar/baz // ... app . get ( \"hello\" , \":name\" , \"**\" ) { req -> String in let name = req . parameters . get ( \"name\" ) ! let attached = req . parameters . get ( \"**\" ) ! return \"Hello, \\( name ) with \\( attached ) !\" // Hello, foo with bar/baz! } req.parameters also supports casting the parameter to LosslessStringConvertible types automatically. // responds to GET /hello/42 // responds to GET /hello/1337 // ... app . get ( \"number\" , \":x\" ) { req -> String in guard let int = req . parameters . get ( \"x\" , as : Int . self ) else { throw Abort (. badRequest ) } return \" \\( int ) is a great number\" }","title":"Parameters"},{"location":"routing/#body-streaming","text":"When registering a route using the on method, you can specify how the request body should be handled. By default, the request body is collected into memory before calling your handler. This is useful since it allows for request content decoding to be synchronous. However, for large requests like file uploads this can potentially strain your system memory. To change how the request body is handled, use the body parameter when registering a route. There are two methods: collect : Collects the request body into memory stream : Streams the request body app . on (. POST , \"file-upload\" , body : . stream ) { req in ... } When the request body is streamed, req.body.data will be nil . You must use req.body.drain to handle each chunk as it is sent to your route.","title":"Body Streaming"},{"location":"routing/#viewing-routes","text":"You can access your application's routes by making the Routes service or using app.routes . print ( app . routes . all ) // [Route] Vapor also ships with a routes command that prints all available routes in an ASCII formatted table. $ swift run Run routes +--------+----------------+ | GET | / | +--------+----------------+ | GET | /hello/ | +--------+----------------+ | GET | /todos | +--------+----------------+ | POST | /todos | +--------+----------------+ | DELETE | /todos/:todoID | +--------+----------------+","title":"Viewing Routes"},{"location":"routing/#metadata","text":"All route registration methods return the created Route . This allows you to metadata to the route's userInfo dictionary. There are some default methods available, like adding a description. app . get ( \"hello\" , \":name\" ) { req in ... }. description ( \"says hello\" )","title":"Metadata"},{"location":"routing/#route-groups","text":"Route grouping allows you to create a set of routes with a path prefix or specific middleware. Grouping supports a builder and closure based syntax. All grouping methods return a RouteBuilder meaning you can infinitely mix, match, and nest your groups with other route building methods.","title":"Route Groups"},{"location":"routing/#path-prefix","text":"Path prefixing route groups allow you to prepend one or more path components to a group of routes. let users = app . grouped ( \"users\" ) // GET /users users . get { req in ... } // POST /users users . post { req in ... } // GET /users/:id users . get ( \":id\" ) { req in let id = req . parameters . get ( \"id\" ) ! ... } Any path component you can pass into methods like get or post can be passed into grouped . There is an alternative, closure-based syntax as well. app . group ( \"users\" ) { users in // GET /users users . get { req in ... } // POST /users users . post { req in ... } // GET /users/:id users . get ( \":id\" ) { req in let id = req . parameters . get ( \"id\" ) ! ... } } Nesting path prefixing route groups allows you to concisely define CRUD APIs. app . group ( \"users\" ) { users in // GET /users users . get { ... } // POST /users users . post { ... } users . group ( \":id\" ) { user in // GET /users/:id user . get { ... } // PATCH /users/:id user . patch { ... } // PUT /users/:id user . put { ... } } }","title":"Path Prefix"},{"location":"routing/#middleware","text":"In addition to prefixing path components, you can also add middleware to route groups. app . get ( \"fast-thing\" ) { req in ... } app . group ( RateLimitMiddleware ( requestsPerMinute : 5 )) { rateLimited in rateLimited . get ( \"slow-thing\" ) { req in ... } } This is especially useful for protecting subsets of your routes with different authentication middleware. app . post ( \"login\" ) { ... } let auth = app . grouped ( AuthMiddleware ()) auth . get ( \"dashboard\" ) { ... } auth . get ( \"logout\" ) { ... }","title":"Middleware"},{"location":"server/","text":"Server \u00b6 Vapor includes a high-performance, asynchronous HTTP server built on SwiftNIO . This server supports HTTP/1, HTTP/2, and protocol upgrades like WebSockets . The server also supports enabling TLS (SSL). Configuration \u00b6 Vapor's default HTTP server can be configured via app.http.server . // Only support HTTP/2 app . http . server . configuration . supportVersions = [. two ] The HTTP server supports several configuration options. Hostname \u00b6 The hostname controls which address the server will accept new connections on. The default is 127.0.0.1 . // Configure custom hostname. app . http . server . configuration . hostname = \"dev.local\" The server configuration's hostname can be overridden by passing the --hostname ( -H ) flag to the serve command or by passing the hostname parameter to app.server.start(...) . # Override configured hostname. vapor run serve --hostname dev.local Port \u00b6 The port option controls which port at the specified address the server will accept new connections on. The default is 8080 . // Configure custom port. app . http . server . configuration . port = 1337 Info sudo may be required for binding to ports less than 1024 . Ports greater than 65535 are not supported. The server configuration's port can be overridden by passing the --port ( -p ) flag to the serve command or by passing the port parameter to app.server.start(...) . # Override configured port. vapor run serve --port 1337 Backlog \u00b6 The backlog parameter defines the maximum length for the queue of pending connections. The default is 256 . // Configure custom backlog. app . http . server . configuration . backlog = 128 Reuse Address \u00b6 The reuseAddress parameter allows for reuse of local addresses. Defaults to true . // Disable address reuse. app . http . server . configuration . reuseAddress = false TCP No Delay \u00b6 Enabling the tcpNoDelay parameter will attempt to minimize TCP packet delay. Defaults to true . // Minimize packet delay. app . http . server . configuration . tcpNoDelay = true Response Compression \u00b6 The responseCompression parameter controls HTTP response compression using gzip. The default is .disabled . // Enable HTTP response compression. app . http . server . configuration . responseCompression = . enabled To specify an initial buffer capacity, use the initialByteBufferCapacity parameter. . enabled ( initialByteBufferCapacity : 1024 ) Request Decompression \u00b6 The requestDecompression parameter controls HTTP request decompression using gzip. The default is .disabled . // Enable HTTP request decompression. app . http . server . configuration . requestDecompression = . enabled To specify a decompression limit, use the limit parameter. The default is .ratio(10) . // No decompression size limit . enabled ( limit : . none ) Available options are: size : Maximum decompressed size in bytes. ratio : Maximum decompressed size as ratio of compressed bytes. none : No size limits. Setting decompression size limits can help prevent maliciously compressed HTTP requests from using large amounts of memory. Pipelining \u00b6 The supportPipelining parameter enables support for HTTP request and response pipelining. The default is false . // Support HTTP pipelining. app . http . server . configuration . supportPipelining = true Versions \u00b6 The supportVersions parameter controls which HTTP versions the server will use. By default, Vapor will support both HTTP/1 and HTTP/2 when TLS is enabled. Only HTTP/1 is supported when TLS is disabled. // Disable HTTP/1 support. app . http . server . configuration . supportVersions = [. two ] TLS \u00b6 The tlsConfiguration parameter controls whether TLS (SSL) is enabled on the server. The default is nil . // Enable TLS. try app . http . server . configuration . tlsConfiguration = . forServer ( certificateChain : [ . certificate (. init ( file : \"/path/to/cert.pem\" , format : . pem )) ], privateKey : . file ( \"/path/to/key.pem\" ) ) Name \u00b6 The serverName parameter controls the Server header on outgoing HTTP responses. The default is nil . // Add 'Server: vapor' header to responses. app . http . server . configuration . serverName = \"vapor\" Serve Command \u00b6 To start up Vapor's server, use the serve command. This command will run by default if no other commands are specified. vapor run serve The serve command accepts the following parameters: hostname ( -H ): Overrides configured hostname. port ( -p ): Overrides configured port. bind ( -b ): Overrides configured hostname and port joined by : . An example using the --bind ( -b ) flag: vapor run serve - b 0.0 . 0.0 : 80 Use vapor run serve --help for more information. The serve command will listen for SIGTERM and SIGINT to gracefully shutdown the server. Use ctrl+c ( ^c ) to send a SIGINT signal. When the log level is set to debug or lower, information about the status of graceful shutdown will be logged. Manual Start \u00b6 Vapor's server can be started manually using app.server . // Start Vapor's server. try app . server . start () // Request server shutdown. app . server . shutdown () // Wait for the server to shutdown. try app . server . onShutdown . wait () Servers \u00b6 The server Vapor uses is configurable. By default, the built in HTTP server is used. app . servers . use (. http ) Custom Server \u00b6 Vapor's default HTTP server can be replaced by any type conforming to Server . import Vapor final class MyServer : Server { ... } app . servers . use { app in MyServer () } Custom servers can extend Application.Servers.Provider for leading-dot syntax. extension Application . Servers . Provider { static var myServer : Self { . init { $0 . servers . use { app in MyServer () } } } } app . servers . use (. myServer )","title":"Server"},{"location":"server/#server","text":"Vapor includes a high-performance, asynchronous HTTP server built on SwiftNIO . This server supports HTTP/1, HTTP/2, and protocol upgrades like WebSockets . The server also supports enabling TLS (SSL).","title":"Server"},{"location":"server/#configuration","text":"Vapor's default HTTP server can be configured via app.http.server . // Only support HTTP/2 app . http . server . configuration . supportVersions = [. two ] The HTTP server supports several configuration options.","title":"Configuration"},{"location":"server/#hostname","text":"The hostname controls which address the server will accept new connections on. The default is 127.0.0.1 . // Configure custom hostname. app . http . server . configuration . hostname = \"dev.local\" The server configuration's hostname can be overridden by passing the --hostname ( -H ) flag to the serve command or by passing the hostname parameter to app.server.start(...) . # Override configured hostname. vapor run serve --hostname dev.local","title":"Hostname"},{"location":"server/#port","text":"The port option controls which port at the specified address the server will accept new connections on. The default is 8080 . // Configure custom port. app . http . server . configuration . port = 1337 Info sudo may be required for binding to ports less than 1024 . Ports greater than 65535 are not supported. The server configuration's port can be overridden by passing the --port ( -p ) flag to the serve command or by passing the port parameter to app.server.start(...) . # Override configured port. vapor run serve --port 1337","title":"Port"},{"location":"server/#backlog","text":"The backlog parameter defines the maximum length for the queue of pending connections. The default is 256 . // Configure custom backlog. app . http . server . configuration . backlog = 128","title":"Backlog"},{"location":"server/#reuse-address","text":"The reuseAddress parameter allows for reuse of local addresses. Defaults to true . // Disable address reuse. app . http . server . configuration . reuseAddress = false","title":"Reuse Address"},{"location":"server/#tcp-no-delay","text":"Enabling the tcpNoDelay parameter will attempt to minimize TCP packet delay. Defaults to true . // Minimize packet delay. app . http . server . configuration . tcpNoDelay = true","title":"TCP No Delay"},{"location":"server/#response-compression","text":"The responseCompression parameter controls HTTP response compression using gzip. The default is .disabled . // Enable HTTP response compression. app . http . server . configuration . responseCompression = . enabled To specify an initial buffer capacity, use the initialByteBufferCapacity parameter. . enabled ( initialByteBufferCapacity : 1024 )","title":"Response Compression"},{"location":"server/#request-decompression","text":"The requestDecompression parameter controls HTTP request decompression using gzip. The default is .disabled . // Enable HTTP request decompression. app . http . server . configuration . requestDecompression = . enabled To specify a decompression limit, use the limit parameter. The default is .ratio(10) . // No decompression size limit . enabled ( limit : . none ) Available options are: size : Maximum decompressed size in bytes. ratio : Maximum decompressed size as ratio of compressed bytes. none : No size limits. Setting decompression size limits can help prevent maliciously compressed HTTP requests from using large amounts of memory.","title":"Request Decompression"},{"location":"server/#pipelining","text":"The supportPipelining parameter enables support for HTTP request and response pipelining. The default is false . // Support HTTP pipelining. app . http . server . configuration . supportPipelining = true","title":"Pipelining"},{"location":"server/#versions","text":"The supportVersions parameter controls which HTTP versions the server will use. By default, Vapor will support both HTTP/1 and HTTP/2 when TLS is enabled. Only HTTP/1 is supported when TLS is disabled. // Disable HTTP/1 support. app . http . server . configuration . supportVersions = [. two ]","title":"Versions"},{"location":"server/#tls","text":"The tlsConfiguration parameter controls whether TLS (SSL) is enabled on the server. The default is nil . // Enable TLS. try app . http . server . configuration . tlsConfiguration = . forServer ( certificateChain : [ . certificate (. init ( file : \"/path/to/cert.pem\" , format : . pem )) ], privateKey : . file ( \"/path/to/key.pem\" ) )","title":"TLS"},{"location":"server/#name","text":"The serverName parameter controls the Server header on outgoing HTTP responses. The default is nil . // Add 'Server: vapor' header to responses. app . http . server . configuration . serverName = \"vapor\"","title":"Name"},{"location":"server/#serve-command","text":"To start up Vapor's server, use the serve command. This command will run by default if no other commands are specified. vapor run serve The serve command accepts the following parameters: hostname ( -H ): Overrides configured hostname. port ( -p ): Overrides configured port. bind ( -b ): Overrides configured hostname and port joined by : . An example using the --bind ( -b ) flag: vapor run serve - b 0.0 . 0.0 : 80 Use vapor run serve --help for more information. The serve command will listen for SIGTERM and SIGINT to gracefully shutdown the server. Use ctrl+c ( ^c ) to send a SIGINT signal. When the log level is set to debug or lower, information about the status of graceful shutdown will be logged.","title":"Serve Command"},{"location":"server/#manual-start","text":"Vapor's server can be started manually using app.server . // Start Vapor's server. try app . server . start () // Request server shutdown. app . server . shutdown () // Wait for the server to shutdown. try app . server . onShutdown . wait ()","title":"Manual Start"},{"location":"server/#servers","text":"The server Vapor uses is configurable. By default, the built in HTTP server is used. app . servers . use (. http )","title":"Servers"},{"location":"server/#custom-server","text":"Vapor's default HTTP server can be replaced by any type conforming to Server . import Vapor final class MyServer : Server { ... } app . servers . use { app in MyServer () } Custom servers can extend Application.Servers.Provider for leading-dot syntax. extension Application . Servers . Provider { static var myServer : Self { . init { $0 . servers . use { app in MyServer () } } } } app . servers . use (. myServer )","title":"Custom Server"},{"location":"services/","text":"Services \u00b6 Vapor's Application and Request are built to be extended by your application and third-party packages. New functionality added to these types are often called services. Read Only \u00b6 The simplest type of service is read-only. These services consist of computed variables or methods added to either application or request. import Vapor struct MyAPI { let client : Client func foos () -> EventLoopFuture < [ String ] > { ... } } extension Request { var myAPI : MyAPI { . init ( client : self . client ) } } Read-only services can depend on any pre-existing services, like client in this example. Once the extension has been added, your custom service can be used like any other property on request. req . myAPI . foos () Writable \u00b6 Services that need state or configuration can utilize Application and Request storage for storing data. Let's assume you want to add the following MyConfiguration struct to your application. struct MyConfiguration { var apiKey : String } To use storage, you must declare a StorageKey . struct MyConfigurationKey : StorageKey { typealias Value = MyConfiguration } This is an empty struct with a Value typealias specifying which type is being stored. By using an empty type as the key, you can control what code is able to access your storage value. If the type is internal or private, only your code will be able to modify the associated value in storage. Finally, add an extension to Application for getting and setting the MyConfiguration struct. extension Application { var myConfiguration : MyConfiguration ? { get { self . storage [ MyConfigurationKey . self ] } set { self . storage [ MyConfigurationKey . self ] = newValue } } } Once the extension is added, you can use myConfiguration like a normal property on Application . app . myConfiguration = . init ( apiKey : ...) print ( app . myConfiguration ?. apiKey ) Lifecycle \u00b6 Vapor's Application allows you to register lifecycle handlers. These let you hook into events such as boot and shutdown. // Prints hello during boot. struct Hello : LifecycleHandler { // Called before application boots. func willBoot ( _ app : Application ) throws { app . logger . info ( \"Hello!\" ) } } // Add lifecycle handler. app . lifecycle . use ( Hello ()) Locks \u00b6 Vapor's Application includes conveniences for synchronizing code using locks. By declaring a LockKey , you can get a unique, shared lock to synchronize access to your code. struct TestKey : LockKey { } let test = app . locks . lock ( for : TestKey . self ) test . withLock { // Do something. } Each call to lock(for:) with the same LockKey will return the same lock. This method is thread-safe. For an application-wide lock, you can use app.sync . app . sync . withLock { // Do something. } Request \u00b6 Services that are intended to be used in route handlers should be added to Request . Request services should use the request's logger and event loop. It is important that a request stay on the same event loop or an assertion will be hit when the response is returned to Vapor. If a service must leave the request's event loop to do work, it should make sure to return to the event loop before finishing. This can be done using the hop(to:) on EventLoopFuture . Request services that need access to application services, such as configurations, can use req.application . Take care to consider thread-safety when accessing the application from a route handler. Generally, only read operations should be performed by requests. Write operations must be protected by locks.","title":"Services"},{"location":"services/#services","text":"Vapor's Application and Request are built to be extended by your application and third-party packages. New functionality added to these types are often called services.","title":"Services"},{"location":"services/#read-only","text":"The simplest type of service is read-only. These services consist of computed variables or methods added to either application or request. import Vapor struct MyAPI { let client : Client func foos () -> EventLoopFuture < [ String ] > { ... } } extension Request { var myAPI : MyAPI { . init ( client : self . client ) } } Read-only services can depend on any pre-existing services, like client in this example. Once the extension has been added, your custom service can be used like any other property on request. req . myAPI . foos ()","title":"Read Only"},{"location":"services/#writable","text":"Services that need state or configuration can utilize Application and Request storage for storing data. Let's assume you want to add the following MyConfiguration struct to your application. struct MyConfiguration { var apiKey : String } To use storage, you must declare a StorageKey . struct MyConfigurationKey : StorageKey { typealias Value = MyConfiguration } This is an empty struct with a Value typealias specifying which type is being stored. By using an empty type as the key, you can control what code is able to access your storage value. If the type is internal or private, only your code will be able to modify the associated value in storage. Finally, add an extension to Application for getting and setting the MyConfiguration struct. extension Application { var myConfiguration : MyConfiguration ? { get { self . storage [ MyConfigurationKey . self ] } set { self . storage [ MyConfigurationKey . self ] = newValue } } } Once the extension is added, you can use myConfiguration like a normal property on Application . app . myConfiguration = . init ( apiKey : ...) print ( app . myConfiguration ?. apiKey )","title":"Writable"},{"location":"services/#lifecycle","text":"Vapor's Application allows you to register lifecycle handlers. These let you hook into events such as boot and shutdown. // Prints hello during boot. struct Hello : LifecycleHandler { // Called before application boots. func willBoot ( _ app : Application ) throws { app . logger . info ( \"Hello!\" ) } } // Add lifecycle handler. app . lifecycle . use ( Hello ())","title":"Lifecycle"},{"location":"services/#locks","text":"Vapor's Application includes conveniences for synchronizing code using locks. By declaring a LockKey , you can get a unique, shared lock to synchronize access to your code. struct TestKey : LockKey { } let test = app . locks . lock ( for : TestKey . self ) test . withLock { // Do something. } Each call to lock(for:) with the same LockKey will return the same lock. This method is thread-safe. For an application-wide lock, you can use app.sync . app . sync . withLock { // Do something. }","title":"Locks"},{"location":"services/#request","text":"Services that are intended to be used in route handlers should be added to Request . Request services should use the request's logger and event loop. It is important that a request stay on the same event loop or an assertion will be hit when the response is returned to Vapor. If a service must leave the request's event loop to do work, it should make sure to return to the event loop before finishing. This can be done using the hop(to:) on EventLoopFuture . Request services that need access to application services, such as configurations, can use req.application . Take care to consider thread-safety when accessing the application from a route handler. Generally, only read operations should be performed by requests. Write operations must be protected by locks.","title":"Request"},{"location":"sessions/","text":"Sessions \u00b6 Sessions allow you to persist a user's data between multiple requests. Sessions work by creating and returning a unique cookie alongside the HTTP response when a new session is initialized. Browsers will automatically detect this cookie and include it in future requests. This allows Vapor to automatically restore a specific user's session in your request handler. Sessions are great for front-end web applications built in Vapor that serve HTML directly to web browsers. For APIs, we recommend using stateless, token-based authentication to persist user data between requests. Configuration \u00b6 To use sessions in a route, the request must pass through SessionsMiddleware . The easiest way to achieve this is by adding this middleware globally. app . middleware . use ( app . sessions . middleware ) If only a subset of your routes utilize sessions, you can instead add SessionsMiddleware to a route group. let sessions = app . grouped ( app . sessions . middleware ) The HTTP cookie generated by sessions can be configured using app.sessions.configuration . You can change the cookie name and declare a custom function for generating cookie values. // Change the cookie name to \"foo\". app . sessions . configuration . cookieName = \"foo\" // Configures cookie value creation. app . sessions . configuration . cookieFactory = { sessionID in . init ( string : sessionID . string , isSecure : true ) } By default, Vapor will use vapor_session as the cookie name. Drivers \u00b6 Session drivers are responsible for storing and retrieving session data by identifier. You can create custom drivers by conforming to the SessionDriver protocol. In-Memory \u00b6 Vapor utilizes in-memory sessions by default. In-memory sessions require zero configuration and do not persist between application launches which makes them great for testing. To enable in-memory sessions manually, use .memory : app . sessions . use (. memory ) For production use cases, take a look at the other session drivers which utilize databases to persist and share sessions across multiple instances of your app. Fluent \u00b6 Fluent includes support for storing session data in your application's database. This section assumes you have configured Fluent and can connect to a database. The first step is to enable the Fluent sessions driver. import Fluent app . sessions . use (. fluent ) This will configure sessions to use the application's default database. To specify a specific database, pass the database's identifier. app . sessions . use (. fluent (. sqlite )) Finally, add SessionRecord 's migration to your database's migrations. This will prepare your database for storing session data in the _fluent_sessions schema. app . migrations . add ( SessionRecord . migration ) Make sure to run your application's migrations after adding the new migration. Sessions will now be stored in your application's database allowing them to persist between restarts and be shared between multiple instances of your app. Session Data \u00b6 Now that sessions are configured, you are ready to persist data between requests. New sessions are initialized automatically when data is added to req.session . The example route handler below accepts a dynamic route parameter and adds the value to req.session.data . app . get ( \"set\" , \":value\" ) { req -> HTTPStatus in req . session . data [ \"name\" ] = req . parameters . get ( \"value\" ) return . ok } Use the following request to initialize a session with the name Vapor. GET /set/vapor HTTP / 1.1 content-length : 0 You should receive a response similar to the following: HTTP / 1.1 200 OK content-length : 0 set-cookie : vapor-session=123; Expires=Fri, 10 Apr 2020 21:08:09 GMT; Path=/ Notice the set-cookie header has been added automatically to the response after adding data to req.session . Including this cookie in subsequent requests will allow access to the session data. Add the following route handler for accessing the name value from the session. app . get ( \"get\" ) { req -> String in req . session . data [ \"name\" ] ?? \"n/a\" } Use the following request to access this route while making sure to pass the cookie value from the previous response. GET /get HTTP / 1.1 cookie : vapor-session=123 You should see the name Vapor returned in the response. You can add or remove data from the session as you see fit. Session data will be synchronized with the session driver automatically before returning the HTTP response. To end a session, use req.session.destroy . This will delete the data from the session driver and invalidate the session cookie. app . get ( \"del\" ) { req -> HTTPStatus in req . session . destroy () return . ok }","title":"Sessions"},{"location":"sessions/#sessions","text":"Sessions allow you to persist a user's data between multiple requests. Sessions work by creating and returning a unique cookie alongside the HTTP response when a new session is initialized. Browsers will automatically detect this cookie and include it in future requests. This allows Vapor to automatically restore a specific user's session in your request handler. Sessions are great for front-end web applications built in Vapor that serve HTML directly to web browsers. For APIs, we recommend using stateless, token-based authentication to persist user data between requests.","title":"Sessions"},{"location":"sessions/#configuration","text":"To use sessions in a route, the request must pass through SessionsMiddleware . The easiest way to achieve this is by adding this middleware globally. app . middleware . use ( app . sessions . middleware ) If only a subset of your routes utilize sessions, you can instead add SessionsMiddleware to a route group. let sessions = app . grouped ( app . sessions . middleware ) The HTTP cookie generated by sessions can be configured using app.sessions.configuration . You can change the cookie name and declare a custom function for generating cookie values. // Change the cookie name to \"foo\". app . sessions . configuration . cookieName = \"foo\" // Configures cookie value creation. app . sessions . configuration . cookieFactory = { sessionID in . init ( string : sessionID . string , isSecure : true ) } By default, Vapor will use vapor_session as the cookie name.","title":"Configuration"},{"location":"sessions/#drivers","text":"Session drivers are responsible for storing and retrieving session data by identifier. You can create custom drivers by conforming to the SessionDriver protocol.","title":"Drivers"},{"location":"sessions/#in-memory","text":"Vapor utilizes in-memory sessions by default. In-memory sessions require zero configuration and do not persist between application launches which makes them great for testing. To enable in-memory sessions manually, use .memory : app . sessions . use (. memory ) For production use cases, take a look at the other session drivers which utilize databases to persist and share sessions across multiple instances of your app.","title":"In-Memory"},{"location":"sessions/#fluent","text":"Fluent includes support for storing session data in your application's database. This section assumes you have configured Fluent and can connect to a database. The first step is to enable the Fluent sessions driver. import Fluent app . sessions . use (. fluent ) This will configure sessions to use the application's default database. To specify a specific database, pass the database's identifier. app . sessions . use (. fluent (. sqlite )) Finally, add SessionRecord 's migration to your database's migrations. This will prepare your database for storing session data in the _fluent_sessions schema. app . migrations . add ( SessionRecord . migration ) Make sure to run your application's migrations after adding the new migration. Sessions will now be stored in your application's database allowing them to persist between restarts and be shared between multiple instances of your app.","title":"Fluent"},{"location":"sessions/#session-data","text":"Now that sessions are configured, you are ready to persist data between requests. New sessions are initialized automatically when data is added to req.session . The example route handler below accepts a dynamic route parameter and adds the value to req.session.data . app . get ( \"set\" , \":value\" ) { req -> HTTPStatus in req . session . data [ \"name\" ] = req . parameters . get ( \"value\" ) return . ok } Use the following request to initialize a session with the name Vapor. GET /set/vapor HTTP / 1.1 content-length : 0 You should receive a response similar to the following: HTTP / 1.1 200 OK content-length : 0 set-cookie : vapor-session=123; Expires=Fri, 10 Apr 2020 21:08:09 GMT; Path=/ Notice the set-cookie header has been added automatically to the response after adding data to req.session . Including this cookie in subsequent requests will allow access to the session data. Add the following route handler for accessing the name value from the session. app . get ( \"get\" ) { req -> String in req . session . data [ \"name\" ] ?? \"n/a\" } Use the following request to access this route while making sure to pass the cookie value from the previous response. GET /get HTTP / 1.1 cookie : vapor-session=123 You should see the name Vapor returned in the response. You can add or remove data from the session as you see fit. Session data will be synchronized with the session driver automatically before returning the HTTP response. To end a session, use req.session.destroy . This will delete the data from the session driver and invalidate the session cookie. app . get ( \"del\" ) { req -> HTTPStatus in req . session . destroy () return . ok }","title":"Session Data"},{"location":"spm/","text":"Swift Package Manager \u00b6 The Swift Package Manager (SPM) is used for building your project's source code and dependencies. Since Vapor relies heavily on SPM, it's a good idea to understand the basics of how it works. SPM is similar to Cocoapods, Ruby gems, and NPM. You can use SPM from the command line with commands like swift build and swift test or with compatible IDEs. However, unlike some other package managers, there is no central package index for SPM packages. SPM instead leverages URLs to Git repositories and versions dependencies using Git tags . Package Manifest \u00b6 The first place SPM looks in your project is the package manifest. This should always be located in the root directory of your project and named Package.swift . Take a look at this example Package manifest. // swift-tools-version:5.2 import PackageDescription let package = Package ( name : \"app\" , platforms : [ . macOS (. v10_15 ) ], products : [ . executable ( name : \"Run\" , targets : [ \"Run\" ]), . library ( name : \"App\" , targets : [ \"App\" ]), ], dependencies : [ . package ( url : \"https://github.com/vapor/vapor.git\" , from : \"4.0.0\" ), ], targets : [ . target ( name : \"App\" , dependencies : [ \"Fluent\" ]), . target ( name : \"Run\" , dependencies : [ \"App\" ]), . testTarget ( name : \"AppTests\" , dependencies : [ \"App\" ]) ] ) Each part of the manifest is explained in the following sections. Tools Version \u00b6 The very first line of a package manifest indicates the Swift tools version required. This specifies the minimum version of Swift that the package supports. The Package description API may also change between Swift versions, so this line ensures Swift will know how to parse your manifest. Package Name \u00b6 The first argument to Package is the package's name. If the package is public, you should use the last segment of the Git repo's URL as the name. Platforms \u00b6 The platforms array specifies which platforms this package supports. By specifying .macOS(.v10_14) this package requires macOS Mojave or greater. When Xcode loads this project, it will automatically set the minimum deployment version to 10.14 so that you can use all available APIs. Products \u00b6 Products are targets that your package produces when built. In this package, there are two targets. A library and an executable. Dependencies \u00b6 Dependencies are other SPM packages that your package relies on. All Vapor applications rely on the Vapor package, but you can add as many other dependencies as you want. In the above example, you can see vapor/vapor version 4.0.0 or later is a dependency of this package. When you add a dependency to your package, you must next signal which targets depend on the newly available modules. Targets \u00b6 Targets are all of the modules, executables, and tests that your package contains. Most Vapor apps will have three targets, although you can add as many as you like to organize your code. Each target declares which modules it depends on. You must add module names here in order to import them in your code. A target can depend on other targets in your project or any modules exposed by packages you've added to the main dependencies array. Tip Executable targets (targets that contain a main.swift file) cannot be imported by other modules. This is why Vapor has both an App and a Run target. Any code you include in App can be tested in the AppTests . Folder Structure \u00b6 Below is the typical folder structure for an SPM package. . \u251c\u2500\u2500 Sources \u2502 \u251c\u2500\u2500 App \u2502 \u2502 \u2514\u2500\u2500 (Source code) \u2502 \u2514\u2500\u2500 Run \u2502 \u2514\u2500\u2500 main.swift \u251c\u2500\u2500 Tests \u2502 \u2514\u2500\u2500 AppTests \u2514\u2500\u2500 Package.swift Each .target corresponds to a folder in the Sources folder. Each .testTarget corresponds to a folder in the Tests folder. Package.resolved \u00b6 The first time you build your project, SPM will create a Package.resolved file that stores the version of each dependency. The next time you build your project, these same versions will be used even if newer versions are available. To update your depdencies, run swift package update . Xcode \u00b6 If you are using Xcode 11 or greater, changes to dependencies, targets, products, etc will happen automatically whenever the Package.swift file is modified. If you want to update to the latest dependencies, use File \u2192 Swift Packages \u2192 Update To Latest Swift Package Versions. You may also want to add the .swiftpm file to your .gitignore . This is where Xcode will store your Xcode project configuration.","title":"SPM"},{"location":"spm/#swift-package-manager","text":"The Swift Package Manager (SPM) is used for building your project's source code and dependencies. Since Vapor relies heavily on SPM, it's a good idea to understand the basics of how it works. SPM is similar to Cocoapods, Ruby gems, and NPM. You can use SPM from the command line with commands like swift build and swift test or with compatible IDEs. However, unlike some other package managers, there is no central package index for SPM packages. SPM instead leverages URLs to Git repositories and versions dependencies using Git tags .","title":"Swift Package Manager"},{"location":"spm/#package-manifest","text":"The first place SPM looks in your project is the package manifest. This should always be located in the root directory of your project and named Package.swift . Take a look at this example Package manifest. // swift-tools-version:5.2 import PackageDescription let package = Package ( name : \"app\" , platforms : [ . macOS (. v10_15 ) ], products : [ . executable ( name : \"Run\" , targets : [ \"Run\" ]), . library ( name : \"App\" , targets : [ \"App\" ]), ], dependencies : [ . package ( url : \"https://github.com/vapor/vapor.git\" , from : \"4.0.0\" ), ], targets : [ . target ( name : \"App\" , dependencies : [ \"Fluent\" ]), . target ( name : \"Run\" , dependencies : [ \"App\" ]), . testTarget ( name : \"AppTests\" , dependencies : [ \"App\" ]) ] ) Each part of the manifest is explained in the following sections.","title":"Package Manifest"},{"location":"spm/#tools-version","text":"The very first line of a package manifest indicates the Swift tools version required. This specifies the minimum version of Swift that the package supports. The Package description API may also change between Swift versions, so this line ensures Swift will know how to parse your manifest.","title":"Tools Version"},{"location":"spm/#package-name","text":"The first argument to Package is the package's name. If the package is public, you should use the last segment of the Git repo's URL as the name.","title":"Package Name"},{"location":"spm/#platforms","text":"The platforms array specifies which platforms this package supports. By specifying .macOS(.v10_14) this package requires macOS Mojave or greater. When Xcode loads this project, it will automatically set the minimum deployment version to 10.14 so that you can use all available APIs.","title":"Platforms"},{"location":"spm/#products","text":"Products are targets that your package produces when built. In this package, there are two targets. A library and an executable.","title":"Products"},{"location":"spm/#dependencies","text":"Dependencies are other SPM packages that your package relies on. All Vapor applications rely on the Vapor package, but you can add as many other dependencies as you want. In the above example, you can see vapor/vapor version 4.0.0 or later is a dependency of this package. When you add a dependency to your package, you must next signal which targets depend on the newly available modules.","title":"Dependencies"},{"location":"spm/#targets","text":"Targets are all of the modules, executables, and tests that your package contains. Most Vapor apps will have three targets, although you can add as many as you like to organize your code. Each target declares which modules it depends on. You must add module names here in order to import them in your code. A target can depend on other targets in your project or any modules exposed by packages you've added to the main dependencies array. Tip Executable targets (targets that contain a main.swift file) cannot be imported by other modules. This is why Vapor has both an App and a Run target. Any code you include in App can be tested in the AppTests .","title":"Targets"},{"location":"spm/#folder-structure","text":"Below is the typical folder structure for an SPM package. . \u251c\u2500\u2500 Sources \u2502 \u251c\u2500\u2500 App \u2502 \u2502 \u2514\u2500\u2500 (Source code) \u2502 \u2514\u2500\u2500 Run \u2502 \u2514\u2500\u2500 main.swift \u251c\u2500\u2500 Tests \u2502 \u2514\u2500\u2500 AppTests \u2514\u2500\u2500 Package.swift Each .target corresponds to a folder in the Sources folder. Each .testTarget corresponds to a folder in the Tests folder.","title":"Folder Structure"},{"location":"spm/#packageresolved","text":"The first time you build your project, SPM will create a Package.resolved file that stores the version of each dependency. The next time you build your project, these same versions will be used even if newer versions are available. To update your depdencies, run swift package update .","title":"Package.resolved"},{"location":"spm/#xcode","text":"If you are using Xcode 11 or greater, changes to dependencies, targets, products, etc will happen automatically whenever the Package.swift file is modified. If you want to update to the latest dependencies, use File \u2192 Swift Packages \u2192 Update To Latest Swift Package Versions. You may also want to add the .swiftpm file to your .gitignore . This is where Xcode will store your Xcode project configuration.","title":"Xcode"},{"location":"testing/","text":"Testing \u00b6 Vapor includes a module named XCTVapor that provides test helpers built on XCTest . These testing helpers allow you to send test requests to your Vapor application programmatically or running over an HTTP server. Getting Started \u00b6 To use the XCTVapor module, ensure it has been added to your package's test target. let package = Package ( ... dependencies : [ . package ( url : \"https://github.com/vapor/vapor.git\" , from : \"4.0.0\" ) ], targets : [ ... . testTarget ( name : \"AppTests\" , dependencies : [ . target ( name : \"App\" ), . product ( name : \"XCTVapor\" , package : \"vapor\" ), ]) ] ) Then, add import XCTVapor at the top of your test files. Create classes extending XCTestCase to write test cases. import XCTVapor final class MyTests : XCTestCase { func testStub () throws { // Test here. } } Each function beginning with test will run automatically when your app is tested. Running Tests \u00b6 Use cmd+u with the -Package scheme selected to run tests in Xcode. Use swift test --enable-test-discovery to test via the CLI. Testable Application \u00b6 Initialize an instance of Application using the .testing environment. You must call app.shutdown() before this application deinitializes. let app = Application (. testing ) defer { app . shutdown () } try configure ( app ) Pass the Application to your package's configure(_:) method to apply your configuration. Any test-only configurations can be applied after. Send Request \u00b6 To send a test request to your application, use the test method. try app . test (. GET , \"hello\" ) { res in XCTAssertEqual ( res . status , . ok ) XCTAssertEqual ( res . body . string , \"Hello, world!\" ) } The first two parameters are the HTTP method and URL to request. The trailing closure accepts the HTTP response which you can verify using XCTAssert methods. For more complex requests, you can supply a beforeRequest closure to modify headers or encode content. Vapor's Content API is available on both the test request and response. try app . test (. POST , \"todos\" , beforeRequest : { req in try req . content . encode ([ \"title\" : \"Test\" ]) }, afterResponse : { res in XCTAssertEqual ( res . status , . created ) let todo = try res . content . decode ( Todo . self ) XCTAssertEqual ( todo . title , \"Test\" ) }) Testable Method \u00b6 Vapor's testing API supports sending test requests programmatically and via a live HTTP server. You can specify which method you would like to use by using the testable method. // Use programmatic testing. app . testable ( method : . inMemory ). test (...) // Run tests through a live HTTP server. app . testable ( method : . running ). test (...) The inMemory option is used by default. The running option supports passing a specific port to use. By default 8080 is used. . running ( port : 8123 )","title":"Testing"},{"location":"testing/#testing","text":"Vapor includes a module named XCTVapor that provides test helpers built on XCTest . These testing helpers allow you to send test requests to your Vapor application programmatically or running over an HTTP server.","title":"Testing"},{"location":"testing/#getting-started","text":"To use the XCTVapor module, ensure it has been added to your package's test target. let package = Package ( ... dependencies : [ . package ( url : \"https://github.com/vapor/vapor.git\" , from : \"4.0.0\" ) ], targets : [ ... . testTarget ( name : \"AppTests\" , dependencies : [ . target ( name : \"App\" ), . product ( name : \"XCTVapor\" , package : \"vapor\" ), ]) ] ) Then, add import XCTVapor at the top of your test files. Create classes extending XCTestCase to write test cases. import XCTVapor final class MyTests : XCTestCase { func testStub () throws { // Test here. } } Each function beginning with test will run automatically when your app is tested.","title":"Getting Started"},{"location":"testing/#running-tests","text":"Use cmd+u with the -Package scheme selected to run tests in Xcode. Use swift test --enable-test-discovery to test via the CLI.","title":"Running Tests"},{"location":"testing/#testable-application","text":"Initialize an instance of Application using the .testing environment. You must call app.shutdown() before this application deinitializes. let app = Application (. testing ) defer { app . shutdown () } try configure ( app ) Pass the Application to your package's configure(_:) method to apply your configuration. Any test-only configurations can be applied after.","title":"Testable Application"},{"location":"testing/#send-request","text":"To send a test request to your application, use the test method. try app . test (. GET , \"hello\" ) { res in XCTAssertEqual ( res . status , . ok ) XCTAssertEqual ( res . body . string , \"Hello, world!\" ) } The first two parameters are the HTTP method and URL to request. The trailing closure accepts the HTTP response which you can verify using XCTAssert methods. For more complex requests, you can supply a beforeRequest closure to modify headers or encode content. Vapor's Content API is available on both the test request and response. try app . test (. POST , \"todos\" , beforeRequest : { req in try req . content . encode ([ \"title\" : \"Test\" ]) }, afterResponse : { res in XCTAssertEqual ( res . status , . created ) let todo = try res . content . decode ( Todo . self ) XCTAssertEqual ( todo . title , \"Test\" ) })","title":"Send Request"},{"location":"testing/#testable-method","text":"Vapor's testing API supports sending test requests programmatically and via a live HTTP server. You can specify which method you would like to use by using the testable method. // Use programmatic testing. app . testable ( method : . inMemory ). test (...) // Run tests through a live HTTP server. app . testable ( method : . running ). test (...) The inMemory option is used by default. The running option supports passing a specific port to use. By default 8080 is used. . running ( port : 8123 )","title":"Testable Method"},{"location":"upgrading/","text":"Upgrading to 4.0 \u00b6 This guide shows you how to upgrade an existing Vapor 3.x project to 4.0. This guide attempts to cover all of Vapor's official packages as well as some commonly used providers. If you notice anything missing, Vapor's team chat is a great place to ask for help. Issues and pull requests are also appreciated. Dependencies \u00b6 To use Vapor 4, you will need Xcode 11.4 and macOS 10.15 or greater. The Install section of the docs goes over installing dependencies. Package.swift \u00b6 The first step to upgrading to Vapor 4 is to update your package's dependencies. Below is an example of an upgraded Package.swift file. You can also check out the updated template Package.swift . -// swift-tools-version:4.0 +// swift-tools-version:5.2 import PackageDescription let package = Package( name: \"api\", + platforms: [ + .macOS(.v10_15), + ], dependencies: [ - .package(url: \"https://github.com/vapor/fluent-postgresql.git\", from: \"1.0.0\"), + .package(url: \"https://github.com/vapor/fluent.git\", from: \"4.0.0-rc\"), + .package(url: \"https://github.com/vapor/fluent-postgres-driver.git\", from: \"2.0.0-rc\"), - .package(url: \"https://github.com/vapor/jwt.git\", from: \"3.0.0\"), + .package(url: \"https://github.com/vapor/jwt.git\", from: \"4.0.0-rc\"), - .package(url: \"https://github.com/vapor/vapor.git\", from: \"3.0.0\"), + .package(url: \"https://github.com/vapor/vapor.git\", from: \"4.0.0-rc\"), ], targets: [ .target(name: \"App\", dependencies: [ - \"FluentPostgreSQL\", + .product(name: \"Fluent\", package: \"fluent\"), + .product(name: \"FluentPostgresDriver\", package: \"fluent-postgres-driver\"), - \"Vapor\", + .product(name: \"Vapor\", package: \"vapor\"), - \"JWT\", + .product(name: \"JWT\", package: \"jwt\"), ]), - .target(name: \"Run\", dependencies: [\"App\"]), - .testTarget(name: \"AppTests\", dependencies: [\"App\"]) + .target(name: \"Run\", dependencies: [ + .target(name: \"App\"), + ]), + .testTarget(name: \"AppTests\", dependencies: [ + .target(name: \"App\"), + ]) ] ) All packages that have been upgraded for Vapor 4 will have their major version number incremented by one. Warning The -rc pre-release identifier is used since Vapor 4 has not been officially released yet. Old Packages \u00b6 Some packages may not be upgraded yet. If you encounter any, file an issue to let the author know. Some Vapor 3 packages have been deprecated, such as: vapor/auth : Now included in Vapor. vapor/core : Absorbed into several modules. vapor/crypto : Replaced by SwiftCrypto. vapor/multipart : Now included in Vapor. vapor/url-encoded-form : Now included in Vapor. vapor-community/vapor-ext : Now included in Vapor. vapor-community/pagination : Now part of Fluent. IBM-Swift/LoggerAPI : Replaced by SwiftLogging. Fluent \u00b6 vapor/fluent must now be added as a separate dependency to your dependencies list and targets. All database-specific packages have been suffixed with -driver to make the requirement on vapor/fluent clear. - .package(url: \"https://github.com/vapor/fluent-postgresql.git\", from: \"1.0.0\"), + .package(url: \"https://github.com/vapor/fluent.git\", from: \"4.0.0-rc\"), + .package(url: \"https://github.com/vapor/fluent-postgres-driver.git\", from: \"2.0.0-rc\"), Platforms \u00b6 Vapor's package manifests now explicitly support macOS 10.15 and greater. This means your package will also need to specify platform support. + platforms: [ + .macOS(.v10_15), + ], Vapor may add additional supported platforms in the future. Your package may support any subset of these platforms as long as the version number is equal or greater to Vapor's minimum version requirements. Xcode \u00b6 Vapor 4 utilizies Xcode 11's native SPM support. This means you will no longer need to generate .xcodeproj files. Opening your project's folder in Xcode will automatically recognize SPM and pull in dependencies. You can open your project natively in Xcode using vapor-beta xcode or open Package.swift . Once you've updated Package.swift, you may need to close Xcode and clear the following folders from the root directory: Package.resolved .build .swiftpm *.xcodeproj Once your updated packages have resolved successfully you should see compiler errors--probably quite a few. Don't worry! We'll show you how to fix them. Run \u00b6 The first order of business is to update your Run module's main.swift file to the new format. import App import Vapor var env = try Environment . detect () try LoggingSystem . bootstrap ( from : & env ) let app = Application ( env ) defer { app . shutdown () } try configure ( app ) try app . run () The main.swift file's contents replace the App module's app.swift , so you can delete that file. App \u00b6 Let's take a look at how to update the basic App module structure. configure.swift \u00b6 The configure method should be changed to accept an instance of Application . - public func configure(_ config: inout Config, _ env: inout Environment, _ services: inout Services) throws + public func configure(_ app: Application) throws Below is an example of an updated configure method. import Fluent import FluentSQLiteDriver import Vapor // Called before your application initializes. public func configure ( _ app : Application ) throws { // Serves files from `Public/` directory // app.middleware.use(FileMiddleware(publicDirectory: app.directory.publicDirectory)) // Configure SQLite database app . databases . use (. sqlite (. file ( \"db.sqlite\" )), as : . sqlite ) // Configure migrations app . migrations . add ( CreateTodo ()) try routes ( app ) } Syntax changes for configuring things like routing, middleware, fluent, and more are mentioned below. boot.swift \u00b6 boot 's contents can be placed in the configure method since it now accepts the application instance. routes.swift \u00b6 The routes method should be changed to accept an instance of Application . - public func routes(_ router: Router, _ container: Container) throws + public func routes(_ app: Application) throws More information on changes to routing syntax are mentioned below. Services \u00b6 Vapor 4's services APIs have been simplified to make it easier for you to discover and use services. Services are now exposed as methods and properties on Application and Request which allows the compiler to help you use them. To understand this better, let's take a look at a few examples. // Change the server's default port to 8281 - services.register { container -> NIOServerConfig in - return .default(port: 8281) - } + app.server.configuration.port = 8281 Instead of registering a NIOServerConfig to services, server configuration is now exposed as simple properties on Application that can be overridden. // Register cors middleware let corsConfiguration = CORSMiddleware.Configuration( allowedOrigin: .all, allowedMethods: [.POST, .GET, .PATCH, .PUT, .DELETE, .OPTIONS] ) let corsMiddleware = CORSMiddleware(configuration: corsConfiguration) - var middlewares = MiddlewareConfig() // Create _empty_ middleware config - middlewares.use(corsMiddleware) - services.register(middlewares) + app.middleware.use(corsMiddleware) Instead of creating and registering a MiddlewareConfig to services, middleware are now exposed as a property on Application that can be added to. // Make a request in a route handler. - try req.make(Client.self).get(\"https://vapor.codes\") + req.client.get(\"https://vapor.codes\") Like Application, Request also exposes services as simple properties and methods. Request-specific services should always be used when inside a route closure. This new service pattern replaces the Container , Service , and Config types from Vapor 3. Providers \u00b6 Providers are no longer required to configure third party packages. Each package instead extends Application and Request with new properties and methods for configuration. Take a look at how Leaf is configured in Vapor 4. // Use Leaf for view rendering. - try services.register(LeafProvider()) - config.prefer(LeafRenderer.self, for: ViewRenderer.self) + app.views.use(.leaf) To configure Leaf, use the app.leaf property. // Disable Leaf view caching. - services.register { container -> LeafConfig in - return LeafConfig(tags: ..., viewsDir: ..., shouldCache: false) - } + app.leaf.cache.isEnabled = false Environment \u00b6 The current environment (production, development, etc) can be accessed via app.environment . Custom Services \u00b6 Custom services conforming to the Service protocol and registered to the container in Vapor 3 can be now be expressed as extensions to either Application or Request. struct MyAPI { let client: Client func foo() { ... } } - extension MyAPI: Service { } - services.register { container -> MyAPI in - return try MyAPI(client: container.make()) - } + extension Request { + var myAPI: MyAPI { + .init(client: self.client) + } + } This service can then be accessed using the extension instead of make . - try req.make(MyAPI.self).foo() + req.myAPI.foo() Custom Providers \u00b6 Most custom services can be implemented using extensions as shown in the previous section. However, some advanced providers may need to hook into the application lifecycle or use stored properties. Application's new Lifecycle helper can be used to register lifecycle handlers. struct PrintHello : LifecycleHandler { func willBoot ( _ app : Application ) throws { print ( \"Hello!\" ) } } app . lifecycle . use ( PrintHello ()) To store values on Application, you case use the new Storage helper. struct MyNumber : StorageKey { typealias Value = Int } app . storage [ MyNumber . self ] = 5 print ( app . storage [ MyNumber . self ]) // 5 Accessing app.storage can be wrapped in a settable computed property to create a concise API. extension Application { var myNumber : Int ? { get { self . storage [ MyNumber . self ] } set { self . storage [ MyNumber . self ] = newValue } } } app . myNumber = 42 print ( app . myNumber ) // 42 Both Application and Request also have userInfo dictionaries for storing any data you may need. NIO \u00b6 Vapor 4 now exposes SwiftNIO's async APIs directly and does not attempt to overload methods like map and flatMap or alias types like EventLoopFuture . Vapor 3 provided overloads and aliases for backward compatibility with early beta versions that were released before SwiftNIO existed. These have been removed to reduce confusion with other SwiftNIO compatible packages and better follow SwiftNIO's best practice recommendations. Async naming changes \u00b6 The most obvious change is that the Future typealias for EventLoopFuture has been removed. This can be fixed fairly easily with a find and replace. Furthermore, NIO does not support the to: labels that Vapor 3 added. Given Swift 5.2's improved type inference, to: is less necessary now anyway. - futureA.map(to: String.self) { ... } + futureA.map { ... } Methods prefixed with new , like newPromise have been changed to make to better suit Swift style. - let promise = eventLoop.newPromise(String.self) + let promise = eventLoop.makePromise(of: String.self) catchMap is no longer available, but NIO's methods like mapError and flatMapErrorThrowing will work instead. Vapor 3's global flatMap method for combining multiple futures is no longer available. This can be replaced by using NIO's and method to combine many futures together. - flatMap(futureA, futureB) { a, b in + futureA.and(futureB).flatMap { (a, b) in // Do something with a and b. } ByteBuffer \u00b6 Many methods and properties that previously used Data now use NIO's ByteBuffer . This type is a more powerful and performant byte storage type. You can read more about its API in SwiftNIO's ByteBuffer docs . To convert a ByteBuffer back to Data , use: Data ( buffer . readableBytesView ) Throwing map / flatMap \u00b6 The most difficult change is that map and flatMap can no longer throw. map has a throwing version named (somewhat confusingly) flatMapThrowing . flatMap however has no throwing counterpart. This may require you to restructure some asynchronous code. Maps that do not throw should continue to work fine. // Non-throwing map. futureA . map { a in return b } Maps that do throw must be renamed to flatMapThrowing . - futureA.map { a in + futureA.flatMapThrowing { a in if ... { throw SomeError() } else { return futureB } } Flat-maps that do not throw should continue to work fine. // Non-throwing flatMap. futureA . flatMap { a in return futureB } Flat-maps that do throw must return a future error. // Returning a future error. futureA . flatMap { a in if ... { return eventLoop . makeFailedFuture ( SomeError ()) } else { return futureB } } When calling methods that throw, the error can be caught in a do / catch and returned as a future. // Returning a caught error as a future. futureA . flatMap { a in do { try doSomething () return futureB } catch { return eventLoop . makeFailedFuture ( error ) } } Throwing method calls can also be refactored into a flatMapThrowing and chained using tuples. // Refactored throwing method into flatMapThrowing with tuple-chaining. futureA . flatMapThrowing { a in try ( a , doSomeThing ()) }. flatMap { ( a , result ) in // result is the value of doSomething. return futureB } Routing \u00b6 Routes are now registered directly to Application. app . get ( \"hello\" ) { req in return \"Hello, world\" } This means you no longer need to register a router to services. Simply pass the application to your routes method and start adding routes. All of the methods available on RoutesBuilder are available on Application . Synchronous Content \u00b6 Decoding request content is now synchronous. let payload = try req . content . decode ( MyPayload . self ) print ( payload ) // MyPayload This behavior can be overridden by register routes using the .stream body collection strategy. app . on (. POST , \"streaming\" , body : . stream ) { req in // Request body is now asynchronous. req . body . collect (). map { buffer in HTTPStatus . ok } } Comma-separated paths \u00b6 Paths must now be comma separated and not contain / for consistency. - router.get(\"v1/users/\", \"posts\", \"/comments\") { req in + app.get(\"v1\", \"users\", \"posts\", \"comments\") { req in // Handle request. } Route parameters \u00b6 The Parameter protocol has been removed in favor of explicitly named parameters. This prevents issues with duplicate parameters and un-ordered fetching of parameters in middleware and route handlers. - router.get(\"planets\", String.parameter) { req in - let id = req.parameters.next(String.self) + app.get(\"planets\", \":id\") { req in + let id = req.parameters.get(\"id\") return \"Planet id: \\(id)\" } Route parameter usage with models is mentioned in the Fluent section. Middleware \u00b6 MiddlewareConfig has been renamed to MiddlewareConfiguration and is now a property on Application. You can add middleware to your app using app.middleware . let corsMiddleware = CORSMiddleware(configuration: ...) - var middleware = MiddlewareConfig() - middleware.use(corsMiddleware) + app.middleware.use(corsMiddleware) - services.register(middlewares) Middleware can no longer be registered by type name. Initialize the middleware first before registering. - middleware.use(ErrorMiddleware.self) + app.middleware.use(ErrorMiddleware.default(environment: app.environment)) To remove all default middleware, set app.middleware to an empty config using: app . middleware = . init () HTTP \u00b6 Coming soon. WebSocket \u00b6 Coming soon. Fluent \u00b6 Coming soon. Crypto \u00b6 Coming soon. Queues \u00b6 Coming soon. Validation \u00b6 Coming soon. Auth \u00b6 Coming soon. Stripe \u00b6 Coming soon. Mailgun \u00b6 Coming soon. Leaf \u00b6 Coming soon.","title":"Upgrading"},{"location":"upgrading/#upgrading-to-40","text":"This guide shows you how to upgrade an existing Vapor 3.x project to 4.0. This guide attempts to cover all of Vapor's official packages as well as some commonly used providers. If you notice anything missing, Vapor's team chat is a great place to ask for help. Issues and pull requests are also appreciated.","title":"Upgrading to 4.0"},{"location":"upgrading/#dependencies","text":"To use Vapor 4, you will need Xcode 11.4 and macOS 10.15 or greater. The Install section of the docs goes over installing dependencies.","title":"Dependencies"},{"location":"upgrading/#packageswift","text":"The first step to upgrading to Vapor 4 is to update your package's dependencies. Below is an example of an upgraded Package.swift file. You can also check out the updated template Package.swift . -// swift-tools-version:4.0 +// swift-tools-version:5.2 import PackageDescription let package = Package( name: \"api\", + platforms: [ + .macOS(.v10_15), + ], dependencies: [ - .package(url: \"https://github.com/vapor/fluent-postgresql.git\", from: \"1.0.0\"), + .package(url: \"https://github.com/vapor/fluent.git\", from: \"4.0.0-rc\"), + .package(url: \"https://github.com/vapor/fluent-postgres-driver.git\", from: \"2.0.0-rc\"), - .package(url: \"https://github.com/vapor/jwt.git\", from: \"3.0.0\"), + .package(url: \"https://github.com/vapor/jwt.git\", from: \"4.0.0-rc\"), - .package(url: \"https://github.com/vapor/vapor.git\", from: \"3.0.0\"), + .package(url: \"https://github.com/vapor/vapor.git\", from: \"4.0.0-rc\"), ], targets: [ .target(name: \"App\", dependencies: [ - \"FluentPostgreSQL\", + .product(name: \"Fluent\", package: \"fluent\"), + .product(name: \"FluentPostgresDriver\", package: \"fluent-postgres-driver\"), - \"Vapor\", + .product(name: \"Vapor\", package: \"vapor\"), - \"JWT\", + .product(name: \"JWT\", package: \"jwt\"), ]), - .target(name: \"Run\", dependencies: [\"App\"]), - .testTarget(name: \"AppTests\", dependencies: [\"App\"]) + .target(name: \"Run\", dependencies: [ + .target(name: \"App\"), + ]), + .testTarget(name: \"AppTests\", dependencies: [ + .target(name: \"App\"), + ]) ] ) All packages that have been upgraded for Vapor 4 will have their major version number incremented by one. Warning The -rc pre-release identifier is used since Vapor 4 has not been officially released yet.","title":"Package.swift"},{"location":"upgrading/#old-packages","text":"Some packages may not be upgraded yet. If you encounter any, file an issue to let the author know. Some Vapor 3 packages have been deprecated, such as: vapor/auth : Now included in Vapor. vapor/core : Absorbed into several modules. vapor/crypto : Replaced by SwiftCrypto. vapor/multipart : Now included in Vapor. vapor/url-encoded-form : Now included in Vapor. vapor-community/vapor-ext : Now included in Vapor. vapor-community/pagination : Now part of Fluent. IBM-Swift/LoggerAPI : Replaced by SwiftLogging.","title":"Old Packages"},{"location":"upgrading/#fluent","text":"vapor/fluent must now be added as a separate dependency to your dependencies list and targets. All database-specific packages have been suffixed with -driver to make the requirement on vapor/fluent clear. - .package(url: \"https://github.com/vapor/fluent-postgresql.git\", from: \"1.0.0\"), + .package(url: \"https://github.com/vapor/fluent.git\", from: \"4.0.0-rc\"), + .package(url: \"https://github.com/vapor/fluent-postgres-driver.git\", from: \"2.0.0-rc\"),","title":"Fluent"},{"location":"upgrading/#platforms","text":"Vapor's package manifests now explicitly support macOS 10.15 and greater. This means your package will also need to specify platform support. + platforms: [ + .macOS(.v10_15), + ], Vapor may add additional supported platforms in the future. Your package may support any subset of these platforms as long as the version number is equal or greater to Vapor's minimum version requirements.","title":"Platforms"},{"location":"upgrading/#xcode","text":"Vapor 4 utilizies Xcode 11's native SPM support. This means you will no longer need to generate .xcodeproj files. Opening your project's folder in Xcode will automatically recognize SPM and pull in dependencies. You can open your project natively in Xcode using vapor-beta xcode or open Package.swift . Once you've updated Package.swift, you may need to close Xcode and clear the following folders from the root directory: Package.resolved .build .swiftpm *.xcodeproj Once your updated packages have resolved successfully you should see compiler errors--probably quite a few. Don't worry! We'll show you how to fix them.","title":"Xcode"},{"location":"upgrading/#run","text":"The first order of business is to update your Run module's main.swift file to the new format. import App import Vapor var env = try Environment . detect () try LoggingSystem . bootstrap ( from : & env ) let app = Application ( env ) defer { app . shutdown () } try configure ( app ) try app . run () The main.swift file's contents replace the App module's app.swift , so you can delete that file.","title":"Run"},{"location":"upgrading/#app","text":"Let's take a look at how to update the basic App module structure.","title":"App"},{"location":"upgrading/#configureswift","text":"The configure method should be changed to accept an instance of Application . - public func configure(_ config: inout Config, _ env: inout Environment, _ services: inout Services) throws + public func configure(_ app: Application) throws Below is an example of an updated configure method. import Fluent import FluentSQLiteDriver import Vapor // Called before your application initializes. public func configure ( _ app : Application ) throws { // Serves files from `Public/` directory // app.middleware.use(FileMiddleware(publicDirectory: app.directory.publicDirectory)) // Configure SQLite database app . databases . use (. sqlite (. file ( \"db.sqlite\" )), as : . sqlite ) // Configure migrations app . migrations . add ( CreateTodo ()) try routes ( app ) } Syntax changes for configuring things like routing, middleware, fluent, and more are mentioned below.","title":"configure.swift"},{"location":"upgrading/#bootswift","text":"boot 's contents can be placed in the configure method since it now accepts the application instance.","title":"boot.swift"},{"location":"upgrading/#routesswift","text":"The routes method should be changed to accept an instance of Application . - public func routes(_ router: Router, _ container: Container) throws + public func routes(_ app: Application) throws More information on changes to routing syntax are mentioned below.","title":"routes.swift"},{"location":"upgrading/#services","text":"Vapor 4's services APIs have been simplified to make it easier for you to discover and use services. Services are now exposed as methods and properties on Application and Request which allows the compiler to help you use them. To understand this better, let's take a look at a few examples. // Change the server's default port to 8281 - services.register { container -> NIOServerConfig in - return .default(port: 8281) - } + app.server.configuration.port = 8281 Instead of registering a NIOServerConfig to services, server configuration is now exposed as simple properties on Application that can be overridden. // Register cors middleware let corsConfiguration = CORSMiddleware.Configuration( allowedOrigin: .all, allowedMethods: [.POST, .GET, .PATCH, .PUT, .DELETE, .OPTIONS] ) let corsMiddleware = CORSMiddleware(configuration: corsConfiguration) - var middlewares = MiddlewareConfig() // Create _empty_ middleware config - middlewares.use(corsMiddleware) - services.register(middlewares) + app.middleware.use(corsMiddleware) Instead of creating and registering a MiddlewareConfig to services, middleware are now exposed as a property on Application that can be added to. // Make a request in a route handler. - try req.make(Client.self).get(\"https://vapor.codes\") + req.client.get(\"https://vapor.codes\") Like Application, Request also exposes services as simple properties and methods. Request-specific services should always be used when inside a route closure. This new service pattern replaces the Container , Service , and Config types from Vapor 3.","title":"Services"},{"location":"upgrading/#providers","text":"Providers are no longer required to configure third party packages. Each package instead extends Application and Request with new properties and methods for configuration. Take a look at how Leaf is configured in Vapor 4. // Use Leaf for view rendering. - try services.register(LeafProvider()) - config.prefer(LeafRenderer.self, for: ViewRenderer.self) + app.views.use(.leaf) To configure Leaf, use the app.leaf property. // Disable Leaf view caching. - services.register { container -> LeafConfig in - return LeafConfig(tags: ..., viewsDir: ..., shouldCache: false) - } + app.leaf.cache.isEnabled = false","title":"Providers"},{"location":"upgrading/#environment","text":"The current environment (production, development, etc) can be accessed via app.environment .","title":"Environment"},{"location":"upgrading/#custom-services","text":"Custom services conforming to the Service protocol and registered to the container in Vapor 3 can be now be expressed as extensions to either Application or Request. struct MyAPI { let client: Client func foo() { ... } } - extension MyAPI: Service { } - services.register { container -> MyAPI in - return try MyAPI(client: container.make()) - } + extension Request { + var myAPI: MyAPI { + .init(client: self.client) + } + } This service can then be accessed using the extension instead of make . - try req.make(MyAPI.self).foo() + req.myAPI.foo()","title":"Custom Services"},{"location":"upgrading/#custom-providers","text":"Most custom services can be implemented using extensions as shown in the previous section. However, some advanced providers may need to hook into the application lifecycle or use stored properties. Application's new Lifecycle helper can be used to register lifecycle handlers. struct PrintHello : LifecycleHandler { func willBoot ( _ app : Application ) throws { print ( \"Hello!\" ) } } app . lifecycle . use ( PrintHello ()) To store values on Application, you case use the new Storage helper. struct MyNumber : StorageKey { typealias Value = Int } app . storage [ MyNumber . self ] = 5 print ( app . storage [ MyNumber . self ]) // 5 Accessing app.storage can be wrapped in a settable computed property to create a concise API. extension Application { var myNumber : Int ? { get { self . storage [ MyNumber . self ] } set { self . storage [ MyNumber . self ] = newValue } } } app . myNumber = 42 print ( app . myNumber ) // 42 Both Application and Request also have userInfo dictionaries for storing any data you may need.","title":"Custom Providers"},{"location":"upgrading/#nio","text":"Vapor 4 now exposes SwiftNIO's async APIs directly and does not attempt to overload methods like map and flatMap or alias types like EventLoopFuture . Vapor 3 provided overloads and aliases for backward compatibility with early beta versions that were released before SwiftNIO existed. These have been removed to reduce confusion with other SwiftNIO compatible packages and better follow SwiftNIO's best practice recommendations.","title":"NIO"},{"location":"upgrading/#async-naming-changes","text":"The most obvious change is that the Future typealias for EventLoopFuture has been removed. This can be fixed fairly easily with a find and replace. Furthermore, NIO does not support the to: labels that Vapor 3 added. Given Swift 5.2's improved type inference, to: is less necessary now anyway. - futureA.map(to: String.self) { ... } + futureA.map { ... } Methods prefixed with new , like newPromise have been changed to make to better suit Swift style. - let promise = eventLoop.newPromise(String.self) + let promise = eventLoop.makePromise(of: String.self) catchMap is no longer available, but NIO's methods like mapError and flatMapErrorThrowing will work instead. Vapor 3's global flatMap method for combining multiple futures is no longer available. This can be replaced by using NIO's and method to combine many futures together. - flatMap(futureA, futureB) { a, b in + futureA.and(futureB).flatMap { (a, b) in // Do something with a and b. }","title":"Async naming changes"},{"location":"upgrading/#bytebuffer","text":"Many methods and properties that previously used Data now use NIO's ByteBuffer . This type is a more powerful and performant byte storage type. You can read more about its API in SwiftNIO's ByteBuffer docs . To convert a ByteBuffer back to Data , use: Data ( buffer . readableBytesView )","title":"ByteBuffer"},{"location":"upgrading/#throwing-map-flatmap","text":"The most difficult change is that map and flatMap can no longer throw. map has a throwing version named (somewhat confusingly) flatMapThrowing . flatMap however has no throwing counterpart. This may require you to restructure some asynchronous code. Maps that do not throw should continue to work fine. // Non-throwing map. futureA . map { a in return b } Maps that do throw must be renamed to flatMapThrowing . - futureA.map { a in + futureA.flatMapThrowing { a in if ... { throw SomeError() } else { return futureB } } Flat-maps that do not throw should continue to work fine. // Non-throwing flatMap. futureA . flatMap { a in return futureB } Flat-maps that do throw must return a future error. // Returning a future error. futureA . flatMap { a in if ... { return eventLoop . makeFailedFuture ( SomeError ()) } else { return futureB } } When calling methods that throw, the error can be caught in a do / catch and returned as a future. // Returning a caught error as a future. futureA . flatMap { a in do { try doSomething () return futureB } catch { return eventLoop . makeFailedFuture ( error ) } } Throwing method calls can also be refactored into a flatMapThrowing and chained using tuples. // Refactored throwing method into flatMapThrowing with tuple-chaining. futureA . flatMapThrowing { a in try ( a , doSomeThing ()) }. flatMap { ( a , result ) in // result is the value of doSomething. return futureB }","title":"Throwing map / flatMap"},{"location":"upgrading/#routing","text":"Routes are now registered directly to Application. app . get ( \"hello\" ) { req in return \"Hello, world\" } This means you no longer need to register a router to services. Simply pass the application to your routes method and start adding routes. All of the methods available on RoutesBuilder are available on Application .","title":"Routing"},{"location":"upgrading/#synchronous-content","text":"Decoding request content is now synchronous. let payload = try req . content . decode ( MyPayload . self ) print ( payload ) // MyPayload This behavior can be overridden by register routes using the .stream body collection strategy. app . on (. POST , \"streaming\" , body : . stream ) { req in // Request body is now asynchronous. req . body . collect (). map { buffer in HTTPStatus . ok } }","title":"Synchronous Content"},{"location":"upgrading/#comma-separated-paths","text":"Paths must now be comma separated and not contain / for consistency. - router.get(\"v1/users/\", \"posts\", \"/comments\") { req in + app.get(\"v1\", \"users\", \"posts\", \"comments\") { req in // Handle request. }","title":"Comma-separated paths"},{"location":"upgrading/#route-parameters","text":"The Parameter protocol has been removed in favor of explicitly named parameters. This prevents issues with duplicate parameters and un-ordered fetching of parameters in middleware and route handlers. - router.get(\"planets\", String.parameter) { req in - let id = req.parameters.next(String.self) + app.get(\"planets\", \":id\") { req in + let id = req.parameters.get(\"id\") return \"Planet id: \\(id)\" } Route parameter usage with models is mentioned in the Fluent section.","title":"Route parameters"},{"location":"upgrading/#middleware","text":"MiddlewareConfig has been renamed to MiddlewareConfiguration and is now a property on Application. You can add middleware to your app using app.middleware . let corsMiddleware = CORSMiddleware(configuration: ...) - var middleware = MiddlewareConfig() - middleware.use(corsMiddleware) + app.middleware.use(corsMiddleware) - services.register(middlewares) Middleware can no longer be registered by type name. Initialize the middleware first before registering. - middleware.use(ErrorMiddleware.self) + app.middleware.use(ErrorMiddleware.default(environment: app.environment)) To remove all default middleware, set app.middleware to an empty config using: app . middleware = . init ()","title":"Middleware"},{"location":"upgrading/#http","text":"Coming soon.","title":"HTTP"},{"location":"upgrading/#websocket","text":"Coming soon.","title":"WebSocket"},{"location":"upgrading/#fluent_1","text":"Coming soon.","title":"Fluent"},{"location":"upgrading/#crypto","text":"Coming soon.","title":"Crypto"},{"location":"upgrading/#queues","text":"Coming soon.","title":"Queues"},{"location":"upgrading/#validation","text":"Coming soon.","title":"Validation"},{"location":"upgrading/#auth","text":"Coming soon.","title":"Auth"},{"location":"upgrading/#stripe","text":"Coming soon.","title":"Stripe"},{"location":"upgrading/#mailgun","text":"Coming soon.","title":"Mailgun"},{"location":"upgrading/#leaf","text":"Coming soon.","title":"Leaf"},{"location":"validation/","text":"Validation \u00b6 Vapor's Validation API helps you validate incoming request before using the Content API to decode data. Introduction \u00b6 Vapor's deep integration of Swift's type-safe Codable protocol means you don't need to worry about data validation as much compared to dynamically typed languages. However, there are still a few reasons why you might want to opt-in to explicit validation using the Validation API. Human-Readable Errors \u00b6 Decoding structs using the Content API will yield errors if any of the data is not valid. However, these error messages can sometimes lack human-readability. For example, take the following string-backed enum: enum Color : String , Codable { case red , blue , green } If a user tries to pass the string \"purple\" to a property of type Color , they will get an error similar to the following: Cannot initialize Color from invalid String value purple for key favoriteColor While this error is technically correct and successfully protected the endpoint from an invalid value, it could do better informing the user about the mistake and which options are available. By using the Validation API, you can generate errors like the following: favoriteColor is not red, blue, or green Furthermore, Codable will stop attempting to decode a type as soon as the first error is hit. This means that even if there are many invalid properties in the request, the user will only see the first error. The Validation API will report all validation failures in a single request. Specific Validation \u00b6 Codable handles type validation well, but sometimes you want more than that. For example, validating the contents of a string or validating the size of an integer. The Validation API has validators for helping to validate data like emails, character sets, integer ranges, and more. Validatable \u00b6 To validate a request, you will need to generate a Validations collection. This is most commonly done by conforming an existing type to Validatable . Let's take a look at how you could add validation to this simple POST /users endpoint. This guide assumes you are already familiar with the Content API. enum Color : String , Codable { case red , blue , green } struct CreateUser : Content { var name : String var username : String var age : Int var email : String var favoriteColor : Color ? } app . post ( \"users\" ) { req -> CreateUser in let user = try req . content . decode ( CreateUser . self ) // Do something with user. return user } Adding Validations \u00b6 The first step is to conform the type you are decoding, in this case CreateUser , to Validatable . This can be done in an extension. extension CreateUser : Validatable { static func validations ( _ validations : inout Validations ) { // Validations go here. } } The static method validations(_:) will be called when CreateUser is validated. Any validations you want to perform should be added to the supplied Validations collection. Let's take a look at adding a simple validation to require that the user's email is valid. validations . add ( \"email\" , as : String . self , is : . email ) The first parameter is the value's expected key, in this case \"email\" . This should match the property name on the type being validated. The second parameter, as , is the expected type, in this case String . The type usually matches the property's type, but not always. Finally, one or more validators can be added after the third parameter, is . In this case, we are adding a single validator that checks if the value is an email address. Validating Request \u00b6 Once you've conformed your type to Validatable , the static validate(_:) function can be used to validate requests. Add the following line before req.content.decode(CreateUser.self) in the route handler. try CreateUser . validate ( req ) Now, try sending the following request containing an invalid email: POST /users HTTP / 1.1 Content-Length : 67 Content-Type : application/json { \"age\" : 4 , \"email\" : \"foo\" , \"favoriteColor\" : \"green\" , \"name\" : \"Foo\" , \"username\" : \"foo\" } You should see the following error returned: email is not a valid email address Integer Validation \u00b6 Great, now let's try adding a validation for age . validations . add ( \"age\" , as : Int . self , is : . range ( 13. ..)) The age validation requires that the age is greater than or equal to 13 . If you try the same request from above, you should see a new error now: age is less than minimum of 13, email is not a valid email address String Validation \u00b6 Next, let's add validations for name and username . validations . add ( \"name\" , as : String . self , is : ! . empty ) validations . add ( \"username\" , as : String . self , is : . count ( 3. ..) && . alphanumeric ) The name validation uses the ! operator to invert the .empty validation. This will require that the string is not empty. The username validation combines two validators using && . This will require that the string is at least 3 characters long and contains only alphanumeric characters. Enum Validation \u00b6 Finally, let's take a look at a slightly more advanced validation to check that the supplied favoriteColor is valid. validations . add ( \"favoriteColor\" , as : String . self , is : . in ( \"red\" , \"blue\" , \"green\" ), required : false ) Since it's not possible to decode a Color from an invalid value, this validation uses String as the base type. It uses the .in validator to verify that the value is a valid option: red, blue, or green. Since this value is optional, required is set to false to signal that validation should not fail if this key is missing from the request data. Note that while the favorite color validation will pass if the key is missing, it will not pass if null is supplied. If you want to support null , change the validation type to String? and use the .nil || (read as: \"is nil or ...\") convenience. validations . add ( \"favoriteColor\" , as : String ?. self , is : . nil || . in ( \"red\" , \"blue\" , \"green\" ), required : false ) Validators \u00b6 Below is a list of the currently supported validators and a brief explanation of what they do. Validation Description .ascii Contains only ASCII characters. .alphanumeric Contains only alphanumeric characters. .characterSet(_:) Contains only characters from supplied CharacterSet . .count(_:) Collection's count is within supplied bounds. .email Contains a valid email. .empty Collection is empty. .in(_:) Value is in supplied Collection . .nil Value is null . .range(_:) Value is within supplied Range . .url Contains a valid URL. Validators can also be combined to build complex validations using operators. Operator Position Description ! prefix Inverts a validator, requiring the opposite. && infix Combines two validators, requires both. || infix Combines two validators, requires one.","title":"Validation"},{"location":"validation/#validation","text":"Vapor's Validation API helps you validate incoming request before using the Content API to decode data.","title":"Validation"},{"location":"validation/#introduction","text":"Vapor's deep integration of Swift's type-safe Codable protocol means you don't need to worry about data validation as much compared to dynamically typed languages. However, there are still a few reasons why you might want to opt-in to explicit validation using the Validation API.","title":"Introduction"},{"location":"validation/#human-readable-errors","text":"Decoding structs using the Content API will yield errors if any of the data is not valid. However, these error messages can sometimes lack human-readability. For example, take the following string-backed enum: enum Color : String , Codable { case red , blue , green } If a user tries to pass the string \"purple\" to a property of type Color , they will get an error similar to the following: Cannot initialize Color from invalid String value purple for key favoriteColor While this error is technically correct and successfully protected the endpoint from an invalid value, it could do better informing the user about the mistake and which options are available. By using the Validation API, you can generate errors like the following: favoriteColor is not red, blue, or green Furthermore, Codable will stop attempting to decode a type as soon as the first error is hit. This means that even if there are many invalid properties in the request, the user will only see the first error. The Validation API will report all validation failures in a single request.","title":"Human-Readable Errors"},{"location":"validation/#specific-validation","text":"Codable handles type validation well, but sometimes you want more than that. For example, validating the contents of a string or validating the size of an integer. The Validation API has validators for helping to validate data like emails, character sets, integer ranges, and more.","title":"Specific Validation"},{"location":"validation/#validatable","text":"To validate a request, you will need to generate a Validations collection. This is most commonly done by conforming an existing type to Validatable . Let's take a look at how you could add validation to this simple POST /users endpoint. This guide assumes you are already familiar with the Content API. enum Color : String , Codable { case red , blue , green } struct CreateUser : Content { var name : String var username : String var age : Int var email : String var favoriteColor : Color ? } app . post ( \"users\" ) { req -> CreateUser in let user = try req . content . decode ( CreateUser . self ) // Do something with user. return user }","title":"Validatable"},{"location":"validation/#adding-validations","text":"The first step is to conform the type you are decoding, in this case CreateUser , to Validatable . This can be done in an extension. extension CreateUser : Validatable { static func validations ( _ validations : inout Validations ) { // Validations go here. } } The static method validations(_:) will be called when CreateUser is validated. Any validations you want to perform should be added to the supplied Validations collection. Let's take a look at adding a simple validation to require that the user's email is valid. validations . add ( \"email\" , as : String . self , is : . email ) The first parameter is the value's expected key, in this case \"email\" . This should match the property name on the type being validated. The second parameter, as , is the expected type, in this case String . The type usually matches the property's type, but not always. Finally, one or more validators can be added after the third parameter, is . In this case, we are adding a single validator that checks if the value is an email address.","title":"Adding Validations"},{"location":"validation/#validating-request","text":"Once you've conformed your type to Validatable , the static validate(_:) function can be used to validate requests. Add the following line before req.content.decode(CreateUser.self) in the route handler. try CreateUser . validate ( req ) Now, try sending the following request containing an invalid email: POST /users HTTP / 1.1 Content-Length : 67 Content-Type : application/json { \"age\" : 4 , \"email\" : \"foo\" , \"favoriteColor\" : \"green\" , \"name\" : \"Foo\" , \"username\" : \"foo\" } You should see the following error returned: email is not a valid email address","title":"Validating Request"},{"location":"validation/#integer-validation","text":"Great, now let's try adding a validation for age . validations . add ( \"age\" , as : Int . self , is : . range ( 13. ..)) The age validation requires that the age is greater than or equal to 13 . If you try the same request from above, you should see a new error now: age is less than minimum of 13, email is not a valid email address","title":"Integer Validation"},{"location":"validation/#string-validation","text":"Next, let's add validations for name and username . validations . add ( \"name\" , as : String . self , is : ! . empty ) validations . add ( \"username\" , as : String . self , is : . count ( 3. ..) && . alphanumeric ) The name validation uses the ! operator to invert the .empty validation. This will require that the string is not empty. The username validation combines two validators using && . This will require that the string is at least 3 characters long and contains only alphanumeric characters.","title":"String Validation"},{"location":"validation/#enum-validation","text":"Finally, let's take a look at a slightly more advanced validation to check that the supplied favoriteColor is valid. validations . add ( \"favoriteColor\" , as : String . self , is : . in ( \"red\" , \"blue\" , \"green\" ), required : false ) Since it's not possible to decode a Color from an invalid value, this validation uses String as the base type. It uses the .in validator to verify that the value is a valid option: red, blue, or green. Since this value is optional, required is set to false to signal that validation should not fail if this key is missing from the request data. Note that while the favorite color validation will pass if the key is missing, it will not pass if null is supplied. If you want to support null , change the validation type to String? and use the .nil || (read as: \"is nil or ...\") convenience. validations . add ( \"favoriteColor\" , as : String ?. self , is : . nil || . in ( \"red\" , \"blue\" , \"green\" ), required : false )","title":"Enum Validation"},{"location":"validation/#validators","text":"Below is a list of the currently supported validators and a brief explanation of what they do. Validation Description .ascii Contains only ASCII characters. .alphanumeric Contains only alphanumeric characters. .characterSet(_:) Contains only characters from supplied CharacterSet . .count(_:) Collection's count is within supplied bounds. .email Contains a valid email. .empty Collection is empty. .in(_:) Value is in supplied Collection . .nil Value is null . .range(_:) Value is within supplied Range . .url Contains a valid URL. Validators can also be combined to build complex validations using operators. Operator Position Description ! prefix Inverts a validator, requiring the opposite. && infix Combines two validators, requires both. || infix Combines two validators, requires one.","title":"Validators"},{"location":"websockets/","text":"WebSockets \u00b6 WebSockets allow for two-way communication between a client and server. Unlike HTTP, which has a request and response pattern, WebSocket peers can send an arbitrary number of messages in either direction. Vapor's WebSocket API allows you to create both clients and servers that handle messages asynchronously. Server \u00b6 WebSocket endpoints can be added to your existing Vapor application using the Routing API. Use the webSocket method like you would use get or post . app . webSocket ( \"echo\" ) { req , ws in // Connected WebSocket. print ( ws ) } WebSocket routes can be grouped and protected by middleware like normal routes. In addition to accepting the incoming HTTP request, WebSocket handlers accept the newly established WebSocket connection. See below for more information on using this WebSocket to send and read messages. Client \u00b6 To connect to a remote WebSocket endpoint, use WebSocket.connect . WebSocket . connect ( to : \"ws://echo.websocket.org\" , on : eventLoop ) { ws in // Connected WebSocket. print ( ws ) } The connect method returns a future that completes when the connection is established. Once connected, the supplied closure will be called with the newly connected WebSocket. See below for more information on using this WebSocket to send and read messages. Messages \u00b6 The WebSocket class has methods for sending and receiving messages as well as listening for events like closure. WebSockets can transmit data via two protocols: text and binary. Text messages are interpreted as UTF-8 strings while binary data is interpreted as an array of bytes. Sending \u00b6 Messages can be sent using the WebSocket's send method. ws . send ( \"Hello, world\" ) Passing a String to this method results in a text message being sent. Binary messages can be sent by passing a [UInt8] . ws . send ([ 1 , 2 , 3 ]) Message sending is asynchronous. You can supply an EventLoopPromise to the send method to be notified when the message has finished sending or failed to send. let promise = eventLoop . makePromise ( of : Void . self ) ws . send (..., promise : promise ) promise . futureResult . whenComplete { result in // Succeeded or failed to send. } Receiving \u00b6 Incoming messages are handled via the onText and onBinary callbacks. ws . onText { ws , text in // String received by this WebSocket. print ( text ) } ws . onBinary { ws , binary in // [UInt8] received by this WebSocket. print ( binary ) } The WebSocket itself is supplied as the first parameter to these callbacks to prevent reference cycles. Use this reference to take action on the WebSocket after receiving data. For example, to send a reply: // Echoes received messages. ws . onText { ws , text in ws . send ( text ) } Closing \u00b6 To close a WebSocket, call the close method. ws . close () This method returns a future that will be completed when the WebSocket has closed. Like send , you may also pass a promise to this method. ws . close ( promise : nil ) To be notified when the peer closes the connection, use onClose . This future will be completed when either the client or server closes the WebSocket. ws . onClose . whenComplete { result in // Succeeded or failed to close. } The closeCode property is set when the WebSocket closes. This can be used to determine why the peer closed the connection. Ping / Pong \u00b6 Ping and pong messages are sent automatically by the client and server to keep WebSocket connections alive. Your application can listen for these events using the onPing and onPong callbacks. ws . onPing { ws in // Ping was received. } ws . onPong { ws in // Pong was received. }","title":"WebSockets"},{"location":"websockets/#websockets","text":"WebSockets allow for two-way communication between a client and server. Unlike HTTP, which has a request and response pattern, WebSocket peers can send an arbitrary number of messages in either direction. Vapor's WebSocket API allows you to create both clients and servers that handle messages asynchronously.","title":"WebSockets"},{"location":"websockets/#server","text":"WebSocket endpoints can be added to your existing Vapor application using the Routing API. Use the webSocket method like you would use get or post . app . webSocket ( \"echo\" ) { req , ws in // Connected WebSocket. print ( ws ) } WebSocket routes can be grouped and protected by middleware like normal routes. In addition to accepting the incoming HTTP request, WebSocket handlers accept the newly established WebSocket connection. See below for more information on using this WebSocket to send and read messages.","title":"Server"},{"location":"websockets/#client","text":"To connect to a remote WebSocket endpoint, use WebSocket.connect . WebSocket . connect ( to : \"ws://echo.websocket.org\" , on : eventLoop ) { ws in // Connected WebSocket. print ( ws ) } The connect method returns a future that completes when the connection is established. Once connected, the supplied closure will be called with the newly connected WebSocket. See below for more information on using this WebSocket to send and read messages.","title":"Client"},{"location":"websockets/#messages","text":"The WebSocket class has methods for sending and receiving messages as well as listening for events like closure. WebSockets can transmit data via two protocols: text and binary. Text messages are interpreted as UTF-8 strings while binary data is interpreted as an array of bytes.","title":"Messages"},{"location":"websockets/#sending","text":"Messages can be sent using the WebSocket's send method. ws . send ( \"Hello, world\" ) Passing a String to this method results in a text message being sent. Binary messages can be sent by passing a [UInt8] . ws . send ([ 1 , 2 , 3 ]) Message sending is asynchronous. You can supply an EventLoopPromise to the send method to be notified when the message has finished sending or failed to send. let promise = eventLoop . makePromise ( of : Void . self ) ws . send (..., promise : promise ) promise . futureResult . whenComplete { result in // Succeeded or failed to send. }","title":"Sending"},{"location":"websockets/#receiving","text":"Incoming messages are handled via the onText and onBinary callbacks. ws . onText { ws , text in // String received by this WebSocket. print ( text ) } ws . onBinary { ws , binary in // [UInt8] received by this WebSocket. print ( binary ) } The WebSocket itself is supplied as the first parameter to these callbacks to prevent reference cycles. Use this reference to take action on the WebSocket after receiving data. For example, to send a reply: // Echoes received messages. ws . onText { ws , text in ws . send ( text ) }","title":"Receiving"},{"location":"websockets/#closing","text":"To close a WebSocket, call the close method. ws . close () This method returns a future that will be completed when the WebSocket has closed. Like send , you may also pass a promise to this method. ws . close ( promise : nil ) To be notified when the peer closes the connection, use onClose . This future will be completed when either the client or server closes the WebSocket. ws . onClose . whenComplete { result in // Succeeded or failed to close. } The closeCode property is set when the WebSocket closes. This can be used to determine why the peer closed the connection.","title":"Closing"},{"location":"websockets/#ping-pong","text":"Ping and pong messages are sent automatically by the client and server to keep WebSocket connections alive. Your application can listen for these events using the onPing and onPong callbacks. ws . onPing { ws in // Ping was received. } ws . onPong { ws in // Pong was received. }","title":"Ping / Pong"},{"location":"deploy/digital-ocean/","text":"Deploying to DigitalOcean \u00b6 This guide will walk you through deploying a simple Hello, world Vapor application to a Droplet . To follow this guide, you will need to have a DigitalOcean account with billing configured. Create Server \u00b6 Let's start by installing Swift on an Ubuntu server. Use the create menu to create a new Droplet. Under distributions, select Ubuntu 18.04 LTS. Note You may select any version of Ubuntu that Swift supports. At the time of writing, Swift 5.2 supports 16.04 and 18.04. You can check which operating systems are officially supported on the Swift Releases page. After selecting the distribution, choose any plan and datacenter region you prefer. Then setup an SSH key to access the server after it is created. Finally, click create Droplet and wait for the new server to spin up. Once the new server is ready, hover over the Droplet's IP address and click copy. Initial Setup \u00b6 Open your terminal and connect to the server as root using SSH. ssh root@your_server_ip DigitalOcean has an in-depth guide for initial server setup on Ubuntu 18.04 . This guide will quickly cover the basics. Configure Firewall \u00b6 Allow OpenSSH through the firewall and enable it. ufw allow OpenSSH ufw enable Add User \u00b6 Create a new user besides root . This guide calls the new user vapor . adduser vapor Allow the newly created user to use sudo . usermod -aG sudo vapor Copy the root user's authorized SSH keys to the newly created user. This will allow you to SSH in as the new user. rsync --archive --chown = vapor:vapor ~/.ssh /home/vapor Finally, exit the current SSH session and login as the newly created user. exit ssh vapor@your_server_ip Install Swift \u00b6 Now that you've created a new Ubuntu server and logged in as a non-root user you can install Swift. Swift Dependencies \u00b6 Install Swift's required dependencies. sudo apt-get update sudo apt-get install clang libicu-dev libatomic1 build-essential pkg-config Download Toolchain \u00b6 This guide will install Swift 5.2.0. Visit the Swift Downloads page for a link to latest release. Copy the download link for Ubuntu 18.04. Download and decompress the Swift toolchain. wget https://swift.org/builds/swift-5.2-release/ubuntu1804/swift-5.2-RELEASE/swift-5.2-RELEASE-ubuntu18.04.tar.gz tar xzf swift-5.2-RELEASE-ubuntu18.04.tar.gz Note Swift's Using Downloads guide includes information on how to verify downloads using PGP signatures. Install Toolchain \u00b6 Move Swift somewhere easy to acess. This guide will use /swift with each compiler version in a subfolder. sudo mkdir /swift sudo mv swift-5.2-RELEASE-ubuntu18.04 /swift/5.2.0 Add Swift to /usr/bin so it can be executed by vapor and root . sudo ln -s /swift/5.2.0/usr/bin/swift /usr/bin/swift Verify that Swift was installed correctly. swift --version Setup Project \u00b6 Now that Swift is installed, let's clone and compile your project. For this example, we'll be using Vapor's API template . First let's install Vapor's system dependencies. sudo apt-get install openssl libssl-dev zlib1g-dev libsqlite3-dev Allow HTTP through the firewall. sudo ufw allow http Clone & Build \u00b6 Now clone the project and build it. git clone https://github.com/vapor/api-template.git cd api-template swift build Tip If you are building this project for production, use swift build -c release Run \u00b6 Once the project has finished compiling, run it on your server's IP at port 80. sudo .build/debug/Run serve -b 157 .245.244.228:80 If you used swift build -c release , then you need to run: sudo .build/release/Run serve -b 157 .245.244.228:80 Visit your server's IP via browser or local terminal and you should see \"It works!\". $ curl http://157.245.244.228 It works! Back on your server, you should see logs for the test request. [ NOTICE ] Server starting on http://157.245.244.228:80 [ INFO ] GET / Use CTRL+C to quit the server. It may take a second to shutdown. Congratulations on getting your Vapor app running on a DigitalOcean Droplet! Next Steps \u00b6 The rest of this guide points to additional resources to improve your deployment. Supervisor \u00b6 Supervisor is a process control system that can run and monitor your Vapor executable. With supervisor setup, your app can automatically start when the server boots and be restarted in case it crashes. Learn more about Supervisor . Nginx \u00b6 Nginx is an extremely fast, battle tested, and easy-to-configure HTTP server and proxy. While Vapor supports directly serving HTTP requests, proxying behind Nginx can provide increased performance, security, and ease-of-use. Learn more about Nginx .","title":"DigitalOcean"},{"location":"deploy/digital-ocean/#deploying-to-digitalocean","text":"This guide will walk you through deploying a simple Hello, world Vapor application to a Droplet . To follow this guide, you will need to have a DigitalOcean account with billing configured.","title":"Deploying to DigitalOcean"},{"location":"deploy/digital-ocean/#create-server","text":"Let's start by installing Swift on an Ubuntu server. Use the create menu to create a new Droplet. Under distributions, select Ubuntu 18.04 LTS. Note You may select any version of Ubuntu that Swift supports. At the time of writing, Swift 5.2 supports 16.04 and 18.04. You can check which operating systems are officially supported on the Swift Releases page. After selecting the distribution, choose any plan and datacenter region you prefer. Then setup an SSH key to access the server after it is created. Finally, click create Droplet and wait for the new server to spin up. Once the new server is ready, hover over the Droplet's IP address and click copy.","title":"Create Server"},{"location":"deploy/digital-ocean/#initial-setup","text":"Open your terminal and connect to the server as root using SSH. ssh root@your_server_ip DigitalOcean has an in-depth guide for initial server setup on Ubuntu 18.04 . This guide will quickly cover the basics.","title":"Initial Setup"},{"location":"deploy/digital-ocean/#configure-firewall","text":"Allow OpenSSH through the firewall and enable it. ufw allow OpenSSH ufw enable","title":"Configure Firewall"},{"location":"deploy/digital-ocean/#add-user","text":"Create a new user besides root . This guide calls the new user vapor . adduser vapor Allow the newly created user to use sudo . usermod -aG sudo vapor Copy the root user's authorized SSH keys to the newly created user. This will allow you to SSH in as the new user. rsync --archive --chown = vapor:vapor ~/.ssh /home/vapor Finally, exit the current SSH session and login as the newly created user. exit ssh vapor@your_server_ip","title":"Add User"},{"location":"deploy/digital-ocean/#install-swift","text":"Now that you've created a new Ubuntu server and logged in as a non-root user you can install Swift.","title":"Install Swift"},{"location":"deploy/digital-ocean/#swift-dependencies","text":"Install Swift's required dependencies. sudo apt-get update sudo apt-get install clang libicu-dev libatomic1 build-essential pkg-config","title":"Swift Dependencies"},{"location":"deploy/digital-ocean/#download-toolchain","text":"This guide will install Swift 5.2.0. Visit the Swift Downloads page for a link to latest release. Copy the download link for Ubuntu 18.04. Download and decompress the Swift toolchain. wget https://swift.org/builds/swift-5.2-release/ubuntu1804/swift-5.2-RELEASE/swift-5.2-RELEASE-ubuntu18.04.tar.gz tar xzf swift-5.2-RELEASE-ubuntu18.04.tar.gz Note Swift's Using Downloads guide includes information on how to verify downloads using PGP signatures.","title":"Download Toolchain"},{"location":"deploy/digital-ocean/#install-toolchain","text":"Move Swift somewhere easy to acess. This guide will use /swift with each compiler version in a subfolder. sudo mkdir /swift sudo mv swift-5.2-RELEASE-ubuntu18.04 /swift/5.2.0 Add Swift to /usr/bin so it can be executed by vapor and root . sudo ln -s /swift/5.2.0/usr/bin/swift /usr/bin/swift Verify that Swift was installed correctly. swift --version","title":"Install Toolchain"},{"location":"deploy/digital-ocean/#setup-project","text":"Now that Swift is installed, let's clone and compile your project. For this example, we'll be using Vapor's API template . First let's install Vapor's system dependencies. sudo apt-get install openssl libssl-dev zlib1g-dev libsqlite3-dev Allow HTTP through the firewall. sudo ufw allow http","title":"Setup Project"},{"location":"deploy/digital-ocean/#clone-build","text":"Now clone the project and build it. git clone https://github.com/vapor/api-template.git cd api-template swift build Tip If you are building this project for production, use swift build -c release","title":"Clone &amp; Build"},{"location":"deploy/digital-ocean/#run","text":"Once the project has finished compiling, run it on your server's IP at port 80. sudo .build/debug/Run serve -b 157 .245.244.228:80 If you used swift build -c release , then you need to run: sudo .build/release/Run serve -b 157 .245.244.228:80 Visit your server's IP via browser or local terminal and you should see \"It works!\". $ curl http://157.245.244.228 It works! Back on your server, you should see logs for the test request. [ NOTICE ] Server starting on http://157.245.244.228:80 [ INFO ] GET / Use CTRL+C to quit the server. It may take a second to shutdown. Congratulations on getting your Vapor app running on a DigitalOcean Droplet!","title":"Run"},{"location":"deploy/digital-ocean/#next-steps","text":"The rest of this guide points to additional resources to improve your deployment.","title":"Next Steps"},{"location":"deploy/digital-ocean/#supervisor","text":"Supervisor is a process control system that can run and monitor your Vapor executable. With supervisor setup, your app can automatically start when the server boots and be restarted in case it crashes. Learn more about Supervisor .","title":"Supervisor"},{"location":"deploy/digital-ocean/#nginx","text":"Nginx is an extremely fast, battle tested, and easy-to-configure HTTP server and proxy. While Vapor supports directly serving HTTP requests, proxying behind Nginx can provide increased performance, security, and ease-of-use. Learn more about Nginx .","title":"Nginx"},{"location":"deploy/nginx/","text":"Deploying with Nginx \u00b6 Nginx is an extremely fast, battle tested, and easy-to-configure HTTP server and proxy. While Vapor supports directly serving HTTP requests with or without TLS, proxying behind Nginx can provide increased performance, security, and ease-of-use. Note We recommend proxying Vapor HTTP servers behind Nginx. Overview \u00b6 What does it mean to proxy an HTTP server? In short, a proxy acts as a middleman between the public internet and your HTTP server. Requests come to the proxy and then it sends them to Vapor. An important feature of this middleman proxy is that it can alter or even redirect the requests. For instance, the proxy can require that the client use TLS (https), rate limit requests, or even serve public files without talking to your Vapor application. More Detail \u00b6 The default port for receiving HTTP requests is port 80 (and 443 for HTTPS). When you bind a Vapor server to port 80 , it will directly receive and respond to the HTTP requests that come to your server. When adding a proxy like Nginx, you bind Vapor to an internal port, like port 8080 . Note Ports greater than 1024 do not require sudo to bind. When Vapor is bound to a port besides 80 or 443 , it will not be accessible to the outside internet. You then bind Nginx to port 80 and configure it to route requests to your Vapor server bound at port 8080 (or whichever port you've chosen). And that's it. If Nginx is properly configured, you will see your Vapor app responding to requests on port 80 . Nginx proxies the requests and responses invisibly. Install Nginx \u00b6 The first step is installing Nginx. One of the great parts of Nginx is the tremendous amount of community resources and documentation surrounding it. Because of this, we will not go into great detail here about installing Nginx as there is almost definitely a tutorial for your specific platform, OS, and provider. Tutorials: How To Install Nginx on Ubuntu 14.04 LTS How To Install Nginx on Ubuntu 16.04 How to Deploy Nginx on Heroku How To Run Nginx in a Docker Container on Ubuntu 14.04 APT \u00b6 Nginx can be installed through APT. sudo apt-get update sudo apt-get install nginx Check whether Nginx was installed correctly by visiting your server's IP address in a browser http://server_domain_name_or_IP Service \u00b6 The service can be started or stopped. sudo service nginx stop sudo service nginx start sudo service nginx restart Booting Vapor \u00b6 Nginx can be started an stopped with the sudo service nginx ... commands. You will need something similar to start and stop your Vapor server. There are many ways to do this, and they depend on which platform you are deploying to. Check out the Supervisor instructions to add commands for starting and stopping your Vapor app. Configure Proxy \u00b6 The configuration files for enabled sites can be found in /etc/nginx/sites-enabled/ . Create a new file or copy the example template from /etc/nginx/sites-available/ to get started. Here is an example configuration file for a Vapor project called Hello in the home directory. server { server_name hello.com ; listen 80 ; root /home/vapor/Hello/Public/ ; location @proxy { proxy_pass http://127.0.0.1:8080 ; proxy_pass_header Server ; proxy_set_header Host $host ; proxy_set_header X-Real-IP $remote_addr ; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for ; proxy_pass_header Server ; proxy_connect_timeout 3s ; proxy_read_timeout 10s ; } } This configuration file assumes the Hello project binds to port 8080 when started in production mode. Serving Files \u00b6 Nginx can also serve public files without asking your Vapor app. This can improve performance by freeing up the Vapor process for other tasks under heavy load. server { ... # Serve all public/static files via nginx and then fallback to Vapor for the rest try_files $uri @proxy ; location @proxy { ... } } TLS \u00b6 Adding TLS is relatively straightforward as long as the certificates have been properly generated. To generate TLS certificates for free, check out Let's Encrypt . server { ... listen 443 ssl ; ssl_certificate /etc/letsencrypt/live/hello.com/fullchain.pem ; ssl_certificate_key /etc/letsencrypt/live/hello.com/privkey.pem ; ssl_protocols TLSv1 TLSv1.1 TLSv1.2 ; ssl_prefer_server_ciphers on ; ssl_dhparam /etc/ssl/certs/dhparam.pem ; ssl_ciphers 'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA' ; ssl_session_timeout 1d ; ssl_session_cache shared:SSL:50m ; ssl_stapling on ; ssl_stapling_verify on ; add_header Strict-Transport-Security max-age = 15768000 ; ... location @proxy { ... } } The configuration above are the relatively strict settings for TLS with Nginx. Some of the settings here are not required, but enhance security.","title":"Nginx"},{"location":"deploy/nginx/#deploying-with-nginx","text":"Nginx is an extremely fast, battle tested, and easy-to-configure HTTP server and proxy. While Vapor supports directly serving HTTP requests with or without TLS, proxying behind Nginx can provide increased performance, security, and ease-of-use. Note We recommend proxying Vapor HTTP servers behind Nginx.","title":"Deploying with Nginx"},{"location":"deploy/nginx/#overview","text":"What does it mean to proxy an HTTP server? In short, a proxy acts as a middleman between the public internet and your HTTP server. Requests come to the proxy and then it sends them to Vapor. An important feature of this middleman proxy is that it can alter or even redirect the requests. For instance, the proxy can require that the client use TLS (https), rate limit requests, or even serve public files without talking to your Vapor application.","title":"Overview"},{"location":"deploy/nginx/#more-detail","text":"The default port for receiving HTTP requests is port 80 (and 443 for HTTPS). When you bind a Vapor server to port 80 , it will directly receive and respond to the HTTP requests that come to your server. When adding a proxy like Nginx, you bind Vapor to an internal port, like port 8080 . Note Ports greater than 1024 do not require sudo to bind. When Vapor is bound to a port besides 80 or 443 , it will not be accessible to the outside internet. You then bind Nginx to port 80 and configure it to route requests to your Vapor server bound at port 8080 (or whichever port you've chosen). And that's it. If Nginx is properly configured, you will see your Vapor app responding to requests on port 80 . Nginx proxies the requests and responses invisibly.","title":"More Detail"},{"location":"deploy/nginx/#install-nginx","text":"The first step is installing Nginx. One of the great parts of Nginx is the tremendous amount of community resources and documentation surrounding it. Because of this, we will not go into great detail here about installing Nginx as there is almost definitely a tutorial for your specific platform, OS, and provider. Tutorials: How To Install Nginx on Ubuntu 14.04 LTS How To Install Nginx on Ubuntu 16.04 How to Deploy Nginx on Heroku How To Run Nginx in a Docker Container on Ubuntu 14.04","title":"Install Nginx"},{"location":"deploy/nginx/#apt","text":"Nginx can be installed through APT. sudo apt-get update sudo apt-get install nginx Check whether Nginx was installed correctly by visiting your server's IP address in a browser http://server_domain_name_or_IP","title":"APT"},{"location":"deploy/nginx/#service","text":"The service can be started or stopped. sudo service nginx stop sudo service nginx start sudo service nginx restart","title":"Service"},{"location":"deploy/nginx/#booting-vapor","text":"Nginx can be started an stopped with the sudo service nginx ... commands. You will need something similar to start and stop your Vapor server. There are many ways to do this, and they depend on which platform you are deploying to. Check out the Supervisor instructions to add commands for starting and stopping your Vapor app.","title":"Booting Vapor"},{"location":"deploy/nginx/#configure-proxy","text":"The configuration files for enabled sites can be found in /etc/nginx/sites-enabled/ . Create a new file or copy the example template from /etc/nginx/sites-available/ to get started. Here is an example configuration file for a Vapor project called Hello in the home directory. server { server_name hello.com ; listen 80 ; root /home/vapor/Hello/Public/ ; location @proxy { proxy_pass http://127.0.0.1:8080 ; proxy_pass_header Server ; proxy_set_header Host $host ; proxy_set_header X-Real-IP $remote_addr ; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for ; proxy_pass_header Server ; proxy_connect_timeout 3s ; proxy_read_timeout 10s ; } } This configuration file assumes the Hello project binds to port 8080 when started in production mode.","title":"Configure Proxy"},{"location":"deploy/nginx/#serving-files","text":"Nginx can also serve public files without asking your Vapor app. This can improve performance by freeing up the Vapor process for other tasks under heavy load. server { ... # Serve all public/static files via nginx and then fallback to Vapor for the rest try_files $uri @proxy ; location @proxy { ... } }","title":"Serving Files"},{"location":"deploy/nginx/#tls","text":"Adding TLS is relatively straightforward as long as the certificates have been properly generated. To generate TLS certificates for free, check out Let's Encrypt . server { ... listen 443 ssl ; ssl_certificate /etc/letsencrypt/live/hello.com/fullchain.pem ; ssl_certificate_key /etc/letsencrypt/live/hello.com/privkey.pem ; ssl_protocols TLSv1 TLSv1.1 TLSv1.2 ; ssl_prefer_server_ciphers on ; ssl_dhparam /etc/ssl/certs/dhparam.pem ; ssl_ciphers 'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA' ; ssl_session_timeout 1d ; ssl_session_cache shared:SSL:50m ; ssl_stapling on ; ssl_stapling_verify on ; add_header Strict-Transport-Security max-age = 15768000 ; ... location @proxy { ... } } The configuration above are the relatively strict settings for TLS with Nginx. Some of the settings here are not required, but enhance security.","title":"TLS"},{"location":"deploy/supervisor/","text":"Supervisor \u00b6 Supervisor is a process control system that makes it easy to start, stop, and restart your Vapor app. Install \u00b6 sudo apt-get update sudo apt-get install supervisor Configure \u00b6 Each Vapor app on your server should have its own configuration file. For an example Hello project, the configuration file would be located at /etc/supervisor/conf.d/hello.conf [ program:hello ] command = /home/vapor/hello/.build/release/Run serve --env production directory = /home/vapor/hello/ user = vapor stdout_logfile = /var/log/supervisor/% ( program_name ) -stdout.log stderr_logfile = /var/log/supervisor/% ( program_name ) -stderr.log As specified in our configuration file the Hello project is located in the home folder for the user vapor . Make sure directory points to the root directory of your project where the Package.swift file is. The --env production flag will disable verbose logging. Environment \u00b6 You can export variables to your Vapor app with supervisor. environment = PORT = 8123 Exported variables can be used in Vapor using Environment.get let port = Environment . get ( \"PORT\" ) Start \u00b6 You can now load and start your app. supervisorctl reread supervisorctl add hello supervisorctl start hello Note The add command may have already started your app.","title":"Supervisor"},{"location":"deploy/supervisor/#supervisor","text":"Supervisor is a process control system that makes it easy to start, stop, and restart your Vapor app.","title":"Supervisor"},{"location":"deploy/supervisor/#install","text":"sudo apt-get update sudo apt-get install supervisor","title":"Install"},{"location":"deploy/supervisor/#configure","text":"Each Vapor app on your server should have its own configuration file. For an example Hello project, the configuration file would be located at /etc/supervisor/conf.d/hello.conf [ program:hello ] command = /home/vapor/hello/.build/release/Run serve --env production directory = /home/vapor/hello/ user = vapor stdout_logfile = /var/log/supervisor/% ( program_name ) -stdout.log stderr_logfile = /var/log/supervisor/% ( program_name ) -stderr.log As specified in our configuration file the Hello project is located in the home folder for the user vapor . Make sure directory points to the root directory of your project where the Package.swift file is. The --env production flag will disable verbose logging.","title":"Configure"},{"location":"deploy/supervisor/#environment","text":"You can export variables to your Vapor app with supervisor. environment = PORT = 8123 Exported variables can be used in Vapor using Environment.get let port = Environment . get ( \"PORT\" )","title":"Environment"},{"location":"deploy/supervisor/#start","text":"You can now load and start your app. supervisorctl reread supervisorctl add hello supervisorctl start hello Note The add command may have already started your app.","title":"Start"},{"location":"fluent/migrations/","text":"Migrations \u00b6 Coming soon.","title":"Migrations"},{"location":"fluent/migrations/#migrations","text":"Coming soon.","title":"Migrations"},{"location":"fluent/models/","text":"Models \u00b6 Coming soon.","title":"Models"},{"location":"fluent/models/#models","text":"Coming soon.","title":"Models"},{"location":"fluent/overview/","text":"Fluent \u00b6 Fluent is an ORM framework for Swift. It takes advantage of Swift's strong type system to provide an easy-to-use interface for your database. Using Fluent centers around the creation of model types which represent data structures in your database. These models are then used to perform create, read, update, and delete operations instead of writing raw queries. Configuration \u00b6 When creating a project using vapor new , answer \"yes\" to including Fluent and choose which database driver you want to use. This will automatically add the dependencies to your new project as well as example configuration code. Existing Project \u00b6 If you have an existing project that you want to add Fluent to, you will need to add two dependencies to your package : vapor/fluent @4.0.0 One (or more) Fluent driver(s) of your choice . package ( url : \"https://github.com/vapor/fluent.git\" , from : \"4.0.0-beta\" ), . package ( url : \"https://github.com/vapor/fluent-<db>-driver.git\" , from : < version >), . target ( name : \"App\" , dependencies : [ . product ( name : \"Fluent\" , package : \"fluent\" ), . product ( name : \"Fluent<db>Driver\" , package : \"fluent-<db>-driver\" ), . product ( name : \"Vapor\" , package : \"vapor\" ), ]), Once the packages are added as dependencies, you can configure your databases using app.databases in configure.swift . import Fluent import Fluent < db > Driver app . databases . use (< db config >, as : < identifier >) Each of the Fluent drivers below has more specific instructions for configuration. Drivers \u00b6 Fluent currently has three officially supported drivers. You can search GitHub for the tag fluent-driver for a full list of official and third-party Fluent database drivers. PostgreSQL \u00b6 PostgreSQL is an open source, standards compliant SQL database. It is easily configurable on most cloud hosting providers. This is Fluent's recommended database driver. To use PostgreSQL, add the following dependencies to your package. . package ( url : \"https://github.com/vapor/fluent-postgres-driver.git\" , from : \"2.0.0-beta\" ) . product ( name : \"FluentPostgresDriver\" , package : \"fluent-postgres-driver\" ) Once the dependencies are added, configure the database's credentials with Fluent using app.databases.use in configure.swift . import Fluent import FluentPostgresDriver app . databases . use (. postgres ( hostname : \"localhost\" , username : \"vapor\" , password : \"vapor\" , database : \"vapor\" ), as : . psql ) You can also parse the credentials from a database connection string. try app . databases . use (. postgres ( url : \"<connection string>\" ), as : . psql ) SQLite \u00b6 SQLite is an open source, embedded SQL database. Its simplistic nature makes it a great candiate for prototyping and testing. To use SQLite, add the following dependencies to your package. . package ( url : \"https://github.com/vapor/fluent-sqlite-driver.git\" , from : \"4.0.0-beta\" ) . product ( name : \"FluentSQLiteDriver\" , package : \"fluent-sqlite-driver\" ) Once the dependencies are added, configure the database with Fluent using app.databases.use in configure.swift . import Fluent import FluentSQLiteDriver app . databases . use (. sqlite (. file ( \"db.sqlite\" )), as : . sqlite ) You can also configure SQLite to store the database ephemerally in memory. app . databases . use (. sqlite (. memory ), as : . sqlite ) If you use an in-memory database, make sure to set Fluent to migrate automatically using --auto-migrate or run app.autoMigrate() after adding migrations. app . migrations . add ( CreateTodo ()) try app . autoMigrate (). wait () MySQL \u00b6 MySQL is a popular open source SQL database. It is available on many cloud hosting providers. This driver also supports MariaDB. To use MySQL, add the following dependencies to your package. . package ( url : \"https://github.com/vapor/fluent-mysql-driver.git\" , from : \"4.0.0-beta\" ) . product ( name : \"FluentMySQLDriver\" , package : \"fluent-mysql-driver\" ) Once the dependencies are added, configure the database's credentials with Fluent using app.databases.use in configure.swift . import Fluent import FluentMySQLDriver app . databases . use (. mysql ( hostname : \"localhost\" , username : \"vapor\" , password : \"vapor\" , database : \"vapor\" ), as : . mysql ) You can also parse the credentials from a database connection string. try app . databases . use (. mysql ( url : \"<connection string>\" ), as : . mysql ) Models \u00b6 Models represent fixed data structures in your database, like tables or collections. Models have one or more fields that store codable values. All models also have a unique identifier. Property wrappers are used to denote identifiers and fields as well as more complex mappings mentioned later. Take a look at the following model which represents a galaxy. final class Galaxy : Model { // Name of the table or collection. static let schema = \"galaxies\" // Unique identifier for this Galaxy. @ ID ( key : . id ) var id : UUID ? // The Galaxy's name. @ Field ( key : \"name\" ) var name : String // Creates a new, empty Galaxy. init () { } // Creates a new Galaxy with all properties set. init ( id : UUID ? = nil , name : String ) { self . id = id self . name = name } } To create a new model, create a new class conforming to Model . Tip It's recommended to mark model classes final to improve performance and simplify conformance requirements. The Model protocol's first requirement is the static string schema . static let schema = \"galaxies\" This property tells Fluent which table or collection the model corresponds to. This can be a table that already exists in the database or one that you will create with a migration . The schema is usually snake_case and plural. Identifier \u00b6 The next requirement is an identifier field named id . @ ID ( key : . id ) var id : UUID ? This field must use the @ID property wrapper. Fluent recommends using UUID and the special .id field key since this is compatible with all of Fluent's drivers. If you want to use a custom ID key or type, use the @ID(custom:) overload. Fields \u00b6 After the identifier is added, you can add however many fields you'd like to store additional information. In this example, the only additional field is the galaxy's name. @ Field ( key : \"name\" ) var name : String For simple fields, the @Field property wrapper is used. Like @ID , the key parameter specifies the field's name in the database. This is especially useful for cases where database field naming convention may be different than in Swift, e.g., using snake_case instead of camelCase . Next, all models require an empty init. This allows Fluent to create new instances of the model. init () { } Finally, you can add a convenience init for your model that sets all of its properties. init ( id : UUID ? = nil , name : String ) { self . id = id self . name = name } Using convenience inits is especially helpful if you add new properties to your model as you can get compile-time errors if the init method changes. Migrations \u00b6 If your database uses pre-defined schemas, like SQL databases, you will need a migration to prepare the database for your model. Migrations are also useful for seeding databases with data. To create a migration, define a new type conforming to the Migration protocol. Take a look at the following migration for the previously defined Galaxy model. struct CreateGalaxy : Migration { // Prepares the database for storing Galaxy models. func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"galaxies\" ) . id () . field ( \"name\" , . string ) . create () } // Optionally reverts the changes made in the prepare method. func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"galaxies\" ). delete () } } The prepare method is used for preparing the database to store Galaxy models. Schema \u00b6 In this method, database.schema(_:) is used to create a new SchemaBuilder . One or more field s are then added to the builder before calling create() to create the schema. Each field added to the builder has a name, type, and optional constraints. field (< name >, < type >, < optional constraints >) There is a convenience id() method for adding @ID properties using Fluent's recommended defaults. Reverting the migration undoes any changes made in the prepare method. In this case, that means deleting the Galaxy's schema. Once the migration is defined, you must tell Fluent about it by adding it to app.migrations in configure.swift . app . migrations . add ( CreateGalaxy ()) Migrate \u00b6 To run migrations, call vapor run migrate from the command line or add migrate as an argument to Xcode's Run scheme. $ vapor run migrate Migrate Command: Prepare The following migration(s) will be prepared: + CreateGalaxy on default Would you like to continue? y/n> y Migration successful Querying \u00b6 Now that you've successfully created a model and migrated your database, you're ready to make your first query. All \u00b6 Take a look at the following route which will return an array of all the galaxies in the database. app . get ( \"galaxies\" ) { req in Galaxy . query ( on : req . db ). all () } In order to return a Galaxy directly in a route closure, add conformance to Content . final class Galaxy : Model , Content { ... } Galaxy.query is used to create a new query builder for the model. req.db is a reference to the default database for your application. Finally, all() returns all of the models stored in the database. If you compile and run the project and request GET /galaxies , you should see an empty array returned. Let's add a route for creating a new galaxy. Create \u00b6 Following RESTful convention, use the POST /galaxies endpoint for creating a new galaxy. Since models are codable, you can decode a galaxy directly from the request body. app . post ( \"galaxies\" ) { req -> EventLoopFuture < Galaxy > in let galaxy = try req . content . decode ( Galaxy . self ) return galaxy . create ( on : req . db ) . map { galaxy } } Seealso See Content \u2192 Overview for more information about decoding request bodies. Once you have an instance of the model, calling create(on:) saves the model to the database. This returns an EventLoopFuture<Void> which signals that the save has completed. Once the save completes, return the newly created model using map . Build and run the project and send the following request. POST /galaxies HTTP / 1.1 content-length : 21 content-type : application/json { \"name\" : \"Milky Way\" } You should get the created model back with an identifier as the response. { \"id\" : ... , \"name\" : \"Milky Way\" } Now, if you query GET /galaxies again, you should see the newly created galaxy returned in the array. Relations \u00b6 What are galaxies without stars! Let's take a quick look at Fluent's powerful relational features by adding a one-to-many relation between Galaxy and a new Star model. final class Star : Model , Content { // Name of the table or collection. static let schema = \"stars\" // Unique identifier for this Star. @ ID ( key : . id ) var id : UUID ? // The Star's name. @ Field ( key : \"name\" ) var name : String // Reference to the Galaxy this Star is in. @ Parent ( key : \"galaxy_id\" ) var galaxy : Galaxy // Creates a new, empty Star. init () { } // Creates a new Star with all properties set. init ( id : UUID ? = nil , name : String , galaxyID : UUID ) { self . id = id self . name = name self . $ galaxy . id = galaxyID } } Parent \u00b6 The new Star model is very similar to Galaxy except for a new field type: @Parent . @ Parent ( key : \"galaxy_id\" ) var galaxy : Galaxy The parent property is a field that stores another model's identifier. The model holding the reference is called the \"child\" and the referenced model is called the \"parent\". This type of relation is also known as \"one-to-many\". The key parameter to the property specifies the field name that should be used to store the parent's key in the database. In the init method, the parent identifier is set using $galaxy . self . $ galaxy . id = galaxyID By prefixing the parent property's name with $ , you access the underlying property wrapper. This is required for getting access to the internal @Field that stores the actual identifier value. Seealso Check out the Swift Evolution proposal for property wrappers for more information: [SE-0258] Property Wrappers Next, create a migration to prepare the database for handling Star . struct CreateStar : Migration { // Prepares the database for storing Star models. func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"stars\" ) . id () . field ( \"name\" , . string ) . field ( \"galaxy_id\" , . uuid , . references ( \"galaxies\" , \"id\" )) . create () } // Optionally reverts the changes made in the prepare method. func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"stars\" ). delete () } } This is mostly the same as galaxy's migration except for the additional field to store the parent galaxy's identifier. field ( \"galaxy_id\" , . uuid , . references ( \"galaxies\" , \"id\" )) This field specifies an optional constraint telling the database that the field's value references the field \"id\" in the \"galaxies\" schema. This is also known as a foreign key and helps ensure data integrity. Once the migration is created, add it to app.migrations after the CreateGalaxy migration. app . migrations . add ( CreateGalaxy ()) app . migrations . add ( CreateStar ()) Since migrations run in order, and CreateStar references the galaxies schema, ordering is important. Finally, run the migrations to prepare the database. Add a route for creating new stars. app . post ( \"stars\" ) { req -> EventLoopFuture < Star > in let star = try req . content . decode ( Star . self ) return star . create ( on : req . db ) . map { star } } Create a new star referencing the previously created galaxy using the following HTTP request. POST /stars HTTP / 1.1 content-length : 36 content-type : application/json { \"name\" : \"Sun\" , \"galaxy\" : { \"id\" : ... } } You should see the newly created star returned with a unique identifier. { \"id\" : ... , \"name\" : \"Sun\" , \"galaxy\" : { \"id\" : ... } } Children \u00b6 Now let's take a look at how you can utilize Fluent's eager-loading feature to automatically return a galaxy's stars in the GET /galaxies route. Add the following property to the Galaxy model. // All the Stars in this Galaxy. @ Children ( for : \\ . $ galaxy ) var stars : [ Star ] The @Children property wrapper is the inverse of @Parent . It takes a key-path to the child's @Parent field as the for argument. Its value is an array of children since zero or more child models may exist. No changes to the galaxy's migration are needed since all the information needed for this relation is stored on Star . Eager Load \u00b6 Now that the relation is complete, you can use the with method on the query builder to automatically fetch and serialize the galaxy-star relation. app . get ( \"galaxies\" ) { req in Galaxy . query ( on : req . db ). with ( \\ . $ stars ). all () } A key-path to the @Children relation is passed to with to tell Fluent to automatically load this relation in all of the resulting models. Build and run and send another request to GET /galaxies . You should now see the stars automatically included in the response. [ { \"id\" : ... , \"name\" : \"Milky Way\" , \"stars\" : [ { \"id\" : ... , \"name\" : \"Sun\" , \"galaxy\" : { \"id\" : ... } } ] } ] Siblings \u00b6 The last type of relationship is many-to-many, or sibling relationship. Create a Tag model with an id and name field that we'll use to tag stars with certain characteristics. final class Tag : Model , Content { // Name of the table or collection. static let schema : String = \"tags\" // Unique identifier for this Tag. @ ID ( key : . id ) var id : UUID ? // The Tag's name. @ Field ( key : \"name\" ) var name : String // Creates a new, empty Tag. init () {} // Creates a new Tag with all properties set. init ( id : UUID ? = nil , name : String ) { self . id = id self . name = name } } A tag can have many stars and a star can have many tags making them siblings. A sibling relationship between two models requires a third model (called a pivot) that holds the relationship data. Each of these StarTag model objects will represent a single star-to-tag relationship holding the ids of a single Star and a single Tag : final class StarTag : Model { // Name of the table or collection. static let schema : String = \"star_tag\" // Unique identifier for this pivot. @ ID ( key : . id ) var id : UUID ? // Reference to the Tag this pivot relates. @ Parent ( key : \"tag_id\" ) var tag : Tag // Reference to the Star this pivot relates. @ Parent ( key : \"star_id\" ) var star : Star // Creates a new, empty pivot. init () {} // Creates a new pivot with all properties set. init ( tagID : UUID , starID : UUID ) { self . $ tag . id = tagID self . $ star . id = starID } } Now let's update our new Tag model to add a stars property for all the stars that contain a tag: @ Siblings ( through : StarTag . self , from : \\ . $ tag , to : \\ . $ star ) var stars : [ Star ] The @Siblings property wrapper takes three arguments. The first argument is the pivot model that we created earlier, StarTag . The next two arguments are key paths to the pivot model's parent relations. The from key path is the pivot's parent relation to the current model, in this case Tag . The to key path is the pivot's parent relation to the related model, in this case Star . These three arguments together create a relation from the current model Tag , through the pivot StarTag , to the desired model Star . Now let's update our Star model with its siblings property which is the inverse of the one we just created: @ Siblings ( through : StarTag . self , from : \\ . $ star , to : \\ . $ tag ) var tags : [ Tag ] These siblings properties rely on StarTag for storage so we don't need to update the Star migration, but we do need to create migrations for the new Tag and StarTag models: struct CreateTag : Migration { func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"tags\" ) . id () . field ( \"name\" , . string ) . create () } func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"tags\" ). delete () } } struct CreateStarTag : Migration { func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"star_tag\" ) . id () . field ( \"star_id\" , . uuid , . required , . references ( \"star\" , \"id\" )) . field ( \"tag_id\" , . uuid , . required , . references ( \"star\" , \"id\" )) . create () } func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"star_tag\" ). delete () } } And then add the migrations in configure.swift: app . migrations . add ( CreateTag ()) app . migrations . add ( CreateStarTag ()) Now we want to add tags to stars. After creating a route to create a new tag, we need to create a route that will add a tag to an existing star. app . post ( \"star\" , \":starID\" , \"tag\" , \":tagID\" ) { req -> EventLoopFuture < HTTPStatus > in let star = Star . find ( req . parameters . get ( \"starID\" ), on : req . db ) . unwrap ( or : Abort (. notFound )) let tag = Tag . find ( req . parameters . get ( \"tagID\" ), on : req . db ) . unwrap ( or : Abort (. notFound )) return star . and ( tag ). flatMap { ( star , tag ) in star . $ tags . attach ( tag , on : req . db ) }. transform ( to : . ok ) } This route includes parameter path components for the IDs of star and tag that we want to associate with one another. If we want to create a relationship between a star with an ID of 1 and a tag with an ID of 2, we'd send a POST request to /star/1/tag/2 and we'd receive an HTTP response code in return. First, we lookup the star and tag in the database to ensure these are valid IDs. Then, we create the relationship by attaching the tag to the star's tags. Since the star's tags property is a relationship to another model, we need to access it via it's @Siblings property wrapper by using the $ operator. Siblings aren't fetched by default so we need to update our get route for stars if we want include them when querying by inserting the with method: app . get ( \"stars\" ) { req in Star . query ( on : req . db ). with ( \\ . $ tags ). all () } Lifecycle \u00b6 To create hooks that respond to events on your Model , you can create middlewares for your model. Your middleware must conform to ModelMiddleware . Here is an example of a simple middleware: struct GalaxyMiddleware : ModelMiddleware { // Runs when a model is created func create ( model : Galaxy , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { return next . create ( model , on : db ) } // Runs when a model is updated func update ( model : Galaxy , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { return next . update ( model , on : db ) } // Runs when a model is soft deleted func softDelete ( model : Galaxy , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { return next . softDelete ( model , on : db ) } // Runs when a soft deleted model is restored func restore ( model : Galaxy , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { return next . restore ( model , on : db ) } // Runs when a model is deleted // If the \"force\" parameter is true, the model will be permanently deleted, // even when using soft delete timestamps. func delete ( model : Galaxy , force : Bool , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { return next . delete ( model , force : force , on : db ) } } Each of these methods has a default implementation, so you only need to include the methods you require. You should return the corresponding method on the next AnyModelResponder so Fluent continues processing the event. Important The middleware will only respond to lifecycle events of the Model type provided in the functions. In the above example GalaxyMiddleware will respond to events on the Galaxy model. Using these methods you can perform actions both before, and after the event completes. Performing actions after the event completes can be done using using .flatMap() on the future returned from the next responder. For example: struct GalaxyMiddleware : ModelMiddleware { func create ( model : Galaxy , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { // The model can be altered here before it is created model . name = \"<New Galaxy Name>\" return next . create ( model , on : db ). flatMap { // Once the galaxy has been created, the code here will be executed print ( \"Galaxy \\( model . name ) was created\" ) } } } Once you have created your middleware, you must register it with the Application 's database middleware configuration so Vapor will use it. In configure.swift add: app . databases . middleware . use ( GalaxyMiddleware (), on : . psql ) Timestamps \u00b6 Fluent provides the ability to track creation and update times on models by specifying Timestamp fields in your model. Fluent automatically sets the fields when necessary. You can add these like so: @ Timestamp ( key : \"created_at\" , on : . create ) var createdAt : Date ? @ Timestamp ( key : \"updated_at\" , on : . update ) var updatedAt : Date ? Info You can use any name/key for these fields. created_at / updated_at , are only for illustration purposes Timestamps are added as fields in a migration using the .datetime data type. database . schema (...) ... . field ( \"created_at\" , . datetime ) . field ( \"updated_at\" , . datetime ) . create () Soft Delete \u00b6 Soft deletion marks an item as deleted in the database but doesn't actually remove it. This can be useful when you have data retention requirements, for example. In Fluent, it works by setting a deletion timestamp. By default, soft deleted items won't appear in queries and can be restored at any time. Similar to created and deleted timestamps, to enable soft deletion in a model just set a deletion timestamp for .delete : @ Timestamp ( key : \"deleted_at\" , on : . delete ) var deletedAt : Date ? Calling Model.delete(on:) on a model that has a delete timestamp property will automatically soft delete it. If you need to perform a query that includes the soft deleted items, you can use withDeleted() in your query. // Get all galaxies including soft-deleted ones. Galaxy . query ( on : db ). withDeleted (). all () You can restore a soft deleted model with restore(on:) : // Restore galaxy galaxy . restore ( on : db ) To permanently delete an item with an on-delete timestamp, use the force parameter: // Permanently delete galaxy . delete ( force : true , on : db ) Next Steps \u00b6 Congratulations on creating your first models and migrations and performing basic create and read operations. For more in-depth information on all of these features, check out their respective sections in the Fluent guide.","title":"Overview"},{"location":"fluent/overview/#fluent","text":"Fluent is an ORM framework for Swift. It takes advantage of Swift's strong type system to provide an easy-to-use interface for your database. Using Fluent centers around the creation of model types which represent data structures in your database. These models are then used to perform create, read, update, and delete operations instead of writing raw queries.","title":"Fluent"},{"location":"fluent/overview/#configuration","text":"When creating a project using vapor new , answer \"yes\" to including Fluent and choose which database driver you want to use. This will automatically add the dependencies to your new project as well as example configuration code.","title":"Configuration"},{"location":"fluent/overview/#existing-project","text":"If you have an existing project that you want to add Fluent to, you will need to add two dependencies to your package : vapor/fluent @4.0.0 One (or more) Fluent driver(s) of your choice . package ( url : \"https://github.com/vapor/fluent.git\" , from : \"4.0.0-beta\" ), . package ( url : \"https://github.com/vapor/fluent-<db>-driver.git\" , from : < version >), . target ( name : \"App\" , dependencies : [ . product ( name : \"Fluent\" , package : \"fluent\" ), . product ( name : \"Fluent<db>Driver\" , package : \"fluent-<db>-driver\" ), . product ( name : \"Vapor\" , package : \"vapor\" ), ]), Once the packages are added as dependencies, you can configure your databases using app.databases in configure.swift . import Fluent import Fluent < db > Driver app . databases . use (< db config >, as : < identifier >) Each of the Fluent drivers below has more specific instructions for configuration.","title":"Existing Project"},{"location":"fluent/overview/#drivers","text":"Fluent currently has three officially supported drivers. You can search GitHub for the tag fluent-driver for a full list of official and third-party Fluent database drivers.","title":"Drivers"},{"location":"fluent/overview/#postgresql","text":"PostgreSQL is an open source, standards compliant SQL database. It is easily configurable on most cloud hosting providers. This is Fluent's recommended database driver. To use PostgreSQL, add the following dependencies to your package. . package ( url : \"https://github.com/vapor/fluent-postgres-driver.git\" , from : \"2.0.0-beta\" ) . product ( name : \"FluentPostgresDriver\" , package : \"fluent-postgres-driver\" ) Once the dependencies are added, configure the database's credentials with Fluent using app.databases.use in configure.swift . import Fluent import FluentPostgresDriver app . databases . use (. postgres ( hostname : \"localhost\" , username : \"vapor\" , password : \"vapor\" , database : \"vapor\" ), as : . psql ) You can also parse the credentials from a database connection string. try app . databases . use (. postgres ( url : \"<connection string>\" ), as : . psql )","title":"PostgreSQL"},{"location":"fluent/overview/#sqlite","text":"SQLite is an open source, embedded SQL database. Its simplistic nature makes it a great candiate for prototyping and testing. To use SQLite, add the following dependencies to your package. . package ( url : \"https://github.com/vapor/fluent-sqlite-driver.git\" , from : \"4.0.0-beta\" ) . product ( name : \"FluentSQLiteDriver\" , package : \"fluent-sqlite-driver\" ) Once the dependencies are added, configure the database with Fluent using app.databases.use in configure.swift . import Fluent import FluentSQLiteDriver app . databases . use (. sqlite (. file ( \"db.sqlite\" )), as : . sqlite ) You can also configure SQLite to store the database ephemerally in memory. app . databases . use (. sqlite (. memory ), as : . sqlite ) If you use an in-memory database, make sure to set Fluent to migrate automatically using --auto-migrate or run app.autoMigrate() after adding migrations. app . migrations . add ( CreateTodo ()) try app . autoMigrate (). wait ()","title":"SQLite"},{"location":"fluent/overview/#mysql","text":"MySQL is a popular open source SQL database. It is available on many cloud hosting providers. This driver also supports MariaDB. To use MySQL, add the following dependencies to your package. . package ( url : \"https://github.com/vapor/fluent-mysql-driver.git\" , from : \"4.0.0-beta\" ) . product ( name : \"FluentMySQLDriver\" , package : \"fluent-mysql-driver\" ) Once the dependencies are added, configure the database's credentials with Fluent using app.databases.use in configure.swift . import Fluent import FluentMySQLDriver app . databases . use (. mysql ( hostname : \"localhost\" , username : \"vapor\" , password : \"vapor\" , database : \"vapor\" ), as : . mysql ) You can also parse the credentials from a database connection string. try app . databases . use (. mysql ( url : \"<connection string>\" ), as : . mysql )","title":"MySQL"},{"location":"fluent/overview/#models","text":"Models represent fixed data structures in your database, like tables or collections. Models have one or more fields that store codable values. All models also have a unique identifier. Property wrappers are used to denote identifiers and fields as well as more complex mappings mentioned later. Take a look at the following model which represents a galaxy. final class Galaxy : Model { // Name of the table or collection. static let schema = \"galaxies\" // Unique identifier for this Galaxy. @ ID ( key : . id ) var id : UUID ? // The Galaxy's name. @ Field ( key : \"name\" ) var name : String // Creates a new, empty Galaxy. init () { } // Creates a new Galaxy with all properties set. init ( id : UUID ? = nil , name : String ) { self . id = id self . name = name } } To create a new model, create a new class conforming to Model . Tip It's recommended to mark model classes final to improve performance and simplify conformance requirements. The Model protocol's first requirement is the static string schema . static let schema = \"galaxies\" This property tells Fluent which table or collection the model corresponds to. This can be a table that already exists in the database or one that you will create with a migration . The schema is usually snake_case and plural.","title":"Models"},{"location":"fluent/overview/#identifier","text":"The next requirement is an identifier field named id . @ ID ( key : . id ) var id : UUID ? This field must use the @ID property wrapper. Fluent recommends using UUID and the special .id field key since this is compatible with all of Fluent's drivers. If you want to use a custom ID key or type, use the @ID(custom:) overload.","title":"Identifier"},{"location":"fluent/overview/#fields","text":"After the identifier is added, you can add however many fields you'd like to store additional information. In this example, the only additional field is the galaxy's name. @ Field ( key : \"name\" ) var name : String For simple fields, the @Field property wrapper is used. Like @ID , the key parameter specifies the field's name in the database. This is especially useful for cases where database field naming convention may be different than in Swift, e.g., using snake_case instead of camelCase . Next, all models require an empty init. This allows Fluent to create new instances of the model. init () { } Finally, you can add a convenience init for your model that sets all of its properties. init ( id : UUID ? = nil , name : String ) { self . id = id self . name = name } Using convenience inits is especially helpful if you add new properties to your model as you can get compile-time errors if the init method changes.","title":"Fields"},{"location":"fluent/overview/#migrations","text":"If your database uses pre-defined schemas, like SQL databases, you will need a migration to prepare the database for your model. Migrations are also useful for seeding databases with data. To create a migration, define a new type conforming to the Migration protocol. Take a look at the following migration for the previously defined Galaxy model. struct CreateGalaxy : Migration { // Prepares the database for storing Galaxy models. func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"galaxies\" ) . id () . field ( \"name\" , . string ) . create () } // Optionally reverts the changes made in the prepare method. func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"galaxies\" ). delete () } } The prepare method is used for preparing the database to store Galaxy models.","title":"Migrations"},{"location":"fluent/overview/#schema","text":"In this method, database.schema(_:) is used to create a new SchemaBuilder . One or more field s are then added to the builder before calling create() to create the schema. Each field added to the builder has a name, type, and optional constraints. field (< name >, < type >, < optional constraints >) There is a convenience id() method for adding @ID properties using Fluent's recommended defaults. Reverting the migration undoes any changes made in the prepare method. In this case, that means deleting the Galaxy's schema. Once the migration is defined, you must tell Fluent about it by adding it to app.migrations in configure.swift . app . migrations . add ( CreateGalaxy ())","title":"Schema"},{"location":"fluent/overview/#migrate","text":"To run migrations, call vapor run migrate from the command line or add migrate as an argument to Xcode's Run scheme. $ vapor run migrate Migrate Command: Prepare The following migration(s) will be prepared: + CreateGalaxy on default Would you like to continue? y/n> y Migration successful","title":"Migrate"},{"location":"fluent/overview/#querying","text":"Now that you've successfully created a model and migrated your database, you're ready to make your first query.","title":"Querying"},{"location":"fluent/overview/#all","text":"Take a look at the following route which will return an array of all the galaxies in the database. app . get ( \"galaxies\" ) { req in Galaxy . query ( on : req . db ). all () } In order to return a Galaxy directly in a route closure, add conformance to Content . final class Galaxy : Model , Content { ... } Galaxy.query is used to create a new query builder for the model. req.db is a reference to the default database for your application. Finally, all() returns all of the models stored in the database. If you compile and run the project and request GET /galaxies , you should see an empty array returned. Let's add a route for creating a new galaxy.","title":"All"},{"location":"fluent/overview/#create","text":"Following RESTful convention, use the POST /galaxies endpoint for creating a new galaxy. Since models are codable, you can decode a galaxy directly from the request body. app . post ( \"galaxies\" ) { req -> EventLoopFuture < Galaxy > in let galaxy = try req . content . decode ( Galaxy . self ) return galaxy . create ( on : req . db ) . map { galaxy } } Seealso See Content \u2192 Overview for more information about decoding request bodies. Once you have an instance of the model, calling create(on:) saves the model to the database. This returns an EventLoopFuture<Void> which signals that the save has completed. Once the save completes, return the newly created model using map . Build and run the project and send the following request. POST /galaxies HTTP / 1.1 content-length : 21 content-type : application/json { \"name\" : \"Milky Way\" } You should get the created model back with an identifier as the response. { \"id\" : ... , \"name\" : \"Milky Way\" } Now, if you query GET /galaxies again, you should see the newly created galaxy returned in the array.","title":"Create"},{"location":"fluent/overview/#relations","text":"What are galaxies without stars! Let's take a quick look at Fluent's powerful relational features by adding a one-to-many relation between Galaxy and a new Star model. final class Star : Model , Content { // Name of the table or collection. static let schema = \"stars\" // Unique identifier for this Star. @ ID ( key : . id ) var id : UUID ? // The Star's name. @ Field ( key : \"name\" ) var name : String // Reference to the Galaxy this Star is in. @ Parent ( key : \"galaxy_id\" ) var galaxy : Galaxy // Creates a new, empty Star. init () { } // Creates a new Star with all properties set. init ( id : UUID ? = nil , name : String , galaxyID : UUID ) { self . id = id self . name = name self . $ galaxy . id = galaxyID } }","title":"Relations"},{"location":"fluent/overview/#parent","text":"The new Star model is very similar to Galaxy except for a new field type: @Parent . @ Parent ( key : \"galaxy_id\" ) var galaxy : Galaxy The parent property is a field that stores another model's identifier. The model holding the reference is called the \"child\" and the referenced model is called the \"parent\". This type of relation is also known as \"one-to-many\". The key parameter to the property specifies the field name that should be used to store the parent's key in the database. In the init method, the parent identifier is set using $galaxy . self . $ galaxy . id = galaxyID By prefixing the parent property's name with $ , you access the underlying property wrapper. This is required for getting access to the internal @Field that stores the actual identifier value. Seealso Check out the Swift Evolution proposal for property wrappers for more information: [SE-0258] Property Wrappers Next, create a migration to prepare the database for handling Star . struct CreateStar : Migration { // Prepares the database for storing Star models. func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"stars\" ) . id () . field ( \"name\" , . string ) . field ( \"galaxy_id\" , . uuid , . references ( \"galaxies\" , \"id\" )) . create () } // Optionally reverts the changes made in the prepare method. func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"stars\" ). delete () } } This is mostly the same as galaxy's migration except for the additional field to store the parent galaxy's identifier. field ( \"galaxy_id\" , . uuid , . references ( \"galaxies\" , \"id\" )) This field specifies an optional constraint telling the database that the field's value references the field \"id\" in the \"galaxies\" schema. This is also known as a foreign key and helps ensure data integrity. Once the migration is created, add it to app.migrations after the CreateGalaxy migration. app . migrations . add ( CreateGalaxy ()) app . migrations . add ( CreateStar ()) Since migrations run in order, and CreateStar references the galaxies schema, ordering is important. Finally, run the migrations to prepare the database. Add a route for creating new stars. app . post ( \"stars\" ) { req -> EventLoopFuture < Star > in let star = try req . content . decode ( Star . self ) return star . create ( on : req . db ) . map { star } } Create a new star referencing the previously created galaxy using the following HTTP request. POST /stars HTTP / 1.1 content-length : 36 content-type : application/json { \"name\" : \"Sun\" , \"galaxy\" : { \"id\" : ... } } You should see the newly created star returned with a unique identifier. { \"id\" : ... , \"name\" : \"Sun\" , \"galaxy\" : { \"id\" : ... } }","title":"Parent"},{"location":"fluent/overview/#children","text":"Now let's take a look at how you can utilize Fluent's eager-loading feature to automatically return a galaxy's stars in the GET /galaxies route. Add the following property to the Galaxy model. // All the Stars in this Galaxy. @ Children ( for : \\ . $ galaxy ) var stars : [ Star ] The @Children property wrapper is the inverse of @Parent . It takes a key-path to the child's @Parent field as the for argument. Its value is an array of children since zero or more child models may exist. No changes to the galaxy's migration are needed since all the information needed for this relation is stored on Star .","title":"Children"},{"location":"fluent/overview/#eager-load","text":"Now that the relation is complete, you can use the with method on the query builder to automatically fetch and serialize the galaxy-star relation. app . get ( \"galaxies\" ) { req in Galaxy . query ( on : req . db ). with ( \\ . $ stars ). all () } A key-path to the @Children relation is passed to with to tell Fluent to automatically load this relation in all of the resulting models. Build and run and send another request to GET /galaxies . You should now see the stars automatically included in the response. [ { \"id\" : ... , \"name\" : \"Milky Way\" , \"stars\" : [ { \"id\" : ... , \"name\" : \"Sun\" , \"galaxy\" : { \"id\" : ... } } ] } ]","title":"Eager Load"},{"location":"fluent/overview/#siblings","text":"The last type of relationship is many-to-many, or sibling relationship. Create a Tag model with an id and name field that we'll use to tag stars with certain characteristics. final class Tag : Model , Content { // Name of the table or collection. static let schema : String = \"tags\" // Unique identifier for this Tag. @ ID ( key : . id ) var id : UUID ? // The Tag's name. @ Field ( key : \"name\" ) var name : String // Creates a new, empty Tag. init () {} // Creates a new Tag with all properties set. init ( id : UUID ? = nil , name : String ) { self . id = id self . name = name } } A tag can have many stars and a star can have many tags making them siblings. A sibling relationship between two models requires a third model (called a pivot) that holds the relationship data. Each of these StarTag model objects will represent a single star-to-tag relationship holding the ids of a single Star and a single Tag : final class StarTag : Model { // Name of the table or collection. static let schema : String = \"star_tag\" // Unique identifier for this pivot. @ ID ( key : . id ) var id : UUID ? // Reference to the Tag this pivot relates. @ Parent ( key : \"tag_id\" ) var tag : Tag // Reference to the Star this pivot relates. @ Parent ( key : \"star_id\" ) var star : Star // Creates a new, empty pivot. init () {} // Creates a new pivot with all properties set. init ( tagID : UUID , starID : UUID ) { self . $ tag . id = tagID self . $ star . id = starID } } Now let's update our new Tag model to add a stars property for all the stars that contain a tag: @ Siblings ( through : StarTag . self , from : \\ . $ tag , to : \\ . $ star ) var stars : [ Star ] The @Siblings property wrapper takes three arguments. The first argument is the pivot model that we created earlier, StarTag . The next two arguments are key paths to the pivot model's parent relations. The from key path is the pivot's parent relation to the current model, in this case Tag . The to key path is the pivot's parent relation to the related model, in this case Star . These three arguments together create a relation from the current model Tag , through the pivot StarTag , to the desired model Star . Now let's update our Star model with its siblings property which is the inverse of the one we just created: @ Siblings ( through : StarTag . self , from : \\ . $ star , to : \\ . $ tag ) var tags : [ Tag ] These siblings properties rely on StarTag for storage so we don't need to update the Star migration, but we do need to create migrations for the new Tag and StarTag models: struct CreateTag : Migration { func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"tags\" ) . id () . field ( \"name\" , . string ) . create () } func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"tags\" ). delete () } } struct CreateStarTag : Migration { func prepare ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"star_tag\" ) . id () . field ( \"star_id\" , . uuid , . required , . references ( \"star\" , \"id\" )) . field ( \"tag_id\" , . uuid , . required , . references ( \"star\" , \"id\" )) . create () } func revert ( on database : Database ) -> EventLoopFuture < Void > { database . schema ( \"star_tag\" ). delete () } } And then add the migrations in configure.swift: app . migrations . add ( CreateTag ()) app . migrations . add ( CreateStarTag ()) Now we want to add tags to stars. After creating a route to create a new tag, we need to create a route that will add a tag to an existing star. app . post ( \"star\" , \":starID\" , \"tag\" , \":tagID\" ) { req -> EventLoopFuture < HTTPStatus > in let star = Star . find ( req . parameters . get ( \"starID\" ), on : req . db ) . unwrap ( or : Abort (. notFound )) let tag = Tag . find ( req . parameters . get ( \"tagID\" ), on : req . db ) . unwrap ( or : Abort (. notFound )) return star . and ( tag ). flatMap { ( star , tag ) in star . $ tags . attach ( tag , on : req . db ) }. transform ( to : . ok ) } This route includes parameter path components for the IDs of star and tag that we want to associate with one another. If we want to create a relationship between a star with an ID of 1 and a tag with an ID of 2, we'd send a POST request to /star/1/tag/2 and we'd receive an HTTP response code in return. First, we lookup the star and tag in the database to ensure these are valid IDs. Then, we create the relationship by attaching the tag to the star's tags. Since the star's tags property is a relationship to another model, we need to access it via it's @Siblings property wrapper by using the $ operator. Siblings aren't fetched by default so we need to update our get route for stars if we want include them when querying by inserting the with method: app . get ( \"stars\" ) { req in Star . query ( on : req . db ). with ( \\ . $ tags ). all () }","title":"Siblings"},{"location":"fluent/overview/#lifecycle","text":"To create hooks that respond to events on your Model , you can create middlewares for your model. Your middleware must conform to ModelMiddleware . Here is an example of a simple middleware: struct GalaxyMiddleware : ModelMiddleware { // Runs when a model is created func create ( model : Galaxy , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { return next . create ( model , on : db ) } // Runs when a model is updated func update ( model : Galaxy , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { return next . update ( model , on : db ) } // Runs when a model is soft deleted func softDelete ( model : Galaxy , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { return next . softDelete ( model , on : db ) } // Runs when a soft deleted model is restored func restore ( model : Galaxy , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { return next . restore ( model , on : db ) } // Runs when a model is deleted // If the \"force\" parameter is true, the model will be permanently deleted, // even when using soft delete timestamps. func delete ( model : Galaxy , force : Bool , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { return next . delete ( model , force : force , on : db ) } } Each of these methods has a default implementation, so you only need to include the methods you require. You should return the corresponding method on the next AnyModelResponder so Fluent continues processing the event. Important The middleware will only respond to lifecycle events of the Model type provided in the functions. In the above example GalaxyMiddleware will respond to events on the Galaxy model. Using these methods you can perform actions both before, and after the event completes. Performing actions after the event completes can be done using using .flatMap() on the future returned from the next responder. For example: struct GalaxyMiddleware : ModelMiddleware { func create ( model : Galaxy , on db : Database , next : AnyModelResponder ) -> EventLoopFuture < Void > { // The model can be altered here before it is created model . name = \"<New Galaxy Name>\" return next . create ( model , on : db ). flatMap { // Once the galaxy has been created, the code here will be executed print ( \"Galaxy \\( model . name ) was created\" ) } } } Once you have created your middleware, you must register it with the Application 's database middleware configuration so Vapor will use it. In configure.swift add: app . databases . middleware . use ( GalaxyMiddleware (), on : . psql )","title":"Lifecycle"},{"location":"fluent/overview/#timestamps","text":"Fluent provides the ability to track creation and update times on models by specifying Timestamp fields in your model. Fluent automatically sets the fields when necessary. You can add these like so: @ Timestamp ( key : \"created_at\" , on : . create ) var createdAt : Date ? @ Timestamp ( key : \"updated_at\" , on : . update ) var updatedAt : Date ? Info You can use any name/key for these fields. created_at / updated_at , are only for illustration purposes Timestamps are added as fields in a migration using the .datetime data type. database . schema (...) ... . field ( \"created_at\" , . datetime ) . field ( \"updated_at\" , . datetime ) . create ()","title":"Timestamps"},{"location":"fluent/overview/#soft-delete","text":"Soft deletion marks an item as deleted in the database but doesn't actually remove it. This can be useful when you have data retention requirements, for example. In Fluent, it works by setting a deletion timestamp. By default, soft deleted items won't appear in queries and can be restored at any time. Similar to created and deleted timestamps, to enable soft deletion in a model just set a deletion timestamp for .delete : @ Timestamp ( key : \"deleted_at\" , on : . delete ) var deletedAt : Date ? Calling Model.delete(on:) on a model that has a delete timestamp property will automatically soft delete it. If you need to perform a query that includes the soft deleted items, you can use withDeleted() in your query. // Get all galaxies including soft-deleted ones. Galaxy . query ( on : db ). withDeleted (). all () You can restore a soft deleted model with restore(on:) : // Restore galaxy galaxy . restore ( on : db ) To permanently delete an item with an on-delete timestamp, use the force parameter: // Permanently delete galaxy . delete ( force : true , on : db )","title":"Soft Delete"},{"location":"fluent/overview/#next-steps","text":"Congratulations on creating your first models and migrations and performing basic create and read operations. For more in-depth information on all of these features, check out their respective sections in the Fluent guide.","title":"Next Steps"},{"location":"fluent/query-builder/","text":"Query Builder \u00b6 Coming soon.","title":"Query Builder"},{"location":"fluent/query-builder/#query-builder","text":"Coming soon.","title":"Query Builder"},{"location":"fluent/relations/","text":"Relations \u00b6 Coming soon.","title":"Relations"},{"location":"fluent/relations/#relations","text":"Coming soon.","title":"Relations"},{"location":"i18n/cn/","text":"Redirecting... \u00b6","title":"Chinese (Simplified)"},{"location":"i18n/cn/#redirecting","text":"","title":"Redirecting..."},{"location":"install/macos/","text":"Install on macOS \u00b6 To use Vapor on macOS, you will need Swift 5.2 or greater. Swift and all of its dependencies come bundled with Xcode. Install Xcode \u00b6 Install Xcode 11 or greater from the Mac App Store. Warning At the time of writing, Xcode 11.4 which includes Swift 5.2 is in beta. You can download it from the developer portal or download the latest Swift 5.2 toolchain from Swift.org . After Xcode has been downloaded, you must open it to complete the installation. This may take a while. Double check to ensure that the installation was successful by opening the Terminal and printing the Swift's version. swift --version You should see Swift's version information printed. Apple Swift version 5 .2 ( swiftlang-1100.0.270.13 clang-1100.0.33.7 ) Target: x86_64-apple-darwin19.0.0 Vapor 4 requires Swift 5.2 or greater. Install Toolbox \u00b6 Now that you have Swift installed, let us install the Vapor Toolbox . This CLI tool is not required to use Vapor but it includes helpful utilities like a new project creator. Toolbox is distributed via Homebrew. If you do not have Homebrew yet, visit brew.sh for install instructions. brew install vapor/tap/vapor-beta Double check to ensure that the installation was successful by printing help. vapor-beta --help You should see a list of available commands. Next \u00b6 Now that you have installed Swift and Vapor Toolbox, create your first app in Getting Started \u2192 Hello, world .","title":"macOS"},{"location":"install/macos/#install-on-macos","text":"To use Vapor on macOS, you will need Swift 5.2 or greater. Swift and all of its dependencies come bundled with Xcode.","title":"Install on macOS"},{"location":"install/macos/#install-xcode","text":"Install Xcode 11 or greater from the Mac App Store. Warning At the time of writing, Xcode 11.4 which includes Swift 5.2 is in beta. You can download it from the developer portal or download the latest Swift 5.2 toolchain from Swift.org . After Xcode has been downloaded, you must open it to complete the installation. This may take a while. Double check to ensure that the installation was successful by opening the Terminal and printing the Swift's version. swift --version You should see Swift's version information printed. Apple Swift version 5 .2 ( swiftlang-1100.0.270.13 clang-1100.0.33.7 ) Target: x86_64-apple-darwin19.0.0 Vapor 4 requires Swift 5.2 or greater.","title":"Install Xcode"},{"location":"install/macos/#install-toolbox","text":"Now that you have Swift installed, let us install the Vapor Toolbox . This CLI tool is not required to use Vapor but it includes helpful utilities like a new project creator. Toolbox is distributed via Homebrew. If you do not have Homebrew yet, visit brew.sh for install instructions. brew install vapor/tap/vapor-beta Double check to ensure that the installation was successful by printing help. vapor-beta --help You should see a list of available commands.","title":"Install Toolbox"},{"location":"install/macos/#next","text":"Now that you have installed Swift and Vapor Toolbox, create your first app in Getting Started \u2192 Hello, world .","title":"Next"},{"location":"install/ubuntu/","text":"Install on Ubuntu \u00b6 To use Vapor on Ubuntu, you will need Swift 5.2 or greater. This can be installed using the toolchains available on Swift.org Supported Versions \u00b6 Vapor supports the same versions of Ubuntu that Swift 5.2 supports. Version Codename 18.04 Bionic Beaver 16.04 Xenial Xerus Installation \u00b6 Visit Swift.org's Using Downloads guide for instructions on how to install Swift on Linux. Docker \u00b6 You can also use Swift's official Docker images which come with the compiler preinstalled. Learn more at Swift's Docker Hub . Install Toolbox \u00b6 Now that you have Swift installed, let's install the Vapor Toolbox . This CLI tool is not required to use Vapor, but it includes helpful utilities. On Linux, you will need to build the toolbox from source. View the toolbox's releases on GitHub to find the latest version. git clone https://github.com/vapor/toolbox.git cd toolbox git checkout <desired version> swift build -c release --disable-sandbox mv .build/release/vapor /usr/local/bin Double check the installation was successful by printing help. vapor --help You should see a list of available commands. Next \u00b6 After you have installed Swift, create your first app in Getting Started \u2192 Hello, world .","title":"Ubuntu"},{"location":"install/ubuntu/#install-on-ubuntu","text":"To use Vapor on Ubuntu, you will need Swift 5.2 or greater. This can be installed using the toolchains available on Swift.org","title":"Install on Ubuntu"},{"location":"install/ubuntu/#supported-versions","text":"Vapor supports the same versions of Ubuntu that Swift 5.2 supports. Version Codename 18.04 Bionic Beaver 16.04 Xenial Xerus","title":"Supported Versions"},{"location":"install/ubuntu/#installation","text":"Visit Swift.org's Using Downloads guide for instructions on how to install Swift on Linux.","title":"Installation"},{"location":"install/ubuntu/#docker","text":"You can also use Swift's official Docker images which come with the compiler preinstalled. Learn more at Swift's Docker Hub .","title":"Docker"},{"location":"install/ubuntu/#install-toolbox","text":"Now that you have Swift installed, let's install the Vapor Toolbox . This CLI tool is not required to use Vapor, but it includes helpful utilities. On Linux, you will need to build the toolbox from source. View the toolbox's releases on GitHub to find the latest version. git clone https://github.com/vapor/toolbox.git cd toolbox git checkout <desired version> swift build -c release --disable-sandbox mv .build/release/vapor /usr/local/bin Double check the installation was successful by printing help. vapor --help You should see a list of available commands.","title":"Install Toolbox"},{"location":"install/ubuntu/#next","text":"After you have installed Swift, create your first app in Getting Started \u2192 Hello, world .","title":"Next"},{"location":"version/1_5/","text":"Redirecting... \u00b6","title":"1.5"},{"location":"version/1_5/#redirecting","text":"","title":"Redirecting..."},{"location":"version/2_0/","text":"Redirecting... \u00b6","title":"2.0"},{"location":"version/2_0/#redirecting","text":"","title":"Redirecting..."},{"location":"version/3_0/","text":"Redirecting... \u00b6","title":"3.0"},{"location":"version/3_0/#redirecting","text":"","title":"Redirecting..."},{"location":"version/4_0/","text":"Redirecting... \u00b6","title":"4.0"},{"location":"version/4_0/#redirecting","text":"","title":"Redirecting..."}]}